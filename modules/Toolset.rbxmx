<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="ModuleScript" referent="RBXEE166C7C14D048E69F65F7290FE11C97">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">Toolset</string>
			<string name="ScriptGuid">{5AB4DAEC-61E6-4944-9974-334008DEF19E}</string>
			<ProtectedString name="Source"><![CDATA[local RepStorage = game:GetService("ReplicatedStorage")
local Collections = game:GetService("CollectionService")
local StarterPack = game:GetService("StarterPack")
local ServerStorage = game:GetService("ServerStorage")
local StarterPlayer = game:GetService("StarterPlayer")
local StarterGui = game:GetService("StarterGui")
local Players = game:GetService("Players")
local Physics = game:GetService("PhysicsService")

local OverwriteTable = nil
local OverwriteIncompatibleSettings = nil

function Load(Settings)
	local GlobalTable = {}

	local SettingsScript = script.DefaultSettings
	local ModSettings = require(SettingsScript.ModifiableSettingsArrays)
	local Directories = script.Directories
	local NewSettings = require(SettingsScript)
	
	OverwriteTable(NewSettings, Settings)

	SettingsScript.Name = "BB_Settings"
	SettingsScript.Parent = RepStorage
	
	OverwriteIncompatibleSettings(NewSettings)
	
	-- Handle ThemePacks
	local themes = Directories.ReplicatedStorage.Themes
	for _, Module in pairs(NewSettings.Themes.ThemePacks) do
		local ThemePack = require(Module)
		if type(ThemePack) == "userdata" then
			if ThemePack:IsA("Folder") then
				for _, Theme in pairs(ThemePack:GetChildren()) do
					if Theme:IsA("Folder") then
						local current = themes:FindFirstChild(Theme.Name)
						if current then
							warn("Theme with same name found, overriding:", current)
							pcall(game.Destroy, current)
						end

						Theme.Parent = themes
					else
						warn("Theme inside themepack must be a folder, not adding:", Theme)
					end
				end
			else
				warn("Improper class for themepack: class must be a folder")
			end
		else
			warn("Improper type for themepack: type() must return userdata (folder)")
		end
	end
	
	-- Set physics properties (these are all used entirely locally)
	local PhysicsTable = {
		Superballs = {
			PlayerParts = false;
			Superballs = false;
			Pellets = false;
			JumpyPellets = false;
		};
		JumpySuperballs = {
			JumpySuperballs = false;
			PlayerParts = true;
			Superballs = false;
			Pellets = false;
			JumpyPellets = false;
		};
		Pellets = {
			PlayerParts = false;
			JumpyPellets = false;
		};
		JumpyPellets = {
			PlayerParts = true;
		};
		Paintballs = {
			PlayerParts = false;
			Superballs = false;
			JumpySuperballs = false;
			Pellets = false;
			JumpyPellets = false;
		};
		BombJumpBombs = {};
		RideableRockets = {
			Default = false;
			Superballs = false;
			JumpySuperballs = false;
			Pellets = false;
			Paintballs = false;
			JumpyPellets = false;
		};
		PlayerParts = {
			RideableRockets = true;
			BombJumpBombs = false;
		};
	}
	
	for Group, _ in pairs(PhysicsTable) do
		Physics:CreateCollisionGroup(Group)
	end
	
	for Group, Table in pairs(PhysicsTable) do
		for OtherGroup, Collidable in pairs(Table) do
			Physics:CollisionGroupSetCollidable(Group, OtherGroup, Collidable)
		end
	end
	
	-- Return settings upon client request
	local CallbacksReparented = false
	local CallbacksReparented_ = Instance.new("BindableEvent")
	Directories.ReplicatedStorage.ToolNetworking.AcquireSettings.OnServerInvoke = function()
		if CallbacksReparented == false then
			CallbacksReparented_.Event:Wait()
		end
		return NewSettings
	end
	
	-- Remove filtered weapons
	for _, Tool in pairs(script.Directories.StarterPack:GetChildren()) do
		local Tool_Filtered = table.find(NewSettings.WeaponsFiltered, Tool.Name) ~= nil
		if Tool_Filtered ~= NewSettings.WeaponsFilterType then
			Tool.Parent = ServerStorage
		end
	end
	
	-- If existent, parent weapons to custom directory
	if NewSettings.CustomWeaponsDirectory then
		for _,Tool in pairs(script.Directories.StarterPack:GetChildren()) do
			Tool.Parent = Settings.CustomWeaponsDirectory
		end
		script.Directories.StarterPack:Destroy()
	end
	
	local repStorage = Directories.ReplicatedStorage
	
	local TimeValue = repStorage.SERVER_TIME
	local Remotes = repStorage.ToolNetworking
	local Modules = repStorage.ToolModules
	local ProjectileFolder = Directories.Workspace.Projectiles
	local ActiveFolder = ProjectileFolder.Active
	local BufferFolder = ProjectileFolder.Buffers -- for trowels
	
	-- Distribute objects
	require(script.DistributeObjects)(script.Directories)

	-- Construct global table
	GlobalTable.Settings = NewSettings
	GlobalTable.Modules = Modules
	GlobalTable.Remotes = Remotes
	GlobalTable.ProjectileFolder = ProjectileFolder
	GlobalTable.MasterTimeTable = {}
	GlobalTable.ProjectileCounts = {}
	GlobalTable.ServerTime = TimeValue
	
	-- Handle callbacks
	local Callbacks = SettingsScript:WaitForChild("Callbacks")
	Callbacks.Parent = Modules
	
	local approved = {}
	for name, module in pairs(NewSettings.Callbacks) do
		if typeof(module) == "Instance" 
			and module:IsA("ModuleScript") 
			and type(require(module)) == "function" then
			table.insert(approved, module)
			module.Name = name
			module.Parent = Callbacks
		end
	end
	
	for _, child in pairs (Callbacks:GetChildren()) do
		if not table.find(approved, child) then
			child:Destroy() -- delete unnecessary extrenuous modules
		end
	end
	
	CallbacksReparented = true
	CallbacksReparented_:Fire()
	game:GetService("Debris"):AddItem(CallbacksReparented_, 0)
	
	-- Functions to load weapons and data for players	
	local function CreateProjectileFolders(Player)
		local PlayerBufferFolder = Instance.new("Folder")
		PlayerBufferFolder.Name = Player.Name
		PlayerBufferFolder.Parent = BufferFolder
		
		local PlayerActiveFolder = Instance.new("Folder")
		PlayerActiveFolder.Name = Player.Name
		PlayerActiveFolder.Parent = ActiveFolder
	end
	
	local function AddBufferValues(Player)
		local Buffers = Player:FindFirstChild("Buffers")
		if not Buffers then
			StarterPlayer:FindFirstChild("Buffers"):Clone().Parent = Player
		end
	end
	
	local function LoadModule(Tool,Buffers,Player,Character)
		local ServerFolder = Tool:WaitForChild("Server",1)
		local ServerModule = ServerFolder and ServerFolder:FindFirstChildWhichIsA("ModuleScript")
		if ServerModule then
			--print("Initializing:",Tool.Name,"| For:",Player.Name)
			require(ServerModule):Init(NewSettings, Modules, Buffers, Player, Character, ProjectileFolder)
		end
	end
	
	local function AddCharacter(Player, Character)		
		local Buffers = Player:WaitForChild("Buffers")
		--[[if not Character then
			return
		end]]
		
		if not Collections:HasTag(Character, "ToolsLoaded") then
			local Backpack = Player:WaitForChild("Backpack")
			Collections:AddTag(Character, "ToolsLoaded")
			
			-- Ensure player has weapons
			local spawnedWithout = 0
			if not NewSettings.CustomWeaponsDirectory then
				for _, tool in pairs (StarterPack:GetChildren()) do
					if not Backpack:FindFirstChild(tool.Name) then
						spawnedWithout += 1
						tool:Clone().Parent = Backpack
					end
				end
			end
			
			if spawnedWithout > 0 then
				--print(Player.Name.." spawned without", spawnedWithout, "tools.")
			end
			
			-- Load weapon
			for _,Tool in pairs(Backpack:GetChildren()) do
				task.spawn(LoadModule, Tool, Buffers, Player, Character)
			end
		end
	end
	
	local function AddPlayer(Player)
		local emptyTable = {
			Superballs = 0;
			Rockets = 0;
			Pellets = 0;
			Bombs = 0;
			Walls = 0;
			Paintballs = 0;
		}
		
		local directory = _G.BB and _G.BB or GlobalTable
		directory.MasterTimeTable[Player.Name] = {}
		directory.ProjectileCounts[Player.Name] = emptyTable
		
		local Theme = Instance.new("StringValue")
		Theme.Name = "Theme"
		Theme.Value = "Normal"
		Theme.Parent = Player
		task.spawn(CreateProjectileFolders,Player)
		task.spawn(AddBufferValues,Player)
	end
	
	local function RemovePlayer(Player)
		local PlayerBufferFolder = BufferFolder:WaitForChild(Player.Name,1)
		local PlayerActiveFolder = ActiveFolder:WaitForChild(Player.Name,1)
		if PlayerBufferFolder then
			PlayerBufferFolder:Destroy()
		end
		if PlayerActiveFolder then
			PlayerActiveFolder:Destroy()
		end
		_G.BB.ProjectileCounts[Player.Name] = nil
	end
	
	-- Release global table
	GlobalTable.LoadModule = LoadModule
	GlobalTable.InitializeServer = AddCharacter
	_G.BB = GlobalTable
	
	-- Load player modules
	require(script.LoadPlayerModules)(AddPlayer, RemovePlayer, AddCharacter)
	
	
	-- Distribute checker script to ensure players have mandatory client scripts
	for _, Player in pairs (Players:GetPlayers()) do
		if not Player:WaitForChild("PlayerGui"):FindFirstChild("Checker") then
			StarterGui.Checker:Clone().Parent = Player.PlayerGui
		end
	end
	
	-- Create security part that is used in Explosion and PSPV
	local SecurityPart = Instance.new("Part")
	SecurityPart.Shape = Enum.PartType.Ball
	SecurityPart.Transparency = 1
	SecurityPart.CanCollide = false
	SecurityPart.Anchored = true
	SecurityPart.Parent = workspace
	SecurityPart.Touched:Connect(function() end)
	
	-- Initialize & hook up remotes
	require(Modules.Explosion):RegisterEvents()
	require(Modules.Hit):RegisterEvents()
	require(Modules.Security):Init(SecurityPart, script.SecurityDummy, TimeValue)
	require(script.CustomPhysicsReplicator):Init(Remotes, Modules)
	
	script.Parent = game:GetService("ServerScriptService")
end


function GetValueFromPathArray(Table, PathArray, Depth)
	if not Depth then
		Depth = 1
	end
	for Key,Value in pairs(Table) do
		if Key == PathArray[Depth] then
			if typeof(Value) == "table" then
				return GetValueFromPathArray(Value, PathArray, Depth + 1)
			else
				return Value
			end
		end
	end
end

function ClearArray(Array)
	while #Array > 0 do
		table.remove(Array)
	end
end

function OverwriteTable(To, From, PathArray)
	if PathArray == nil then
		PathArray = {}
	end
	if typeof(From) == "table" and typeof(To) == "table" then
		for Key, Value in pairs(From) do

			if typeof(Value) == "table" then
				OverwriteTable(To[Key], Value)
			else
				if To[Key] == nil and type(Key) ~= "number" then
					warn("Key not found in default settings (attempting to override):", Key, Value)
				end
				To[Key] = Value
			end
		end
	end
end

function OverwriteIncompatibleSettings(T)
	if T.InstantDamage then
		if (
			T.Security.Initial.Deactivate
				or T.Security.Update.Deactivate
				or T.Security.Hit.Deactivate
			) and T.Security.Master then

			warn("InstantDamage disabled (not compatible with Deactivate settings in Security).")
			T.InstantDamage = false
		end
	end
	if T.SlingClimb and T.Doomspire.SlingFly then
		T.SlingClimb = false
	end
end

return Load

--[[
	Under _G.BB (Server):
	- Settings: The default settings that were overriden by the requirer's changes
	- Modules: Directory of the modules used by the toolset
	- Remotes: Directory of the remotes used by the toolset
	- ProjectileFolder: Directory of the projectiles (would be physics folders from server's POV)
	- ServerTime: Number value that holds the last tick of the last heartbeat
	- MasterTimeTable: Dictionary that CFrames of chracters every heartbeat when PSPV is on
	- ProjectileCounts: Dictionary with tool names as keys and the fire count as values
	- InitializeServer: A function that ensures the player has the necessary weapons and loads their server modules
	- LoadModule: A function that loads the server modules of a specific weapon
]]]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Folder" referent="RBX773E2FD119E54856A94809F989AC3854">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">Directories</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBX221B089A2AF04FA0BACB6D7A7B6EFE1A">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">ReplicatedStorage</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBXE06C252043574D50B47E1EAC55B79752">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">ToolNetworking</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="RemoteEvent" referent="RBX705112CE984647B4AC1A0D4F25DE0224">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Explosion</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX8BB7BD6B569444D5A0DE1829622ECAB1">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Hit</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX9F60B89BE5F242448F04C2683688DF1E">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">UpdatePhysics</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXE3735E260397487CB239A28CD7E365E8">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Ping</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteFunction" referent="RBXA945681EB8B64CC68242A9384673CE45">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">AcquireSettings</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="BindableEvent" referent="RBX41836551D84C49819814B1D57AD51961">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">ThemeActivation</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX9F7D112E5C6B4B25B542D23F3B8CD05A">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Delete</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXDB984FAD50C04ACB86F4D2E80CCB742B">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">ToolModules</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXB6DE322A59854E0AB924B414E96D1898">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Aesthetics</string>
							<string name="ScriptGuid">{DDE10478-2756-43C6-AC4F-C3BA5889036F}</string>
							<ProtectedString name="Source"><![CDATA[-- GloriedRage
-- Module used for determining aesthetics of explosions and hit indicators.
local Aesthetics = {}

local repStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Debris = game:GetService("Debris")
local TweenService = game:GetService("TweenService")
local Physics = game:GetService("PhysicsService")
local RunService = game:GetService("RunService")
local CollectionService = game:GetService("CollectionService")

-- Yield for themes folder
local ThemesFolder = repStorage:WaitForChild("Themes")

local BrightnessRange = {
	Min = .15,
	Max = .85
}

local swordTrailLoop = nil

Aesthetics.TrailTypes  = {
	"Trail",
	"Fire",
	"ParticleEmitter",
	"Smoke",
	"Beam"
}


local function themesOn()
	return _G.BB.Local and _G.BB.Local.Themes 
end

local function themesHighGraphics()
	return _G.BB.Local and _G.BB.Local.ThemesHighGraphics
end

local function returnRandomBrickColor(ctable)
	return BrickColor.new(ctable[math.random(1, #ctable)])		
end

function Aesthetics:HasNeutralColors(Player)

	local teamName = Player.Team and Player.Team.Name

	if not _G.BB.Settings.AutoTeamColors then
		return true
	end

	if _G.BB.Settings.ThemeOverrides then
		local theme = Player:FindFirstChild("Theme")

		-- do not override if theme is normal/default theme
		if theme and theme.Value ~= _G.BB.Settings.Themes.DefaultTheme then
			return true
		end
	end

	return Player.Neutral or table.find(_G.BB.Settings.TeamsFiltered, teamName)
end

function Aesthetics:DetermineTheme(Player)
	local themeVal = Player:WaitForChild("Theme")
	local theme = themeVal and themeVal.Value

	local base = (themesOn() and themeVal) and theme or _G.BB.Settings.Themes.DefaultTheme
	local teamColor = not self:HasNeutralColors(Player) and "Team Color"

	return teamColor or base or _G.BB.Settings.Themes.DefaultTheme
end

function Aesthetics:GetThemeObject(Player, ObjectName)
	local Theme = self:DetermineTheme(Player)

	local ThemeFolder = (Theme and Theme ~= "Team Color") 
		and ThemesFolder:FindFirstChild(Theme) 
		or ThemesFolder:FindFirstChild("Normal")

	local Object = ThemeFolder and ThemeFolder:FindFirstChild(ObjectName)

	return Object,Theme
end

function Aesthetics:RandomColor()
	return Color3.new(
		math.random(BrightnessRange.Min*1000,BrightnessRange.Max*1000)/1000,
		math.random(BrightnessRange.Min*1000,BrightnessRange.Max*1000)/1000,
		math.random(BrightnessRange.Min*1000,BrightnessRange.Max*1000)/1000
	)
end

function Aesthetics:GetColorAtTime(Sequence, Time)

	local LowerBound, UpperBound = Sequence.Keypoints[1], Sequence.Keypoints[#Sequence.Keypoints]

	for i = 1, #Sequence.Keypoints do
		local Keypoint = Sequence.Keypoints[i]
		if Time - Keypoint.Time >= 0 and Time - Keypoint.Time < Time - LowerBound.Time then
			LowerBound = Keypoint
		end
		if Keypoint.Time - Time >= 0 and Keypoint.Time - Time < UpperBound.Time - Time then
			UpperBound = Keypoint
		end
	end

	Time = Time - LowerBound.Time

	return LowerBound.Value:Lerp(UpperBound.Value, Time)
end

--Handle animated textures
local function animateTexture(t)
	local uSpeed = t:FindFirstChild("UOffsetSpeed") and t.UOffsetSpeed.Value or 0
	local vSpeed = t:FindFirstChild("VOffsetSpeed") and t.VOffsetSpeed.Value or 0

	if uSpeed == 0 and vSpeed == 0 then return end

	if uSpeed ~= 0 then
		local tweenInfo = TweenInfo.new(uSpeed, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, -1, false, 0)
		local uTween = TweenService:Create(t, tweenInfo, {OffsetStudsU = 30})
		uTween:Play()
		t.Destroying:Connect(function() uTween:Destroy() end)
	end

	if vSpeed ~= 0 then
		local tweenInfo = TweenInfo.new(vSpeed, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, -1, false, 0)
		local vTween = TweenService:Create(t, tweenInfo, {OffsetStudsV = 30})
		vTween:Play()
		t.Destroying:Connect(function() vTween:Destroy() end)
	end

end

function Aesthetics:HandleSBHandle(Player, handle, colorEvent, initial)

	local ThemeValue = Player:WaitForChild("Theme")

	local function themeChanged()
		-- Update handle
		local Folder, Theme = self:GetThemeObject(Player, "Superball")
		local Part = Folder:FindFirstChildWhichIsA("Part")
		handle.Material = Part.Material
		handle.Reflectance = Part.Reflectance
		handle.Transparency = Part.Transparency
		
		if initial then
			for _,v in pairs(handle:GetChildren()) do
				if v:IsA("ParticleEmitter") or v:IsA("Fire") or v:IsA("Trail") or v:IsA("Smoke") or v:IsA("Texture") then
					v:Destroy()
				end
			end
			
			for _,v in pairs(Part:GetChildren()) do
				if v:IsA("Texture") then
					local vv = v:Clone()
					vv.Parent = handle
					if vv:FindFirstChild("UOffsetSpeed") or vv:FindFirstChild("VOffsetSpeed") then
						animateTexture(vv)
					end
				end
			end
		end

		local NonCustomThemes = {
			_G.BB.Settings.Themes.DefaultTheme,
			"Team Color",
		}

		handle.Color = (themesOn() and not table.find(NonCustomThemes, Theme)) 
			and (Part.Color)
			or Theme == "Team Color"
			and Player.TeamColor.Color 
			or (_G.BB.Settings.Themes.RandomSuperballColors 
				and self:RandomColor() 
				or Part.Color)

		colorEvent:FireServer(handle.Color, handle.Transparency, handle.Reflectance, handle.Material)
	end

	themeChanged()

	if initial then
		ThemeValue.Changed:Connect(themeChanged)
		_G.BB.Remotes:WaitForChild("ThemeActivation").Event:Connect(themeChanged)
	end	
end

function Aesthetics:HandleSword(Player, handle, Server)
	local ThemeValue = Player:WaitForChild("Theme")
	local Connection

	local function ColorSword()
		local Folder = self:GetThemeObject(Player, "Sword")

		local HandleRef = Folder:FindFirstChildWhichIsA("Part")
		handle.Color = HandleRef.Color
		handle.Reflectance = HandleRef.Reflectance
		handle.Transparency = HandleRef.Transparency
		handle.Material = HandleRef.Material

		local Mesh = HandleRef:FindFirstChildWhichIsA("SpecialMesh")
		local myMesh = handle:WaitForChild("Mesh", 3)
		if myMesh then
			myMesh.TextureId = Mesh.TextureId
			myMesh.VertexColor = Mesh.VertexColor
		end
	end

	local function AssignColors()
		ColorSword()
		local HasTrail = self:CreateSwordTrail(handle,Player)
		if not Server and (HasTrail or not _G.BB.Local.Themes) then
			if not Connection then
				Connection = handle.DescendantAdded:Connect(function(Child)
					if Child.Name == "ServerTrail" then
						game:GetService('Debris'):AddItem(Child,0)
					end
				end)
			end

			for _,Child in pairs(handle:GetDescendants()) do
				if Child.Name == "ServerTrail" then
					Child:Destroy()
				end
			end
		end
	end

	local function themeChanged()
		for _,Child in pairs(handle:GetDescendants()) do
			if table.find(Aesthetics.TrailTypes,Child.ClassName) then
				Child:Destroy()
			end
		end
		AssignColors()
	end

	if not Server then
		_G.BB.Remotes:WaitForChild("ThemeActivation").Event:Connect(themeChanged)
	end

	AssignColors()

	ThemeValue.Changed:Connect(themeChanged)
end

function Aesthetics:ToggleThemes(value)
	if _G.BB == nil then
		warn("Global table not found, yielding.")
		while _G.BB == nil do
			task.wait()
		end
	end

	local Themes


	if value == nil or type(value) ~= "boolean" then
		Themes = not _G.BB.Local.Themes
	else
		Themes = value
	end

	_G.BB.Local.Themes = Themes


	_G.BB.Remotes:WaitForChild("ThemeActivation"):Fire()

	if swordTrailLoop then
		swordTrailLoop:Disconnect()
	end

	if Themes then
		return
	end

	-- Run through every single player and toggle their trail off every render step
	swordTrailLoop = RunService.RenderStepped:Connect(function()
		for _, Plr in pairs (Players:GetPlayers()) do
			if Plr.Character and Plr ~= Players.LocalPlayer then
				local Sword = Plr.Character:FindFirstChild("Sword") or Plr.Backpack:FindFirstChild("Sword")
				if Sword then
					local Handle = Sword:FindFirstChild("Handle")
					if Handle then
						for _, Desc in pairs (Handle:GetDescendants()) do
							if table.find(Aesthetics.TrailTypes,Desc.ClassName) then
								game:GetService("Debris"):AddItem(Desc,0)
							end
						end
					end
				end
			end
		end
	end)

	return Themes
end


function Aesthetics:CreateSwordTrail(Handle, Creator, Server)

	local Reference,Theme = Aesthetics:GetThemeObject(Creator,"Sword")
	local Children = Reference:FindFirstChildWhichIsA("Part"):GetChildren()

	local AddedTrail = false
	for _,Trail in pairs(Children) do
		if not (Trail and Trail.ClassName and table.find(Aesthetics.TrailTypes,Trail.ClassName)) then 
			--warn("No trail for",Creator,"with theme",Theme) 
			continue 
		end
		AddedTrail = true

		if Trail:IsA("Trail") then -- could also be a fire
			Trail = Trail:Clone()

			if Theme == "Team Color" then
				Handle.Color = Creator.TeamColor
			end

			if Theme == "Team Color" or Theme == "Normal" then
				Trail.Color = Aesthetics:CustomColorSequence(Handle.Color)
			end

			Trail.Attachment0 = Handle:WaitForChild("A0")
			Trail.Attachment1 = Handle:WaitForChild("A1")
			Trail.FaceCamera = false
			Trail.Enabled = false
			Trail.Name = Server and "ServerTrail" or "ClientTrail"
			Trail.Parent = Handle

		elseif table.find(Aesthetics.TrailTypes,Trail.ClassName) then

			for _,Child in pairs(Handle:GetChildren()) do

				if Child:IsA("Attachment")then

					Trail = Trail:Clone()
					Trail.Enabled = false
					Trail.Name = Server and "ServerTrail" or "ClientTrail"
					Trail.Parent = Child
				end
			end
		end
	end
	return AddedTrail
end


function Aesthetics:ToggleSwordTrail(handle,Activation)
	for _,Child in pairs(handle:GetDescendants()) do

		if table.find(Aesthetics.TrailTypes,Child.ClassName)then

			coroutine.wrap(function() 

				if not Activation then
					task.wait(.1)	
				end

				if not (Activation and not themesHighGraphics()) then --If HighGraphics == false, trail can be disabled but not enabled
					Child.Enabled = Activation
				end
			end)()
		end
	end
end

local function lowerVal(value)

	local a = math.max(value - 70, 0)
	local b = value * .5

	return math.min(a, b)
end

function Aesthetics:CustomColorSequence(baseColor3)

	local darkColor3 = Color3.new(
		lowerVal(baseColor3.r), 
		lowerVal(baseColor3.g), 
		lowerVal(baseColor3.b)
	)

	return ColorSequence.new(baseColor3, darkColor3)
end

function Aesthetics:ApplyWallColors(Brick, randomColor)
	if not Brick:IsA("Part") then
		return
	end

	local Creator = Brick.creator.Value
	local BrickIndex = tonumber(Brick.Name)
	local Folder, Theme = Aesthetics:GetThemeObject(Creator, "Trowel")
	local Part = Folder:FindFirstChildWhichIsA("Part")

	local Gradient = Folder:FindFirstChildWhichIsA("UIGradient")
	local RowNum = math.ceil(BrickIndex / _G.BB.Settings.Trowel.BricksPerRow)
	local Alpha = (RowNum - 1) / (_G.BB.Settings.Trowel.BricksPerColumn - 1)

	Brick.Transparency = Part.Transparency
	Brick.Reflectance = Part.Reflectance
	Brick.Material = Part.Material

	local RandomColor = Theme == "Normal" and _G.BB.Settings.Themes.RandomWallColors
	local Color = RandomColor and randomColor or self:GetColorAtTime(Gradient.Color, 1 - Alpha)

	Brick.Color = Theme == "Team Color" and Creator.TeamColor.Color or Color
end

function Aesthetics:HandleProjectileVisuals(Creator, Part, Theme)
	Aesthetics:AddTrail(Creator, Part)

	if not themesHighGraphics() then
		for _,v in pairs(Part:GetChildren()) do
			if v:IsA("Fire") or v:IsA("Sparkles") or v:IsA("ParticleEmitter") or v:IsA("Smoke") then
				v:Destroy()
			end
		end
	end
	
	for _,v in pairs(Part:GetChildren()) do
		if v:IsA("Texture") and (v:FindFirstChild("UOffsetSpeed") or v:FindFirstChild("VOffsetSpeed")) then
			animateTexture(v)
		end
	end
end

function Aesthetics:AddTrail(Creator, Part)
	if not themesHighGraphics() then --themesOn
		return
	end

	local Theme = self:DetermineTheme(Creator)

	if table.find(_G.BB.Settings.Themes.TrailsOmitted,Theme) then
		return
	end

	local Children = Part:GetChildren()
	for _,Trail in pairs(Children) do

		if not (Trail and Trail.ClassName and table.find(self.TrailTypes, Trail.ClassName)) then 
			--warn("No trail for", Creator, "with theme", Theme) 
			continue 
		end

		Trail = Trail:Clone()

		if Theme == "Team Color" or Theme == "Normal" then
			Trail.Color = self:CustomColorSequence(Part.Color)
		end

		local Size = Part.Size.X/2

		if Trail:IsA("Trail") then -- could also be a fire
			local a0 = Instance.new("Attachment")
			a0.Name = "0"
			a0.Position = Vector3.new(-Size,0,0)
			a0.Parent = Part

			local a1 = Instance.new("Attachment")
			a1.Name = "1"
			a1.Position = -Vector3.new(-Size,0,0)
			a1.Parent = Part
			Trail.Attachment0 = a0
			Trail.Attachment1 = a1
		end

		Trail.Parent = Part
	end
end

function Aesthetics:PaintballColor(Hit, Color)
	local oldColor = Hit.Color

	local originalColor = Hit:FindFirstChild("OriginalColor")

	if originalColor then
		oldColor = originalColor.Value
	else
		local val = Instance.new("Color3Value")
		val.Name = "OriginalColor"
		val.Value = oldColor
		val.Parent = Hit
	end

	Hit.Color = Color


	local Mesh = Hit:FindFirstChildWhichIsA("FileMesh")
	local part = Hit:IsA("Part")
	local functionUponReset = nil

	local reset = _G.BB.Settings.PaintballGun.ColorResetTime > 0
	local timeUntilRemove = _G.BB.Settings.PaintballGun.ColorResetTime
	local timeUntilTween = timeUntilRemove - 3
	local tweenDuration = timeUntilRemove - timeUntilTween

	local plr = Players:GetPlayerFromCharacter(Hit.Parent)
	local hum = Hit.Parent:FindFirstChildWhichIsA("Humanoid")
	local hrp = Hit.Name == "HumanoidRootPart"

	-- Only a tween if _G.BB.Local.Themes is true.
	local tweenInfo = TweenInfo.new(
		tweenDuration, -- Time
		Enum.EasingStyle.Linear, -- EasingStyle
		Enum.EasingDirection.Out, -- EasingDirection
		0, -- RepeatCount (when less than zero the tween will loop indefinitely)
		false, -- Reverses (tween will reverse once reaching it's goal)
		0 -- DelayTime
	)

	if Hit:IsA("MeshPart") and not hum then
		local oldId = Hit.TextureID
		Hit.TextureID = ""

		functionUponReset = function()
			Hit.TextureID = oldId
		end

	elseif Mesh then
		local oldId = Mesh.TextureId
		Mesh.TextureId = ""

		functionUponReset = function()
			Mesh.TextureId = oldId
		end

	elseif hum and Hit.Name ~= "Head" then
		local guiArray = {}

		for _, gui in pairs (script.PaintballGUIs:GetChildren()) do

			local new = gui:Clone()
			new.Frame.BackgroundColor3 = Color

			local current = Hit:FindFirstChild(gui.Name)
			if current then
				current:Destroy()
			end

			new.Parent = Hit

			if reset then
				Debris:AddItem(new, timeUntilRemove)
			end

			table.insert(guiArray, new)
		end

		functionUponReset = function()
			if themesHighGraphics() then --themesOn
				for _, gui in pairs(guiArray) do

					local tween = TweenService:Create(gui.Frame, tweenInfo, {BackgroundTransparency = 1})
					tween:Play()
				end
			end
		end

	elseif Hit:IsA("UnionOperation") then
		Hit.UsePartColor = true
	end

	if reset then

		local stillReset = true
		local conn 

		conn = Hit.Changed:Connect(function(property)
			if property == "Color" then
				if Hit.OriginalColor.Value ~= Hit.Color then
					stillReset = false
					if functionUponReset then
						functionUponReset()
					end
					conn:Disconnect()
				end
			end
		end)

		task.delay(timeUntilTween, function()
			if conn then
				conn:Disconnect()
			end

			if stillReset then
				if themesHighGraphics() then --themesOn
					local tween = TweenService:Create(Hit, tweenInfo, {Color = oldColor})
					tween:Play()
				else
					Hit.Color = oldColor
				end

				if functionUponReset then
					functionUponReset()
				end
			end
		end)
	end
end

function Aesthetics:ExplodePaintball(Paintball)

	Paintball.Anchored = true
	Paintball.Transparency = 1
	Paintball.CanCollide = false

	for _,v in pairs(Paintball:GetChildren()) do
		if v:IsA("ParticleEmitter") then
			v.Enabled = false
		end
	end

	for i = 1, math.random(2, 3) do
		local DebrisPart = Instance.new("Part")

		Physics:SetPartCollisionGroup(DebrisPart, "Paintballs")

		DebrisPart.Name = "PaintballDebris"
		DebrisPart.Size = Vector3.new(1,0.4,1)
		DebrisPart.BrickColor = Paintball.BrickColor

		-- yuck
		local RandomDistance = Vector3.new(
			math.random(-10, 10) / 10, 
			math.random(0, 10) / 10, 
			math.random(-10, 10) / 10
		).Unit * (math.random(10, 20) / 10)

		DebrisPart.CFrame = CFrame.lookAt(Paintball.Position + RandomDistance, Paintball.Position)

		DebrisPart.Velocity = 15 * RandomDistance 
		DebrisPart.Parent = workspace
		Debris:AddItem(DebrisPart, math.random(3, 5))
	end

	Debris:AddItem(Paintball,1.5)
end

function Aesthetics:CreateCustomExplosion(Player, ExplosionPart)

	local HighGraphics = themesHighGraphics() --themesOn()

	local ParticleFolder, Theme = self:GetThemeObject(Player, "ExplosionParticles")
	local ExplosionFolder = ParticleFolder.Parent.Explosion

	local performantBase = ExplosionFolder:FindFirstChild("Base") or {
		Color = ExplosionPart.Color,
		Material = Enum.Material.SmoothPlastic,
		Transparency = .5,
	}

	local aestheticBase = ExplosionFolder:FindFirstChild("Theme") or {
		Color = ExplosionPart.Color,
		Material = Enum.Material.Neon,
		Transparency = .7,
	}

	local ExplosionBase = HighGraphics and aestheticBase or performantBase
	local baseTime = ExplosionFolder:FindFirstChild("BaseTime")
	local themeTime = ExplosionFolder:FindFirstChild("ThemeTime")

	local TIME = HighGraphics and (themeTime and themeTime.Value or .6) 
		or (baseTime and baseTime.Value or .3)

	--[[local Fire = ExplosionPart:FindFirstChildWhichIsA("Fire")
	if Fire then
		Debris:AddItem(Fire, 0)
	end]]
	for _,v in pairs(ExplosionPart:GetChildren()) do
		if v:IsA("Fire") then
			v.Enabled = false
			Debris:AddItem(v, 1) --?
		elseif v:IsA("ParticleEmitter") then
			v.Enabled = false
			Debris:AddItem(v, v.Lifetime.Max) --?
		end
	end

	local radius = ExplosionPart.Size.X / 2
	ExplosionPart.Name = Player.Name.."'s Client Explosion"
	ExplosionPart.Shape = Enum.PartType.Ball
	ExplosionPart.Anchored = true
	ExplosionPart.CanCollide = false
	ExplosionPart.CastShadow = false
	ExplosionPart.Color = Theme == "Team Color" and Player.TeamColor.Color or ExplosionBase.Color
	ExplosionPart.Material = ExplosionBase.Material
	ExplosionPart.Transparency = ExplosionBase.Transparency
	ExplosionPart.BottomSurface = Enum.SurfaceType.Smooth
	ExplosionPart.TopSurface = Enum.SurfaceType.Smooth
	ExplosionPart.LeftSurface = Enum.SurfaceType.Smooth
	ExplosionPart.RightSurface = Enum.SurfaceType.Smooth
	ExplosionPart.FrontSurface = Enum.SurfaceType.Smooth
	ExplosionPart.BackSurface = Enum.SurfaceType.Smooth

	if HighGraphics then

		-- Either use default Roblox explosion or
		-- use custom explosions.

		if _G.BB.Settings.Themes.UseRobloxExplosions then

			ExplosionPart.Transparency = 1

			local Explosion = Instance.new("Explosion")
			Explosion.Name = Player.Name.."'s Aesthetic Explosion"
			Explosion.BlastPressure = 0
			Explosion.BlastRadius = radius
			Explosion.DestroyJointRadiusPercent = 0
			Explosion.ExplosionType = Enum.ExplosionType.NoCraters
			Explosion.Position = ExplosionPart.Position
			Explosion.Parent = workspace

			Debris:AddItem(Explosion, 5)
		else

			-- Prepare aesthetic objects
			for _,Object in pairs(ParticleFolder:GetChildren()) do

				local Object = Object:Clone()

				if Object:IsA("ParticleEmitter") then

					Object.Speed = NumberRange.new((Object.Speed.Min/2) * radius, (Object.Speed.Max / 2) * radius)
					Object.Rate = (Object.Rate / 2) * radius

					if Theme == "Team Color" then
						Object.Color = self:CustomColorSequence(ExplosionPart.Color)
					end

				elseif Object:IsA("Smoke") then

					Object.Size = radius * 2.2

				elseif Object:IsA("Folder") then

					local partDecals = Object:GetChildren()

					for _, Decal in pairs (partDecals) do
						Decal.Parent = ExplosionPart
					end
				end

				Object.Parent = ExplosionPart
			end

			-- Begin tweening
			local function PlayTweens()
				for _,Object in pairs (ExplosionPart:GetChildren()) do

					if Object:IsA("Decal") then
						TweenService:Create(Object, TweenInfo.new(TIME, Enum.EasingStyle.Linear), {Transparency = 1}):Play()

					elseif Object:IsA("Smoke") then
						TweenService:Create(Object,TweenInfo.new(TIME, Enum.EasingStyle.Linear), {Opacity = 0}):Play()

					elseif Object:IsA("ParticleEmitter") then
						Object:Emit(Object.Rate)
					end
				end
			end

			task.spawn(PlayTweens)

			TweenService:Create(ExplosionPart, TweenInfo.new(TIME, Enum.EasingStyle.Linear), {Transparency = 1}):Play()

		end
	end

	local function CleanUp()
		ExplosionPart.Size = Vector3.new(.01,.01,.01)
		ExplosionPart.Transparency = 1

		for _,Child in pairs(ExplosionPart:GetChildren()) do

			if Child:IsA("ParticleEmitter") or Child:IsA("Smoke") or Child:IsA("Decal") then
				Child:Destroy()
			end
		end
	end

	task.delay(TIME, CleanUp)
	Debris:AddItem(ExplosionPart, 5)
end

local function doOutline(Part, color)

	local Outline = Instance.new("SelectionBox")
	Outline.SurfaceColor3 = color
	Outline.Transparency = 1
	Outline.SurfaceTransparency=0
	Outline.Parent = Part
	Outline.Adornee = Outline.Parent

	local Tween = TweenService:Create(Outline, TweenInfo.new(1), {SurfaceTransparency=1})
	Tween:Play()

	local function RemoveOutline()
		Tween.Completed:Wait()
		Outline:Destroy()
	end

	coroutine.wrap(RemoveOutline)()
end

function Aesthetics:CreateVisual(hitPart, player, highlightEntireCharacter)
	if not _G.BB.Local.VisualHitIndicators then
		return
	end

	if not _G.BB.Local.Themes then
		return
	end 

	if hitPart == nil or hitPart.Parent == nil then 
		return
	end

	local color = self:GetThemeObject(player,"HitColor").Value

	if highlightEntireCharacter then
		for _,Part in pairs(hitPart.Parent:GetChildren()) do
			if Part:IsA("Part") and Part.Name~="HumanoidRootPart" then
				doOutline(Part,color)
			end
		end
	else
		doOutline(hitPart,color)
	end
end

function Aesthetics:RegisterClientEvents()
	local localPlayer = game:GetService("Players").LocalPlayer
	local hitRemote = _G.BB.Remotes.Hit

	hitRemote.OnClientEvent:connect(function(plr, hit, expl)
		if plr ~= localPlayer then
			self:CreateVisual(hit,plr,expl)
		end
	end)
end

return Aesthetics]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX350A0C37B93049F4850BAAF443DDF6A1">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">PaintballGUIs</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="SurfaceGui" referent="RBX3F763EDB743D4DBAA949AB908D25650B">
								<Properties>
									<bool name="Active">true</bool>
									<Ref name="Adornee">null</Ref>
									<bool name="AlwaysOnTop">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<float name="Brightness">1</float>
									<Vector2 name="CanvasSize">
										<X>800</X>
										<Y>600</Y>
									</Vector2>
									<bool name="ClipsDescendants">true</bool>
									<bool name="Enabled">true</bool>
									<token name="Face">5</token>
									<float name="LightInfluence">1</float>
									<string name="Name">Front</string>
									<float name="PixelsPerStud">50</float>
									<bool name="ResetOnSpawn">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<token name="SizingMode">1</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<float name="ToolPunchThroughDistance">0</float>
									<token name="ZIndexBehavior">1</token>
									<float name="ZOffset">0</float>
								</Properties>
								<Item class="Frame" referent="RBX140F183B9AD14EF2AF02FA9B89B1E02E">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<bool name="Visible">true</bool>
										<int name="ZIndex">5</int>
									</Properties>
								</Item>
							</Item>
							<Item class="SurfaceGui" referent="RBX5848D276B73144568498D343FB6602CB">
								<Properties>
									<bool name="Active">true</bool>
									<Ref name="Adornee">null</Ref>
									<bool name="AlwaysOnTop">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<float name="Brightness">1</float>
									<Vector2 name="CanvasSize">
										<X>800</X>
										<Y>600</Y>
									</Vector2>
									<bool name="ClipsDescendants">true</bool>
									<bool name="Enabled">true</bool>
									<token name="Face">2</token>
									<float name="LightInfluence">1</float>
									<string name="Name">Back</string>
									<float name="PixelsPerStud">50</float>
									<bool name="ResetOnSpawn">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<token name="SizingMode">1</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<float name="ToolPunchThroughDistance">0</float>
									<token name="ZIndexBehavior">1</token>
									<float name="ZOffset">0</float>
								</Properties>
								<Item class="Frame" referent="RBXBCEE1A6FE25A42B68377EFC8742E5331">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<bool name="Visible">true</bool>
										<int name="ZIndex">5</int>
									</Properties>
								</Item>
							</Item>
							<Item class="SurfaceGui" referent="RBX189BA460FFCF43B3921206295521BCE4">
								<Properties>
									<bool name="Active">true</bool>
									<Ref name="Adornee">null</Ref>
									<bool name="AlwaysOnTop">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<float name="Brightness">1</float>
									<Vector2 name="CanvasSize">
										<X>800</X>
										<Y>600</Y>
									</Vector2>
									<bool name="ClipsDescendants">true</bool>
									<bool name="Enabled">true</bool>
									<token name="Face">4</token>
									<float name="LightInfluence">1</float>
									<string name="Name">Bottom</string>
									<float name="PixelsPerStud">50</float>
									<bool name="ResetOnSpawn">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<token name="SizingMode">1</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<float name="ToolPunchThroughDistance">0</float>
									<token name="ZIndexBehavior">1</token>
									<float name="ZOffset">0</float>
								</Properties>
								<Item class="Frame" referent="RBX09317DE051B3475E85DE65C42821C357">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<bool name="Visible">true</bool>
										<int name="ZIndex">5</int>
									</Properties>
								</Item>
							</Item>
							<Item class="SurfaceGui" referent="RBX10AC10DC7D8E42CEB6105F7AA1BBBB61">
								<Properties>
									<bool name="Active">true</bool>
									<Ref name="Adornee">null</Ref>
									<bool name="AlwaysOnTop">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<float name="Brightness">1</float>
									<Vector2 name="CanvasSize">
										<X>800</X>
										<Y>600</Y>
									</Vector2>
									<bool name="ClipsDescendants">true</bool>
									<bool name="Enabled">true</bool>
									<token name="Face">0</token>
									<float name="LightInfluence">1</float>
									<string name="Name">Right</string>
									<float name="PixelsPerStud">50</float>
									<bool name="ResetOnSpawn">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<token name="SizingMode">1</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<float name="ToolPunchThroughDistance">0</float>
									<token name="ZIndexBehavior">1</token>
									<float name="ZOffset">0</float>
								</Properties>
								<Item class="Frame" referent="RBX0D23D5E1B0FB44E1B0DEA2DD901C5CCE">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<bool name="Visible">true</bool>
										<int name="ZIndex">5</int>
									</Properties>
								</Item>
							</Item>
							<Item class="SurfaceGui" referent="RBX9B0788150E734C439BC131BCF37D079A">
								<Properties>
									<bool name="Active">true</bool>
									<Ref name="Adornee">null</Ref>
									<bool name="AlwaysOnTop">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<float name="Brightness">1</float>
									<Vector2 name="CanvasSize">
										<X>800</X>
										<Y>600</Y>
									</Vector2>
									<bool name="ClipsDescendants">true</bool>
									<bool name="Enabled">true</bool>
									<token name="Face">1</token>
									<float name="LightInfluence">1</float>
									<string name="Name">Top</string>
									<float name="PixelsPerStud">50</float>
									<bool name="ResetOnSpawn">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<token name="SizingMode">1</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<float name="ToolPunchThroughDistance">0</float>
									<token name="ZIndexBehavior">1</token>
									<float name="ZOffset">0</float>
								</Properties>
								<Item class="Frame" referent="RBX61B2E8F5DD6542E68A28F3047BA1CFDA">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<bool name="Visible">true</bool>
										<int name="ZIndex">5</int>
									</Properties>
								</Item>
							</Item>
							<Item class="SurfaceGui" referent="RBX495D851500974C57B6A9BF8121F67044">
								<Properties>
									<bool name="Active">true</bool>
									<Ref name="Adornee">null</Ref>
									<bool name="AlwaysOnTop">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<float name="Brightness">1</float>
									<Vector2 name="CanvasSize">
										<X>800</X>
										<Y>600</Y>
									</Vector2>
									<bool name="ClipsDescendants">true</bool>
									<bool name="Enabled">true</bool>
									<token name="Face">3</token>
									<float name="LightInfluence">1</float>
									<string name="Name">Left</string>
									<float name="PixelsPerStud">50</float>
									<bool name="ResetOnSpawn">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<token name="SizingMode">1</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<float name="ToolPunchThroughDistance">0</float>
									<token name="ZIndexBehavior">1</token>
									<float name="ZOffset">0</float>
								</Properties>
								<Item class="Frame" referent="RBX78A25E42A1574725B8AB6D1418E57A20">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Frame</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<bool name="Visible">true</bool>
										<int name="ZIndex">5</int>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX0998252F7D624B3CA72D39EDE3AA6DCF">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Kill</string>
							<string name="ScriptGuid">{2624D07E-0260-451E-A5D6-BD6E95E6E93B}</string>
							<ProtectedString name="Source"><![CDATA[local Kill = {}
local Debris = game:GetService("Debris")

local function findFiltered(name)
	return table.find(_G.BB.Settings.TeamsFiltered, name)
end

local callbacks = {}

local Tags = {
	Rocket = "rbxasset://Textures/Rocket.png";
	Bomb = "rbxasset://Textures/Bomb.png";
	Sword = "rbxasset://Textures/Sword128.png";
	PaintballGun = "rbxasset://Textures/PaintballIcon.png";
	Slingshot = "rbxasset://Textures/Slingshot.png";
	Superball = "rbxasset://Textures/Superball.png";
}

function Kill:CanDamage(player, hitHumanoid, SelfKill, DeadException)
	--print(2.7, hitHumanoid:GetFullName())
	if player:FindFirstChild("CanDamage") and player.CanDamage.Value == false then 
		return false
	end

	-- Must have an active character
	local character = player.Character
	if not character then
		return false;
	end

	-- Must have a humanoid
	local humanoid = character:FindFirstChildWhichIsA("Humanoid")
	if not humanoid then
		return false
	end

	-- Hit player must have a character/char can't be nil
	local hitCharacter = hitHumanoid.Parent
	if not hitCharacter then
		return false
	end

	local otherPlr = game.Players:GetPlayerFromCharacter(hitCharacter)

	-- Already dead or godded
	if (hitHumanoid.Health <= 0) and not DeadException then
		return false
	end

	-- Player has a forcefield.
	if hitCharacter:FindFirstChildWhichIsA("ForceField",true) then
		return false
	end

	---- Manipulated humanoid, could be godded
	if not _G.BB.Settings.AllowHumanoidChanges then
		if (((humanoid.MaxHealth ~= 100) or (humanoid.WalkSpeed~=16) or humanoid.JumpPower~=50)) 
			or character:FindFirstChildWhichIsA("ForceField",true) then
			return false
		end
	end 

	-- Died, projectile is roaming around though
	if (humanoid.Health <= 0) and not _G.BB.Settings.WeaponsDamageAfterDeath then
		--print("Can't damage after death")
		return false
	end

	-- NPC
	-- The only reason this causes no weird behaviour is because all
	-- conditions after that are reserved for players (teams, etc).
	-- i.e. an afterlife check after this condition would yield unintended results.
	if not otherPlr then
		return true
	end
	
	-- Callback functions available to add after module loads
	for _, func in ipairs(callbacks) do
		if not func(player, otherPlr) then
			return false
		end
	end

	-- Self kill
	if player == otherPlr then
		return SelfKill
	end

	local t1 = player.TeamColor
	local t2 = otherPlr.TeamColor
	local t1Name
	local t2Name

	-- Firing player could be a spectator and shouldn't deal damage
	if not player.Neutral and player.Team ~= nil  then
		t1Name = player.Team.Name
		if _G.BB.Settings.SpectatorTeamActive 
			and t1Name == _G.BB.Settings.SpectatorTeamName then
			return false
		end
	end

	-- Hit player could be a spectator and shouldn't take damage
	if not otherPlr.Neutral and otherPlr.Team ~= nil then
		t2Name = otherPlr.Team.Name
		if _G.BB.Settings.SpectatorTeamActive 
			and t2Name == _G.BB.Settings.SpectatorTeamName then
			return false
		end
	end

	-- For FFA scenarios
	if player.Neutral or otherPlr.Neutral then
		return true 
	end

	-- Team kill
	if t1 == t2 then
		-- Ensure they are not on a "neutral team"
		if _G.BB.Settings.IgnoreCertainTeams then
			return findFiltered(t1Name) or findFiltered(t2Name)
		end
		
		return _G.BB.Settings.TeamKill
	end
	
	return true
end

function Kill:TagHumanoid(player, humanoid, obj, projectileType)
	local currentTag = humanoid:FindFirstChild("creator");
	local tag = obj and obj:FindFirstChild("creator")
	local Lifetime = _G.BB.Settings.TagLifetime
	
	if currentTag and currentTag:IsA("ObjectValue") then
		pcall(game.Destroy, currentTag)
	end
	
	local NewTag = tag and tag:Clone() or Instance.new("ObjectValue")
	NewTag.Name = "creator"
	NewTag.Value = player
	NewTag:SetAttribute("WeaponImageId", Tags[projectileType])
	--NewTag:SetAttribute("WeaponType", projectileType)
	
	local weapon = player:WaitForChild("Backpack"):FindFirstChild(projectileType) or player.Character:FindFirstChild(projectileType)
			
	local newWeaponTag = NewTag:FindFirstChild("Weapon") or Instance.new("ObjectValue")
	newWeaponTag.Name = "Weapon"
	newWeaponTag.Value = weapon
	newWeaponTag.Parent = NewTag
	
	local newWeaponStringTag = NewTag:FindFirstChild("WeaponType") or Instance.new("StringValue")
	newWeaponStringTag.Name = "WeaponType"
	newWeaponStringTag.Value = projectileType
	newWeaponStringTag.Parent = NewTag
	
	--[[
	creator.Value = Player object
	creator.Weapon.Value = Tool object
	creator.WeaponType.Value = String of weapon type
	]]
	
	NewTag.Parent = humanoid
	
	--print(
	--	"\n PATH:", NewTag:GetFullName(), 
	--	"\n VALUE:", NewTag.Value, 
	--	"\n WEAPON OBJECT:", NewTag.Weapon.Value, 
	--	"\n WEAPON STRING:", NewTag.WeaponType.Value
	--)
	
	Debris:AddItem(NewTag, Lifetime)
end

function Kill:AddDamageRule(func)
	local index = table.find(callbacks, func)
	if index then 
		warn("Function rule already exists.")
		return 
	end
	table.insert(callbacks, func)
end

function Kill:RemoveDamageRule(func)
	local index = table.find(callbacks, func)
	if index == nil then 
		warn("No damage rule found for input function.")
		return 
	end
	table.remove(callbacks, index)
end


return Kill]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX0D9E74C645184B6096B20CB9C7B93A01">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Explosion</string>
							<string name="ScriptGuid">{E32F7CF9-FA2E-4794-819A-7B2F0807D95E}</string>
							<ProtectedString name="Source"><![CDATA[local Explosion = {}

local Players = game:GetService("Players")
local repStorage = game:GetService("ReplicatedStorage")
local Collections = game:GetService("CollectionService")

local Kill = require(_G.BB.Modules:WaitForChild("Kill"))
local Aesthetics = require(_G.BB.Modules:WaitForChild("Aesthetics"))
local PSPV = require(_G.BB.Modules.Security:WaitForChild("PSPV"))

local WeldTracker = require(script:WaitForChild("WeldTracker"))
local Force = require(script:WaitForChild("Force"))

local ExplosionCallback = require(_G.BB.Modules.Callbacks.ExplodeMaster)
local BreakJointsCallback = require(_G.BB.Modules.Callbacks.BreakJoints)

local hitRemote = _G.BB.Remotes:WaitForChild("Hit") -- Hit indication
local explodeRemote = _G.BB.Remotes:WaitForChild("Explosion")

local Settings = _G.BB.Settings

local Debris = game:GetService("Debris")

local Limbs = {
	"LeftFoot",
	"LeftLowerLeg",
	"LeftUpperLeg",

	"RightFoot",
	"RightLowerLeg",
	"RightUpperLeg",

	"LeftHand",
	"LeftLowerArm",
	"LeftUpperArm",

	"Left Arm",
	"Right Arm",
	"Left Leg"
}

local DeadlyLimbs = {
	"RightHand",
	"RightLowerArm",
	"RightUpperArm",

	"HumanoidRootPart",
	"UpperTorso",
	"LowerTorso",

	"Right Arm",
	"Torso",

	"Head"
}




local function verifyTableElement(Table,Element)
	if not table.find(Table,Element) then
		table.insert(Table,Element)
		return true
	else
		return false
	end
end


local function isDeadlyLimb(part)
	return table.find(DeadlyLimbs,part.Name) ~= nil
end

local function canFlingPart(Part)
	local Model = Part:FindFirstAncestorWhichIsA("Model") 
	return not (
		Part.Anchored 
			or Part:FindFirstAncestorWhichIsA("Tool") 
			or Part:FindFirstAncestorWhichIsA("Accessory") 
			or Part:FindFirstChild("PhysicsFolder")
			or (Model and Model:FindFirstChildWhichIsA("Humanoid"))
			
	)
end

local function ClientFling(Part, Humanoid, Position, Explosion)
	-- Do not fling self if setting is off.
	local Mass = Part:GetMass()
	local LocalPlayer = Players.LocalPlayer
	local HitPlayer = Humanoid and Players:GetPlayerFromCharacter(Humanoid.Parent)
	local Creator = Explosion.creator.Value
	local ProjectileType = Explosion.ProjectileType.Value
	local Damage = Settings[ProjectileType].Damage
	local SelfDamage = Settings[ProjectileType].SelfDamage
	local Radius = Settings[ProjectileType].Radius
	local ExplosionForce = Settings[ProjectileType].ExplosionForce
	local ForceFactorOnSelf = Settings.Explosions.ForceFactorOnSelf
	
	local IsBomb = Part.Name == LocalPlayer.Name.."'s Bomb"
	if (HitPlayer == Creator and Creator == LocalPlayer and Settings.Explosions.FlingYou) then

		Force:ExertDirectionally(Position, Part, Radius, ExplosionForce * ForceFactorOnSelf, Mass)

	elseif (IsBomb and Settings.Explosions.FlingBombs) then

		Force:ExertDirectionally(Position,Part,Radius,ExplosionForce,Mass)

	elseif not IsBomb and canFlingPart(Part) and Settings.Explosions.FlingParts then

		--If you fired the rocket/bomb, apply impulse to all debris.
		--You don't always netown it, but it shouldn't do anything in that case.
		for _, Weld in pairs(WeldTracker:GetWeldsByPart(Part)) do
			if BreakJointsCallback(Weld,Creator) then
				Weld:Destroy()
			end
		end

		Force:ExertLocally(Position, Part, Radius, ExplosionForce, Mass)
	end
end

-- Used in rocket and bomb client scripts
function Explosion:HandleHitDetection(Explosion, HitPart, RocketPosition, DirectHitCFrames)
	local player = Players.LocalPlayer
	local localHum = player.Character.Humanoid
	
	local ProjectileType = Explosion.ProjectileType.Value
	local Damage = Settings[ProjectileType].Damage
	local SelfDamage = Settings[ProjectileType].SelfDamage
	
	-- Grab parts
	local TempConnection = Explosion.Touched:Connect(function() end)
	local TouchingParts = Explosion:GetTouchingParts()
	TempConnection:Disconnect()
	
	if HitPart and not table.find(TouchingParts,HitPart) then
		table.insert(TouchingParts,HitPart)	
	end
	
	Explosion.Active.Value = false -- Stop sending updates
	
	-- Rocket sends new distance, bomb sends cframe
	local ExplData = Explosion.Position
	if ProjectileType == "Rocket" then
		ExplData = (Explosion.Position - Explosion.Origin.Value.Position).Magnitude
	end
	
	-- Determine what sounds to play, grab character positional data, + client dmg
	local HitCharacterCFrames = {}
	local Humanoids = {}
	local Killed = false
	local Blocked = false
	for i,Part in pairs(TouchingParts) do
		
		if ExplosionCallback(Part, Explosion.creator.Value) == false then
			continue
		end
		
		local Humanoid = Part.Parent:FindFirstChildWhichIsA("Humanoid")
		local position = RocketPosition and RocketPosition or Explosion.Position
		
		if Humanoid then
			if Kill:CanDamage(player,Humanoid,SelfDamage) then
				
				if not HitCharacterCFrames[Humanoid.Parent.Name] then
					HitCharacterCFrames[Humanoid.Parent.Name] = PSPV:CreateCharacterCFrameTable(Humanoid)
				end
				
				if not Settings.Explosions.LimbRemoval or isDeadlyLimb(Part) then
					if verifyTableElement(Humanoids, Humanoid) then
						
						-- Instantaneous damage for firer
						if Settings.InstantDamage then
							if ((Humanoid.Health-Damage)<=0) then
								if (Humanoid.Health == Humanoid.MaxHealth) then --Fix health not updating if target player is full health
									task.delay(3, function() if math.abs(Humanoid.Health - .1) < 1e6 then Humanoid.Health = Humanoid.MaxHealth end end)
								end
								Humanoid.Health = .1
							else
								Humanoid:TakeDamage(Damage)
							end
						end
						
						Killed = ((Humanoid.Health-Damage)<=0) and not player.Character:IsAncestorOf(Humanoid)
						
						Aesthetics:CreateVisual(Humanoid.Parent.PrimaryPart,player,true)
					end
				end
			else
				Blocked = not player.Character:IsAncestorOf(Humanoid)
			end
		end
		
		ClientFling(Part, Humanoid, position, Explosion)
	end
	
	if not Settings.Security.PSPV then
		HitCharacterCFrames = {}
	end
	
	-- Play sound
	if Killed then
		if _G.BB.Local.Hit~="None" then
			_G.BB.ClientObjects.Sounds.Hit[_G.BB.Local.Hit]:Play()
		end
	elseif Blocked then
		if _G.BB.Local.BlockedHit ~="None" then
			_G.BB.ClientObjects.Sounds.Blocked[_G.BB.Local.BlockedHit]:Play()
		end
	end
	
	local ID_array = {Explosion.ProjectileType.Value, Explosion.Count.Value}

	explodeRemote:FireServer(
		ID_array,
		ExplData,
		HitPart,
		TouchingParts,
		DirectHitCFrames,
		HitCharacterCFrames
	)
	
end

-- Used in client Extrapolation module
function Explosion:ExtrapolateExplosion(ExtrapolatedProjectile, PhysicsFolder)
	
	PhysicsFolder.Exploded.Value = true
	
	local Radius = _G.BB.Settings[PhysicsFolder.ProjectileType.Value].Radius
	ExtrapolatedProjectile.Size = Vector3.new(Radius*2,Radius*2,Radius*2)
	
	local ProjectileType = PhysicsFolder.ProjectileType.Value
	local Damage = Settings[ProjectileType].Damage
	local SelfDamage = Settings[ProjectileType].SelfDamage
	
	local SoundName
	
	if ProjectileType == "Bomb" then
		SoundName = _G.BB.Local.BombExplosion

		ExtrapolatedProjectile.Position = PhysicsFolder.LatestPosition.Value
		ExtrapolatedProjectile.Tick:Destroy()
	elseif ProjectileType == "Rocket" then
		SoundName = _G.BB.Local.RocketExplosion
		
		ExtrapolatedProjectile.CFrame = (
			PhysicsFolder.Origin.Value 
				+ (PhysicsFolder.Origin.Value.lookVector 
					* PhysicsFolder.LatestDistance.Value
				)
		)
		ExtrapolatedProjectile.Swoosh:Destroy()
	end

	-- Client explosion sound
	local Sounds = ExtrapolatedProjectile:WaitForChild("Boom")
	local Sound = Sounds:FindFirstChild(SoundName)
	Sound.Parent = ExtrapolatedProjectile
	Sound:Play()
	
	Aesthetics:CreateCustomExplosion(PhysicsFolder.creator.Value, ExtrapolatedProjectile)
	
	local connection = ExtrapolatedProjectile.Touched:Connect(function() end)
	local CollectedParts = ExtrapolatedProjectile:GetTouchingParts()
	connection:Disconnect()
	
	for _,Part in pairs (CollectedParts) do
		
		if ExplosionCallback(Part, PhysicsFolder.creator.Value) == false then
			continue
		end
		
		local CharacterModel = Part:FindFirstAncestorOfClass("Model")
		local Humanoid = CharacterModel and CharacterModel:FindFirstChildOfClass("Humanoid")

		ClientFling(Part,Humanoid,ExtrapolatedProjectile.Position,PhysicsFolder)
	end
	
	Debris:AddItem(ExtrapolatedProjectile,5)	
end

function Explosion:HandleHumanoid(PhysicsFolder, Humanoid, CharPartArray, ExplosionPosition)
	-- When LimbRemoval is on, only hits to the torso/hrp, head, and right
	-- arm deal certain damage.
	
	local ProjectileType = PhysicsFolder.ProjectileType.Value
	local Damage = Settings[ProjectileType].Damage
	local SelfDamage = Settings[ProjectileType].SelfDamage
	local Radius = Settings[ProjectileType].Radius
	local ExplosionForce = Settings[ProjectileType].ExplosionForce
	
	local Player = PhysicsFolder.creator.Value
	local FirerHumanoid = Player.Character and Player.Character:FindFirstChild("Humanoid")
	local HitPlayer = Players:GetPlayerFromCharacter(Humanoid.Parent)
	local Damaged = false

	for _, Part in pairs(CharPartArray) do
		if Kill:CanDamage(Player, Humanoid, SelfDamage) then
			
			if not Settings.Explosions.LimbRemoval or isDeadlyLimb(Part)then
				if not Damaged then
					Damaged = true
					Kill:TagHumanoid(Player, Humanoid, PhysicsFolder, ProjectileType)
					Humanoid:TakeDamage(Settings[ProjectileType].Damage)
					hitRemote:FireAllClients(Player,Humanoid.Parent.PrimaryPart, true)
				end
				
			elseif Settings.Explosions.LimbRemoval then
				-- Break limb off (Try to prevent wild fling issue)
				Part:BreakJoints()
				Part.Massless = true
				Part.Parent = workspace
			end
		end
		
		if  _G.BB.Settings.Explosions.FlingEnemies then
			if Kill:CanDamage(Player, Humanoid, false, true) then
				
				--print("Flinging hum:",Part,Humanoid.Parent)
				Force:ExertDirectionally(ExplosionPosition, Part, Radius, ExplosionForce, Part:GetMass())
			end
		end
	end
end

function Explosion:BlowUpPart(PhysicsFolder, Part, ExplosionPosition)
	local Humanoid = Part.Parent:FindFirstChildWhichIsA("Humanoid") or Part.Parent.Parent:FindFirstChildWhichIsA("Humanoid")
	local Character = Humanoid and Humanoid.Parent
	local Player = Players:GetPlayerFromCharacter(Part.Parent)
	local ProjectileType = PhysicsFolder.ProjectileType.Value
	local Creator = PhysicsFolder.creator.Value

	if Collections:HasTag(Part, _G.BB.Settings.Explosions.ExclusionTag) then
		return
	end
	
	if Part.Parent:IsA("Tool") then
		return
	elseif Part.Parent:IsA("Accessory") and Humanoid then
		if not Kill:CanDamage(Creator, Humanoid, false) then
			return
		end
	end
	
	if Part.Anchored then return end
	
	-- Teammates trowel's are protected, unless setting is off
	if Collections:HasTag(Part,"TrowelWallBrick") and Settings.Explosions.ProtectTeammateWalls then 
		local OwnerValue = Part.creator.Value
		if OwnerValue.Character then
			local ownerHumanoid = OwnerValue.Character:FindFirstChild("Humanoid")
			if ownerHumanoid and not Kill:CanDamage(PhysicsFolder.creator.Value,ownerHumanoid,true) then
				return
			end
		end
	end
	
	local firingPlayer = PhysicsFolder.creator.Value
	local PartJointsBroken = false

	-- Break joints assuming settings is on, and humanoid is either dead, 
	-- nil, or LR is on
	local destroyed = 0
	local welds = WeldTracker:GetWeldsByPart(Part)
	for _, Weld in pairs(welds) do
		if BreakJointsCallback(Weld, Creator) then
			Weld:Destroy()
			destroyed += 1
		end
	end
	
	-- Ensure mass is below threshold & fling
	local Mass = Part:GetMass()
	
	if Settings.Explosions.FlingParts and destroyed == #welds then
		--print("Flinging part:",Part,Part.Parent)
		Force:Exert(ExplosionPosition,Part,Settings[ProjectileType].Radius,Settings[ProjectileType].ExplosionForce ,Mass)
	end
		
	-- Destroy
	if Mass < Settings[ProjectileType].MaxMassToDestroy 
		and not Part:IsA("SpawnLocation")
		and not Humanoid
		and (Settings.Explosions.DestroyParts
			or (
				Collections:HasTag(Part,"TrowelWallBrick")
				and Settings.Explosions.DestroyTrowelWallsOverride
			)
		) then
		Part:Destroy()
	end
	
	if Settings.Explosions.DebrisTime > 0 then
		Debris:AddItem(Part, Settings.Explosions.DebrisTime)
	end
end

-- Server
function Explosion:RegisterEvents()
	--[[
		When the explosion is from a rocket, "ExplPosData" is 
		the distance from the origin.
		
		Otherwise if explosion is from a bomb, "ExplPosData" is 
		the client's last seen cframe.
	]]
	
	local Security = require(_G.BB.Modules.Security)
	
	explodeRemote.OnServerEvent:Connect(function(
		playerFired, 
		ID_array, 
		ExplPosData, 
		HitPart,
		Parts, 
		DirectHitCharacterData, 
		RadiusCharacterData
	)
		
		local PhysicsFolder = Security:GetPhysicsFolder(ID_array, playerFired, true)
		if not PhysicsFolder then
			return
		end
		
		local ProjectileType = PhysicsFolder:FindFirstChild("ProjectileType")
		local Creator = PhysicsFolder:FindFirstChild("creator")	
		
		local ExplosionPosition = ExplPosData
		local RocketCFrame
		
		if ProjectileType.Value == "Rocket" then
			local Origin = PhysicsFolder.Origin.Value
			local ExplosionCFrame = (Origin) and (Origin + Origin.lookVector * ExplPosData)
			
			RocketCFrame = CFrame.new(ExplosionCFrame.Position - 2*ExplosionCFrame.LookVector, ExplosionCFrame.Position)
			ExplosionPosition = ExplosionCFrame.Position
		end
		
		local approvedHumanoids, approvedParts = Security:ApproveExplode(
			PhysicsFolder, 
			ExplPosData, 
			Parts, 
			HitPart, 
			DirectHitCharacterData, 
			RadiusCharacterData, 
			RocketCFrame
		)
		
		if not approvedHumanoids or not approvedParts then
			return
		end
		
		-- Rocket sends distance as its final update. Bomb send position.
		local value = ProjectileType.Value == "Bomb" and "LatestPosition" or "LatestDistance"
		PhysicsFolder[value].Value = ExplPosData
		
		-- Tell clients that this projectile has exploded		
		PhysicsFolder.Active.Value = false 	
		
		-- Blow up only the approved parts
		for _, Part in pairs(approvedParts) do
			local function BlowUpPart()
				self:BlowUpPart(PhysicsFolder, Part, ExplosionPosition)
			end
			task.spawn(BlowUpPart)
		end
		
		for Humanoid, CharPartArray in pairs(approvedHumanoids) do
			local function BlowUpPlayer()
				self:HandleHumanoid(PhysicsFolder, Humanoid, CharPartArray, ExplosionPosition)
			end
			task.spawn(BlowUpPlayer)
		end
				
		-- Remove explosion
		task.delay(2, function() PhysicsFolder:Destroy() end)
		
		if Settings.Bomb.TeleportOnExplode 
			and not Settings.Bomb.SelfDamage 
			and ProjectileType.Value == "Bomb" then
			Creator.Value.Character:MoveTo(ExplosionPosition)
		end
	end)
end

return Explosion]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXFF44A5BD707E47B5A045BE2D174C5477">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Force</string>
								<string name="ScriptGuid">{129ACFF7-6D4A-4FAA-8EC9-BFA3FB7B7D7A}</string>
								<ProtectedString name="Source"><![CDATA[local Force = {}
local Collections = game:GetService("CollectionService")
local Debris = game:GetService("Debris")

local function getExplosionImpulseValues(ExplosionPosition, Part, BlastRadius, Pressure, Mass)
	--This technically encompasses limbs and accessories...
	--...But isn't there a cleaner way?
	local IsInCharacter = (
		(Part.Parent:FindFirstChildWhichIsA("Humanoid")
		) or
			(Part.Parent.Parent:FindFirstChildWhichIsA("Humanoid")
			)
	)

	local delta = Part.Position - ExplosionPosition
	local normal = (delta == Vector3.new(0,0,0))
		and Vector3.new(0,1,0)
		or  delta.unit

	local r = delta.magnitude
	local radius = Part.Size.magnitude / 2
	local surfaceArea = radius * radius
	local impulse = normal * Pressure * surfaceArea * (1.0 / 4560.0)

	local frac, mass
	if IsInCharacter then
		frac = 2-- - math.max(0, math.min(1, (r-2)/BlastRadius))
		mass = 0
		local parts = Part:GetConnectedParts(true)
		for _,p in pairs(parts) do
			mass += p.Mass
		end
	else
		frac = 1
		mass = Part.Mass
	end

	local currentVelocity = Part.Velocity
	local deltaVelocity = impulse / mass
	local accelNeeded = workspace.Gravity

	local rotImpulse = impulse * 0.5 * radius
	local currentRotVelocity = Part.RotVelocity
	local momentOfInertia = (2 * Part:GetMass() * radius * radius / 5) -- moment of inertia = 2/5*m*r^2 (assuming roughly spherical)
	local deltaRotVelocity = rotImpulse / momentOfInertia
	local torqueNeeded = 20 * momentOfInertia
	
	accelNeeded = accelNeeded * 10 * frac
	torqueNeeded = torqueNeeded * 10 * frac

	return deltaVelocity, accelNeeded, deltaRotVelocity, torqueNeeded
end

--https://devforum.roblox.com/t/explosion-visible-true-false/6170/31
function Force:Exert(ExplosionPosition, Part, BlastRadius, Pressure, Mass)
	
	if Part and workspace:IsAncestorOf(Part) and (Part:GetNetworkOwner() == nil) then

		local dV, accel, dRV, torque = getExplosionImpulseValues(
			ExplosionPosition, Part, BlastRadius, Pressure, Mass
		)
		
		local dt = 0.1
		
		local force = accel * Part.Mass
		local bodyV = Instance.new('BodyVelocity')
		bodyV.velocity = Part.Velocity + dV
		bodyV.maxForce = Vector3.new(force, force, force)
		Collections:AddTag(bodyV,"BodyMoverServer")
		bodyV.Parent = Part
		Debris:AddItem(bodyV, dt)

		local rot = Instance.new('BodyAngularVelocity')
		rot.Name = "BodyAngularVelocityServer"
		rot.angularvelocity = Part.RotVelocity + dRV
		rot.maxTorque = Vector3.new(torque, torque, torque)
		Collections:AddTag(rot,"BodyMoverServer")
		rot.Parent = Part
		Debris:AddItem(rot, dt)
	end
end

-- No rotational force
function Force:ExertDirectionally(ExplosionPosition, Part, BlastRadius, Pressure, Mass)
	if Part then
		local dV, accel, dRV, torque = getExplosionImpulseValues(
			ExplosionPosition, Part, BlastRadius, Pressure, Mass
		)
		local dt = 0.1
		
		--Boost for player and bomb
		dV *= 1.5
		
		local IsInCharacter = (
			(Part.Parent:FindFirstChildWhichIsA("Humanoid")
			) or
				(Part.Parent.Parent:FindFirstChildWhichIsA("Humanoid")
				)
		)
		
		if IsInCharacter then
			local mul = 1.5
			dV = Vector3.new(dV.X * mul, dV.Y, dV.Z * mul)
		end
		
		
		--[[
		local maxSpeed = math.sqrt(3*accel^2) * dt
		print(dV.Magnitude, maxSpeed)
		if dV.Magnitude > maxSpeed then
			dV = dV.Unit * maxSpeed
		end
		]]
		
		local dx, dy, dz = dV.X, dV.Y, dV.Z
		
		--[[
		local maxSpeed = accel * dt
		
		if dx > maxSpeed then dx = maxSpeed end
		if dx < -maxSpeed then dx = -maxSpeed end
		if dy > maxSpeed then dy = maxSpeed end
		if dy < -maxSpeed then dy = -maxSpeed end
		if dz > maxSpeed then dz = maxSpeed end
		if dz < -maxSpeed then dz = -maxSpeed end
		]]


		local maxSpeed = accel * dt
		local maxSpeedXZ = maxSpeed * 1.5

		if dx > maxSpeedXZ then dx = maxSpeedXZ end
		if dx < -maxSpeedXZ then dx = -maxSpeedXZ end
		if dy > maxSpeed then dy = maxSpeed end
		if dy < -maxSpeed then dy = -maxSpeed end
		if dz > maxSpeedXZ then dz = maxSpeedXZ end
		if dz < -maxSpeedXZ then dz = -maxSpeedXZ end
		
		dV = Vector3.new(dx, dy, dz)
		
		Part.Velocity = Part.Velocity + dV

	end
end

function Force:ExertLocally(ExplosionPosition,Part, BlastRadius, Pressure,Mass)
	if Part then
		local dV, accel, dRV, torque = getExplosionImpulseValues(
			ExplosionPosition, Part, BlastRadius, Pressure, Mass
		)
		
		local force = accel * Part.Mass
		--Get rid of bodymover later
		local bodyV = Instance.new('BodyVelocity', Part)
		bodyV.velocity = Part.Velocity + dV
		bodyV.maxForce = Vector3.new(force, force, force)
		game.Debris:AddItem(bodyV, 0.1)
		
		--Get rid of bodymover later
		local rot = Instance.new('BodyAngularVelocity', Part)
		rot.angularvelocity = Part.RotVelocity + dRV
		rot.maxTorque = Vector3.new(torque, torque, torque)
		game.Debris:AddItem(rot, 0.1)
	end
end


return Force
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX0A03E855EBF04247A4AC135457896E57">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">WeldTracker</string>
								<string name="ScriptGuid">{4F216199-79AD-4054-80F3-1E484381B987}</string>
								<ProtectedString name="Source"><![CDATA[-- Thegameboy

local WeldTracker = {}
WeldTracker.__index = WeldTracker

function WeldTracker.new(root)
	return setmetatable({
		root = root;
		didStart = false;
		activeWelds = {};
		weldsByPart = {};
	}, WeldTracker)
end

function WeldTracker:Start()
	if self.didStart then return end
	self.didStart = true
	
	local activeWelds = self.activeWelds
	local weldsByPart = self.weldsByPart
	local weldToCons = {}
	
	local function onDescendantAdded(i)
		local class = i.ClassName
		if class ~= "WeldConstraint" and class ~= "Weld" and class ~= "Snap" then return end
		activeWelds[i] = true
		
		local part0 = i.Part0
		local function onPart0Changed()
			if weldsByPart[part0] then
				weldsByPart[part0][i] = nil
			end
			
			local newPart = i.Part0
			if newPart then
				weldsByPart[newPart] = weldsByPart[newPart] or {}
				weldsByPart[newPart][i] = true
			end
			part0 = newPart
		end
		
		local part1 = i.Part1
		local function onPart1Changed()
			if weldsByPart[part1] then
				weldsByPart[part1][i] = nil
			end
			
			local newPart = i.Part1
			if newPart then
				weldsByPart[newPart] = weldsByPart[newPart] or {}
				weldsByPart[newPart][i] = true
			end
			part1 = newPart
		end
		
		local cons = {}
		weldToCons[i] = cons
		
		table.insert(cons, i:GetPropertyChangedSignal("Part0"):Connect(onPart0Changed))
		table.insert(cons, i:GetPropertyChangedSignal("Part1"):Connect(onPart1Changed))
		onPart0Changed()
		onPart1Changed()
	end
	
	self.root.DescendantAdded:Connect(onDescendantAdded)
	for _, i in pairs(self.root:GetDescendants()) do
		onDescendantAdded(i)
	end
	
	self.root.DescendantRemoving:Connect(function(i)
		local class = i.ClassName
		if class ~= "WeldConstraint" and class ~= "Weld" and class ~= "Snap" then return end
		activeWelds[i] = nil
		
		local part0 = i.Part0
		if part0 then
			local welds = weldsByPart[part0]
			welds[i] = nil
		end
		
		local part1 = i.Part1
		if part1 then
			local welds = weldsByPart[part1]
			welds[i] = nil
		end
		
		for _, con in pairs(weldToCons[i]) do
			con:Disconnect()
		end
		weldToCons[i] = nil
	end)
end

function WeldTracker:GetWelds()
	return self.activeWelds
end

function WeldTracker:GetWeldsByPart(part)
	local entry = self.weldsByPart[part]
	if entry == nil then
		return {}
	end
	
	local array = {}
	for weld in pairs(entry) do
		table.insert(array, weld)
	end
	
	return array
end

local singleton = WeldTracker.new(workspace)
singleton:Start()
return singleton]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX1854973A6A194F8A84EC678A18233887">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Security</string>
							<string name="ScriptGuid">{4CB765BA-EFF7-4137-88EA-4DC2253E876F}</string>
							<ProtectedString name="Source"><![CDATA[local Security = {}

local Debris = game:GetService("Debris")
local Players = game:GetService("Players")

local INTERP_CONSTANT = .138

local function findFolder(Player,Type)
	return workspace:FindFirstChild("Projectiles"):FindFirstChild(Type):FindFirstChild(Player.Name)
end

local countsKeys = {
	Superball = "Superballs";
	Rocket = "Rockets";
	PaintballGun = "Paintballs";
	Bomb = "Bombs";
	Trowel = "Walls";
	Slingshot = "Pellets";
}

function Security:GetPhysicsFolder(ID_array, PlayerFired, DontWarn)
	local ActiveFolder = findFolder(PlayerFired, "Active")

	local PhysicsFolder = ActiveFolder:FindFirstChild(ID_array[1]..ID_array[2])
		
	local success, err = pcall(function()
		assert(PhysicsFolder, "PhysicsFolder does not exist.")

		assert(#PhysicsFolder:GetChildren() > 0, "PhysicsFolder has no children.")

		assert(PhysicsFolder.creator.Value == PlayerFired, "Creator value does not match firing player, value:", PhysicsFolder.creator.Value)
		assert(PhysicsFolder.Active.Value == true, "PhysicsFolder is inactive!")
	end)

	if success then
		return PhysicsFolder
	elseif err then
		if not DontWarn then
			warn(
				"\n Error verifying PhysicsFolder...",
				"\n ID:",PlayerFired.Name.." "..ID_array[1]..ID_array[2],
				--"\n Count:", _G.BB.ProjectileCounts[PlayerFired.Name][countsKeys[ID_array[1]]],
				"\n Error:",err
			)
			--for _, obj in pairs(ActiveFolder:GetChildren()) do
			--	print(obj.Name)
			--end
		end
		return false
	end
end

function Security:ApproveActivation(Player, name, server)
	
	local Character = Player.Character
	
	local tool = Character and Character:FindFirstChildWhichIsA("Tool")

	if tool == nil then
		--print(Player, name, "NO TOOL FOUND", Character)
		return false
	end
	
	if tool and name then
		if tool.Name ~= name then
			--print(Player, name, "WRONG TOOL FOUND")
			return false
		end
	end

	if tool.Enabled == false or not tool:FindFirstChild("Activation") then
		--print(Player, name, "TOOL NOT ENABLED")
		return false
	end
	
	local deathCheck = true
	
	if server then
		deathCheck = _G.BB.Settings.Security.Master
	end

	if Character.Humanoid.Health > 0 or not deathCheck then
		if (tool.Name == "Sword" or tool.Name == "Trowel") 
			or not Character:FindFirstChildWhichIsA("ForceField") then
			return tool
		else
			--print(Player, name, "FORCEFIELDED")
		end
	else
		--print(Player, name, "PLAYER DEAD")
	end
end

-- approves initial positions, velocities, etc
function Security:ApproveInit(PhysicsFolder, handle)
	
	local projectileType = PhysicsFolder.ProjectileType.Value
	local creator = PhysicsFolder.creator.Value
	
	local character = creator.Character
	local head = character.Head
	
	local Settings = _G.BB.Settings	
	
	if not self:ApproveActivation(creator, projectileType, true) then
		--print(PhysicsFolder.Name, "denied activation approval.")
		return false
	end
	
	if Settings.Security.Master then
		if projectileType == "Slingshot" then

			local initPos = PhysicsFolder.LatestPosition.Value
			--local initVel = PhysicsFolder.LatestVelocity.Value
			--local initTime = PhysicsFolder.LatestTime.Value	

			local MovementVector = head.Velocity * INTERP_CONSTANT
			local projPos = head.Position + MovementVector

			local vector2 = Vector2.new(initPos.X, initPos.Z)
			local vector1 = Vector2.new(projPos.X, projPos.Z)

			local Magnitude2D = (vector2 - vector1).Magnitude
			local Magnitude3D = (initPos - projPos).Magnitude

			local Cushion2D = Settings.Slingshot.SpawnDistance + 5
			local Cushion3D = Settings.Slingshot.SpawnDistance * 3

			if Magnitude2D > Cushion2D or Magnitude3D > Cushion3D then

				if Settings.Security.Initial.Warn then
					warn(
						"\n High initial displacement: "..PhysicsFolder.UniqueID.Value,
						"\n 2D Distance: "..Magnitude2D,
						"\n 3D Distance:"..Magnitude3D -- might as well print this too
					)
				end

				if Settings.Security.Initial.Deactivate then
					Debris:AddItem(PhysicsFolder,0)
					PhysicsFolder:Destroy()
					return false
				end
			end
			
		else
			
			local initPos = projectileType == "Rocket"
				and PhysicsFolder.Origin.Value.Position 
				or PhysicsFolder.LatestPosition.Value
			
			--local initVel = PhysicsFolder.LatestVelocity.Value
			--local initTime = PhysicsFolder.LatestTime.Value	

			-- Check velocity
			--[[
			local Vector = initVel.Magnitude--/initCF.LookVector
			local Average = (Vector.X + Vector.Y + Vector.Z)/3
			local Difference =math.abs(Average-Settings.Superball.Speed) 
			if Difference>Settings.Security.Initial.SuperballVelocity then
				if Settings.Security.Initial.Warn then
					warn(
						"\n Bad initial velocity: "..PhysicsFolder.UniqueID.Value,
						"\n Vector speed:",Vector,
						"\n Average: "..Average,
						"\n Difference: "..Difference
					)
				end
				if Settings.Security.Initial.Deactivate then
					PhysicsFolder:Destroy()
					self.BufferObjectValue.Value = nil
					self:CreatePhysicsFolder();
					return
				end
			end
			]]

			local vector2 = Vector2.new(initPos.X, initPos.Z)
			local vector1 = Vector2.new(head.Position.X, head.Position.Z)
			
			local Magnitude2D = (vector2 - vector1).Magnitude
			local Magnitude3D = (initPos - head.Position).Magnitude
			
			local limit2d = Settings.Security.Initial[projectileType.."2D"]
			local limit3d = Settings.Security.Initial[projectileType.."3D"]

			if Magnitude2D > limit2d or Magnitude3D > limit3d then
				if Settings.Security.Initial.Warn then
					warn(
						"\n High initial displacement: "..PhysicsFolder.UniqueID.Value,
						"\n 2D Distance: "..Magnitude2D,
						"\n 3D Distance:"..Magnitude3D -- might as well print this too
					)
				end
				if Settings.Security.Initial.Deactivate then
					PhysicsFolder:Destroy()
					return false
				end
			end
		end
	end
	
	return true
end

function Security:ApproveUpdate(PhysicsFolder, InfoArray, UpdateSet, DeltaTime)
	local Parabola = require(script.Parabola)
	
	local RemoteSender = PhysicsFolder.creator.Value
	local ProjectileType = PhysicsFolder.ProjectileType.Value
	
	if _G.BB.Settings.Security.Master then
		
		if ProjectileType == "Superball" or ProjectileType == "Slingshot" or ProjectileType == "PaintballGun" then
			local LatestPosition = PhysicsFolder.LatestPosition
			local LatestVelocity = PhysicsFolder.LatestVelocity
			local LatestTime = PhysicsFolder.LatestTime

			local p0 = LatestPosition.Value
			local v0 = LatestVelocity.Value
			local p1 = InfoArray[2]
			local PositionMagnitude = (p1 - p0).Magnitude

			local fallout = _G.BB.Settings.Security.Fallout[ProjectileType]
			local g = Vector3.new(0, -workspace.Gravity, 0)

			if not PhysicsFolder.Hacking.Value 
				and not Parabola:Check(p0, v0, g, p1, fallout) then

				if UpdateSet.Warn then
					warn("Projectile Path Verification failed: Position update rejected.")
				end

				if UpdateSet.Deactivate then
					PhysicsFolder.Hacking.Value = true
					PhysicsFolder.Active.Value = false
							--[[local sbpre = game.ReplicatedStorage.SBVis:Clone()
							sbpre.Parent = game.Workspace
							sbpre.BrickColor = BrickColor.new("Bright red")
							sbpre.Position = p1

							local sbpost = game.ReplicatedStorage.SBVis:Clone()
							sbpost.Parent = game.Workspace
							sbpost.BrickColor = BrickColor.new("Bright green")
							sbpost.Position = p0]]

					return false
				end
			end
			
		elseif ProjectileType == "Rocket" then
			local LatestDistance = PhysicsFolder.LatestDistance
			--local LatestVelocity = PhysicsFolder.LatestVelocity

			local OldDistance = LatestDistance.Value
			--local OldVelocity = LatestVelocity.Value
			local NewDistance = InfoArray[2]

			local Difference = NewDistance - OldDistance
			
			if (Difference > UpdateSet.Rocket or Difference < 0) then
				if UpdateSet.Warn then
					warn(
						"\n Bad distance change: "..PhysicsFolder.Name,
						"\n Difference: "..Difference
						--"\n DT: "..DeltaTime
					)
				end
				if UpdateSet.Deactivate then
					PhysicsFolder.Exploded.Value = true
					PhysicsFolder.Active.Value = false
					return false
				end
			elseif Difference == 0 then
				if UpdateSet.Warn then
					warn(
						"\n Zero distance change: "..PhysicsFolder.Name,
						"\n Difference: "..Difference
						--"\n DT: "..DeltaTime
					)
				end
			end
			
		elseif ProjectileType == "Bomb" then
			local Position1 = PhysicsFolder.LatestPosition.Value
			local Position2 = InfoArray[2]
			local PositionMagnitude = (Position2-Position1).Magnitude

			if PositionMagnitude > UpdateSet.Bomb then
				if UpdateSet.Warn then
					warn(
						"\n High displacement:",PhysicsFolder.Name,
						"\n Magnitude:",PositionMagnitude,
						"\n Velocity:",PhysicsFolder.LatestVelocity.Value
						--"\n DT:",DeltaTime
					)
				end
				if UpdateSet.Deactivate then
					PhysicsFolder.Active.Value = false
					return false
				end
			end

			local Velocity1 = PhysicsFolder.LatestVelocity.Value
			local Velocity2 = InfoArray[3]
			local VelocityMagnitude = (Velocity2-Velocity1).Magnitude
				if VelocityMagnitude>UpdateSet.BombVelocity then
					if UpdateSet.Warn then
						warn(
							"\n High acceleration: "..PhysicsFolder.Name,
							"\n Magnitude: "..VelocityMagnitude,
							"\n New velocity:",Velocity2,
							"\n Old velocity:",Velocity1
							--"\n DT:",DeltaTime
						)
					end
					if UpdateSet.Deactivate then
						PhysicsFolder.Active.Value = false
						return false
					end
				end


			local Time =  InfoArray[4]
			local CurrentTime = PhysicsFolder.LatestTime.Value
			-- DeltaTime = Time since last update
			if not(Time > (CurrentTime + .05) and (DeltaTime + CurrentTime - Time < .5)) then
				if UpdateSet.Warn then
					warn(
						"\n Bad incoming time: "..PhysicsFolder.Name,
						"\n Time: "..Time,
						"\n CurrentTime:",CurrentTime,
						"\n DT:",DeltaTime
					)
				end
				if UpdateSet.Deactivate then
					PhysicsFolder.Active.Value = false
					return false
				end
			end
		
		end
		
	end
	
	return true
end

function Security:ApproveExplode(PhysicsFolder, ExplPosData, Parts, HitPart, DirectHitCharacterData, RadiusCharacterData, RocketCFrame)
	local Settings = _G.BB.Settings	
	
	local Kill = require(_G.BB.Modules.Kill)
	local PSPV = self.PSPV
	local ExplosionCallback = require(_G.BB.Modules.Callbacks.ExplodeMaster)

	local ProjectileType = PhysicsFolder.ProjectileType.Value
	local playerFired = PhysicsFolder.creator.Value
	
	local directCharData = DirectHitCharacterData
	local Radius = Settings[ProjectileType].Radius
	local Multiplier = Settings.Security.Hit.RadiusMultiplier -- Current default 5, 5*4=20 for rocket

	local ExplosionPosition = ExplPosData

	local ID = playerFired.Name.."_"..PhysicsFolder.Name
	
	local SecurityPart = self.SecurityPart

	if Settings.Security.Master then
		-- Verify rocket hit a part
		
		if ProjectileType == "Rocket" then
			if HitPart then
				local Humanoid = HitPart.Parent:FindFirstChildWhichIsA("Humanoid")
				if (Humanoid
					and Players:GetPlayerFromCharacter(Humanoid.Parent) 
					and Kill:CanDamage(playerFired,Humanoid,false)
					and Humanoid.RigType == Enum.HumanoidRigType.R6  
					and Humanoid.Health>0)  then
					local HitPlayer = Players:GetPlayerFromCharacter(Humanoid.Parent)

					local TrueHit = PSPV:Verify(directCharData,{RocketCFrame},Vector3.new(1, 1, 4),Enum.PartType.Block,HitPlayer.Name,PhysicsFolder)
					if not TrueHit then
						if Settings.Security.Hit.Warn then
							warn("PSPV failed for direct rocket hit:",ID,"Hit player:",HitPlayer)
						end
						if Settings.Security.Hit.Deactivate then
							PhysicsFolder.Active.Value = false		
							task.delay(2, function() PhysicsFolder:Destroy() end)
							return false
						end
					end
				elseif not Humanoid then
					SecurityPart.Shape = Enum.PartType.Block
					SecurityPart.Size = Vector3.new(1, 1, 4)
					SecurityPart.CFrame = RocketCFrame
					local CollectedParts = SecurityPart:GetTouchingParts()
					SecurityPart.Shape = Enum.PartType.Block
					if not table.find(CollectedParts,HitPart) then
						if Settings.Security.Hit.Warn then
							warn("Rocket's HitPart not touching rocket for",ID,"Hit:", HitPart:GetFullName())
						end
					end
				end
			else
				if Settings.Security.Hit.Warn then
					warn("Rocket's HitPart is nil for",ID)
				end
			end

			-- Ensure rocket did not explode too far away
			local OldDistance = PhysicsFolder.LatestDistance.Value
			local Difference = ExplPosData-OldDistance
			if Difference>Settings.Security.Hit.RocketExplode then
				if Settings.Security.Hit.Warn then
					warn(
						"\n High explosion displacement: "..ID,
						"\n New distance: "..ExplPosData,
						"\n Old distance: "..OldDistance,
						"\n Difference: "..Difference
					)
				end
				if Settings.Security.Hit.Disable then
					PhysicsFolder.Active.Value = false		
					task.delay(2, function() PhysicsFolder:Destroy() end)
					return false
				end
			end
		elseif ProjectileType == "Bomb" then
			if Settings.Security.Master then
				local LastTime = PhysicsFolder.LatestTime.Value
				-- Ensure bomb did not explode too quickly
				if LastTime<Settings.Security.Hit.BombTime then
					if Settings.Security.Hit.Warn then
						warn(
							"\n Quick explosion: "..ID,
							"\n LastTime: "..LastTime
						)
					end
					if Settings.Security.Hit.Disable then
						PhysicsFolder.Active.Value = false	
						task.delay(2, function() PhysicsFolder:Destroy() end)
						return false
					end
				end
			end
		end
	end
	
	-- Grab parts in same vicinity
	local CollectedParts = {}
	if Settings.Security.Master then
		SecurityPart.Size = Vector3.new(Radius*2,Radius*2,Radius*2)
		SecurityPart.Position = ExplosionPosition
		CollectedParts = SecurityPart:GetTouchingParts()
	end

	local Humanoids = {}
	local ApprovedParts = {}

	-- Check distance from explosion, make exception for large parts
	for _, Part in pairs(Parts) do
		-- Verify part
		if not Part or not workspace:IsAncestorOf(Part) or Part.Anchored then
			continue
		end

		if ExplosionCallback(Part, PhysicsFolder.creator.Value) == false then
			continue
		end

		-- Create a dictionary with humanoids
		-- Humanoids[Humanoid] = {CharPart,CharPart2}
		local Humanoid = Part.Parent:FindFirstChildWhichIsA("Humanoid")
		if Humanoid then
			if not Humanoids[Humanoid] then
				Humanoids[Humanoid] = {Part}
			else
				table.insert(Humanoids[Humanoid],Part)
			end
			continue
		end


		--[[
		Makes an exception for large, moving parts that were not collected
		by the Server explosion.
		
		** This stinks and is probably unnecessary
		]]
		if Settings.Security.Master and not table.find(CollectedParts, Part) then
			local DistanceBetweenCenters = (ExplosionPosition - Part.Position).Magnitude
			local AverageDistanceFromCenter = (Part.Size.X / 2 + Part.Size.Y / 2 + Part.Size.Z / 2) / 3

			-- Constraint is really only necessary for large, moving parts but whatever
			if DistanceBetweenCenters > Radius * Multiplier and AverageDistanceFromCenter + Radius < Radius * Multiplier then
				if Part.Name ~= "Handle" then
					if Settings.Security.Hit.Warn then
						local FullName = Part:GetFullName()

						warn("--------------------",
							"\n Part is far from explosion: "..ID,
							"\n Distance: "..DistanceBetweenCenters,
							"\n Part: "..FullName,
							"\n Part pos: ",Part.Position,
							"\n Expl pos: ",ExplosionPosition,
							"\n Part average from center: "..AverageDistanceFromCenter
						)
					end
					if Settings.Security.Hit.Disable then
						-- Part is not blown up and any possible humanoid is not damaged
						continue	
					end
				end
			end
		end
		table.insert(ApprovedParts,Part)
	end

	--[[
	This is our security check for hit characters. It uses
	a system called Past Server Position Verification (coined
	by GFink). 
	]]
	local ApprovedHumanoids = {}
	for Humanoid,CharPartArray in pairs(Humanoids) do
		local HitPlayer = Players:GetPlayerFromCharacter(Humanoid.Parent)
		if HitPlayer
			and Kill:CanDamage(playerFired, Humanoid, false)
			and Humanoid.RigType == Enum.HumanoidRigType.R6 
			and Settings.Security.Master 
			and Humanoid.Health > 0 then

			local TrueHit = PSPV:Verify(
				{RadiusCharacterData[HitPlayer.Name]},
				{CFrame.new(ExplosionPosition)},
				Vector3.new(Radius*2, Radius*2, Radius*2),
				Enum.PartType.Ball,
				HitPlayer.Name,
				PhysicsFolder
			)

			-- Approve
			if TrueHit then
				ApprovedHumanoids[Humanoid] = CharPartArray
			else
				warn("PSPV failed: Past character position not touching EXPLOSION.","\n Hit position:",ExplosionPosition)
			end
		else
			ApprovedHumanoids[Humanoid] = CharPartArray
		end
	end
	
	return ApprovedHumanoids, ApprovedParts
end

function Security:ApproveHit(PhysicsFolder, HitPlayer, HitPart, p1, v1, t1, CharacterData, ClientPhysicsFPS)
	local PSPV = self.PSPV
	local Parabola = self.Parabola

	local ka, kb, kc, kd, ke, kf, Lm, Mm -- Ewwww
	local HitPosition, HitVelocity, HitTime, SameParabola
	local HitPositionCandidates = {}
	
	local creator = PhysicsFolder.creator.Value
	local ProjectileType = PhysicsFolder.ProjectileType.Value

	local LatestPosition = PhysicsFolder:FindFirstChild("LatestPosition")
	local LatestVelocity = PhysicsFolder:FindFirstChild("LatestVelocity")
	local LatestTime = PhysicsFolder:FindFirstChild("LatestTime")

	local p0 = LatestPosition.Value
	local v0 = LatestVelocity.Value
	local t0 = LatestTime.Value
	
	if _G.BB.Settings.Security.Master then
		local Hacking = PhysicsFolder:FindFirstChild("Hacking")

		local Accel = Vector3.new(0, 0, 0)

		local VectorForce = PhysicsFolder:FindFirstChild("VectorForce")
		local Mass = PhysicsFolder:FindFirstChild("Mass")
		if VectorForce and Mass then
			Accel = VectorForce.Value / Mass.Value 
		end

		Accel += Vector3.new(0, -workspace.Gravity, 0)

		HitPosition, HitVelocity, HitTime, SameParabola, ka, kb, kc, kd, ke, kf, Lm, Mm = Parabola:FindTouchPoint(Accel,   p0, v0, t0,   p1, v1, t1)
		HitPositionCandidates = {CFrame.new(HitPosition)}

		if SameParabola then
			HitPosition, HitVelocity, HitTime = p1,v1,t1
			if not Parabola:Check(p0, v0, Accel, p1, _G.BB.Settings.Security.Fallout[ProjectileType]) then

				if _G.BB.Settings.Security.Hit.Warn then
					warn("Projectile Touch Verification failed: Same-parabola touch position REJECTED.")

					if HitPlayer then
						warn("Failed when hitting a player:", HitPlayer.Name, HitPart.Name)
					end
				end

				if _G.BB.Settings.Security.Hit.Deactivate then
					if Hacking then
						Hacking.Value = true
					end
					PhysicsFolder.Active.Value = false
					return false
				end
			end
			
			-- Post-touch position is confirmed, now we need to find candidates for the touch pos.
			-- Physics get throttled at FPS < 15.
			ClientPhysicsFPS = math.max(ClientPhysicsFPS, 15)
			HitPositionCandidates = {}
			for i = 0, 4 do
				local HitTimeCandidate = t1 - (i/4) * (1 / ClientPhysicsFPS)
				local HitPosCandidate,_ = Parabola:Eval(p1, v1, Vector3.new(0, -workspace.Gravity, 0), t1, HitTimeCandidate)
				table.insert(HitPositionCandidates, CFrame.new(HitPosCandidate))
			end
		end

		local DELTA_T = t1-HitTime

		if (t1-t0 > 0) then 
			if (not Hacking or Hacking.Value == false)
				and not SameParabola 
				and (Parabola:Check(p0, v0, Accel, HitPosition, _G.BB.Settings.Security.Fallout[ProjectileType]) == false) then

				if _G.BB.Settings.Security.Hit.Warn then
					warn("Projectile Touch Verification for".." failed: Normal touch position REJECTED.")

					if HitPlayer then
						warn("Failed when hitting a player:",HitPlayer.Name, HitPart.Name)
					end
				end
				if _G.BB.Settings.Security.Hit.Deactivate then
					if Hacking then
						Hacking.Value = true
					end
					PhysicsFolder.Active.Value = false
					return false
				end
			elseif not SameParabola then
				PhysicsFolder.LatestPosition.Value = p1
				PhysicsFolder.LatestVelocity.Value = v1
				PhysicsFolder.LatestTime.Value = t1
			end
		end
		
		-- No current PSPV security offered for NPCs.
		if HitPlayer then 
			local Size = ProjectileType == "Superball" and Vector3.new(2,2,2) or Vector3.new(1,1,1)
			local TrueHit = PSPV:Verify(
				CharacterData, 
				HitPositionCandidates, 
				Size, 
				Enum.PartType.Ball, 
				HitPlayer.Name, 
				PhysicsFolder, 
				SameParabola)

			if not TrueHit then
				if _G.BB.Settings.Security.Hit.Warn then
					warn("PSPV failed: Past character position not touching projectile hit position.","SameParabola:",SameParabola)
				end
				if _G.BB.Settings.Security.Hit.Deactivate then
					PhysicsFolder.Active.Value = false
					return false
				end
			end
		end
	end
	
	return true
end

function Security:ApproveFuturePositions(Player,LocalCFrames)
	if not _G.BB.Settings.Security.Master then
		return true
	end 
	if not _G.BB.Settings.Security.FuturePositionApproval then
		return true
	end
	local AlottedTime = _G.BB.Settings.Security.AllowedTime
	local Distance = _G.BB.Settings.Security.AcceptableDistance
	-- approve character position (occurs post-hit)
	local Character  = Player.Character
	if not Character then
		return false
	end
	local start = tick()
	local c
	local approved = {}
	local bestMags = {0,0,0}
	-- player has 1 second to get to that position
	c = game:GetService("RunService").Heartbeat:Connect(function()
		if tick()-start>.2 and #approved~=3 then
			warn(Player.Name," never reached future positions.",#approved)
			-- Do something here
			c:Disconnect()
		end
		for i,v in pairs(LocalCFrames) do
			if approved[i] then
				continue
			end
			local Mag = (v[2].Head.Position-Character.PrimaryPart.Position).Magnitude
			if Mag<bestMags[i] then
				bestMags[i]  = Mag
			end
			if Mag<Distance then
				approved[i] = true
			end
		end
		if #approved == 3 then
			--print("Approved future positions for",Player.Name)
			c:Disconnect()
		end
	end)
end

function Security:ApproveHandlePositions(Player,LocalCFrames)
	if not _G.BB.Settings.Security.Master then
		return true
	end 
	for _,frametable in pairs(LocalCFrames) do
		local char = frametable[2]
		local cf = char.Sword
		if cf then
			local mag = (cf.Position - char.Head.Position).Magnitude
			if mag > 3.8 then
				warn("High handle-root distance for:",Player)
				return false
			end
		end
	end
	return true
end

function Security:Init(SecurityPart, SecurityDummy, TimeValue)
	self.SecurityPart = SecurityPart
	
	self.Parabola = require(script:WaitForChild("Parabola"))
	self.PSPV = require(script:WaitForChild("PSPV"))
	
	self.PSPV:Init(SecurityPart, SecurityDummy, TimeValue)
end

return Security
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXE1FBB6DFF92E4F4285838A93DB30CD08">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Parabola</string>
								<string name="ScriptGuid">{4A895A48-1CF6-4EAB-81B0-860171BC330B}</string>
								<ProtectedString name="Source"><![CDATA[-- tyzone
-- Used by Hit and CustomPhysicsReplicator


local ParabolaModule = {}

local function CubeRoot(x) -- Get the cube root while preserving the negative or positive operand
	local Multiplier = x > 0 and 1 or -1
	return Multiplier * (x * Multiplier)^(1/3)
end

local function CubicRoots(A, B, C, D) -- Parameters are coefficients of a cubic polynomial ax^3 + bx^2 + cx + d = 0
	-- Use the cubic formula here to solve for x (in our case, t) - https://math.vanderbilt.edu/schectex/courses/cubic/cubic.gif
	local O = -B/(3*A)
	local P = (3*A*C - B^2) / (3*A^2)
	local Q = (2*B^3 - 9*A*B*C + 27*A*A*D) / (27*A^3)
	
	local Delta = -4*P^3 - 27*Q^2
	
	local z0, z1, z2
	if Delta < 0 then
		local k0, k1, k2
		k0 = -Q/2
		k1 = (Q^2)/4
		k2 = (P^3)/27
		
		
		--k1 + k2 is always positive here
		local sqrtsum = math.sqrt(k1 + k2)
		
		z0 = CubeRoot(k0 + sqrtsum) + CubeRoot(k0 - sqrtsum)
		--local z0 = (math.abs(k0) + math.sqrt(k1 + k2))^0.3333 + (math.abs(k0) - math.sqrt(k1 + k2))^0.3333
		--if k0 < 0 then z0 = -z0 end
	else
		local M = 2*math.sqrt(-P/3)
		local Phi = math.acos(3*Q/(M*P))
		z0 = M*math.cos(Phi/3)
		z1 = M*math.cos((Phi + 2*math.pi)/3)
		z2 = M*math.cos((Phi + 4*math.pi)/3)
	end
	return z0 + O, z1 and z1 + O, z2 and z2 + O
	-- z1 and z2 only exist if Delta is 0 or greater, so we do 'z1 and z1 + O' to return nil before trying to add nil and a number
end

local h = 1/240

local function ClosestTime(p0, v0, a, p1)
	local dp = p0 - p1
	
	local vOff = v0 + .5 * h * a
	
	a *= 0.5
	
	--We only use those for verification right now
	local QA, QB, QC, QD, QE
	QA = a.Y^2 --yes
	QB = 2*a.Y*vOff.Y --yes
	QC = vOff:Dot(vOff) + 2*a.Y*dp.Y
	QD = 2*vOff:Dot(dp)
	QE = dp:Dot(dp)
	
	local A,B,C,D
	A = 4*QA
	B = 3*QB
	C = 2*QC
	D = QD
	
	local function quartic(t)
		return QA*t^4 + QB*t^3 + QC*t^2 + QD*t + QE
	end
	
	local roots = {CubicRoots(A,B,C,D)}
	table.sort(roots, 
		function(t1, t2)
			return quartic(t1) < quartic(t2)
		end
	)
	return roots[1]
end

local function getOffset(a, t)
	
	return .5 * h * a * t
end

function ParabolaModule:ClosestVector(...)
	local t = ClosestTime(...)
	local p0, v0, a = ...
	
	return 
		p0 + (v0 * t) + (0.5 * a * t^2) + getOffset(a,t), -- Position at time t
		v0 + (a * t), -- Velocity at time t
		t -- Time t (probably will not be used)
end

function ParabolaModule:Eval(...)
	local p0, v0, a, t0, t1 = ...
	local dt = t1-t0
	return 
		p0 + (v0 * dt) + (0.5 * a * dt^2) + getOffset(a,dt), -- Position at time t
		v0 + (a * dt)
end

function ParabolaModule:Check(...)
	local ClosestPosition = self:ClosestVector(...)
	local _, _, _, p1, AllowedFallout = ...
	local Dist = (ClosestPosition - p1).Magnitude
	local safe = Dist <= AllowedFallout
	if not safe then
		--print(Dist,(Dist <= AllowedFallout and "<" or ">"),tostring(AllowedFallout))
		--print(ClosestPosition)
		--print(p1)
	end
	return safe
end

--[[ Tyzone
Uses "average" of two parabolas to find the true touch position of the projectile.
Why not just use Projectile.Position at the moment of touch? Physics is computed at
4x the speed of touch events firing. Means that the position could be up to 4 frames off,
which is intolerable for our security system.
]]
function ParabolaModule:FindTouchPoint(a,   p0, v0, t0,   p1, v1, t1)
	--[[
	The coefficients get too large if we use arbitrary values for time.
	This can cause floating point errors.
	We're only interested in time differences, so we set t0=0 for this calculation.
	We revert this change at the very end of the function.
	]]
	
	--local ERROR_CONSTANT = 0.0020387359836901
	
	--TODO: the "a" in the function params only accounts for the bodyforce.
	--The "a" in our formula should account for gravity + bodyforce.

	local dt = t1 - t0
	local off = getOffset(a, dt)
	
	
	local ka = 0.5 * a
	local kb = v0
	local kc = p0
	
	local kd = ka
	local ke = v1 - a * dt
	local kf = p1 - v1 * dt + 0.5 * a * dt^2
	kf = kf - off
	
	--[[
	local ka = 0.5 * a
	local kb = v0
	local kc = p0

	local kd = ka
	local ke = v1 - a * dt
	local kf = p1 - v1 * dt + 0.5*a*dt^2 - off*dt
	]]

	local L = ke - kb
	local M = kf - kc

	local SameParabola = (L.Magnitude < 10e-1 and M.Magnitude < 0.1)
	--print("SameParabola =",SameParabola,"(",L.Magnitude,",",M.Magnitude,",",v0.Magnitude,")")

	local tTouch = (M:Dot(L)) / (L:Dot(L))

	if (L*tTouch + M).Magnitude > (-L*tTouch + M).Magnitude then
		tTouch = -tTouch
	end

	local idt0 = tTouch
	local pTouch0 = p0 + (v0 * idt0) + (ka * idt0^2) + getOffset(a, idt0)
	--[[
	local idt1Candidates = {
		tTouch - dt,
		(tTouch - dt) * 3/4,
		(tTouch - dt) * 2/4,
		(tTouch - dt) * 1/4,
	}
	local bestPTouch = nil
	local bestDistance = math.huge
	for _,w in pairs(idt1Candidates) do
		local pCandidate = p1 + (v1 * w) + (kd * w^2) + getOffset(a, w)
		local ClosestPosition = self:ClosestVector(p0, v0, a, pCandidate)
		local Dist = (ClosestPosition - p).Magnitude
		
	end]]
	local idt1 = tTouch - dt
	local pTouch1 = p1 + (v1 * idt1) + (kd * idt1^2) + getOffset(a, idt1)
	local vTouch = v1 + a * idt1
	
	--print(off * idt1)

	--[[
	print("COEFFICIENTS")
	print(ka.magnitude, kb.magnitude, kc.magnitude)
	print(kd.magnitude, ke.magnitude, kf.magnitude)
	
	print("Position:",CFrameIWant.Position)
	print("Position 2:",p3)

	local s0 = game.ReplicatedStorage.SBVis:Clone()
	s0.Parent = game.Workspace
	s0.CFrame = CFrame.new(pTouch0)
	s0.BrickColor = BrickColor.new("Bright red")

	local s1 = game.ReplicatedStorage.SBVis:Clone()
	s1.Parent = game.Workspace
	s1.CFrame = CFrame.new(pTouch1)
	s1.BrickColor = BrickColor.new("Bright blue")
	]]
	
	if ((p0-p1).magnitude < 10e-3) and ((v0-v1).magnitude < 10e-3) then
		pTouch1 = p1
		vTouch = v1
		tTouch = (t0 + t1) / 2
		SameParabola = true
	end

	return pTouch1, vTouch, tTouch + t0, SameParabola, ka, kb, kc, kd, ke, kf, L.Magnitude, M.Magnitude
	-- everything past the fourth arg is for debugging purposes only
end

return ParabolaModule]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX0DA4F9C604914B89AB7D3A0B6178B5BB">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">PSPV</string>
								<string name="ScriptGuid">{F7A71AB6-0FEF-4BF4-B376-08BE9504176B}</string>
								<ProtectedString name="Source"><![CDATA[-- Past Server Position Verification
local PSPV = {}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local MaxDistances = {
	["Head"] = 1.6,
	["Right Arm"] = 2,
	["Left Arm"]= 2,
	["Left Leg"]= 2.3,
	["Right Leg"]= 2.3,
	["Torso"] = .1,
	["HumanoidRootPart"] = .1
}

local DefaultHRP = Vector3.new(2,2,1)

local function findTimeFromRoot(ClientRootPosition,HitPlayerName,ClientSeenTime)
	local ReturningTable
	local BestMagnitude = 100
	local BestTimeDifference = 1
	
	--print("Evaluating with client time stamp:",ClientSeenTime)
	
	for  _,RecordedCharData in pairs(_G.BB.MasterTimeTable[HitPlayerName]) do
		
		local RecordedRootPosition = RecordedCharData[2]["HumanoidRootPart"].Position
		local RecordedTime = RecordedCharData[1]
		
		local TimeDifference = math.abs(ClientSeenTime - RecordedCharData[1])
		local Magnitude = (ClientRootPosition - RecordedRootPosition).Magnitude
		
		if ((Magnitude > 0.1 and Magnitude < BestMagnitude) or Magnitude <= 0.1) and TimeDifference < BestTimeDifference then
			--print("Mag:",BestMagnitude,"TD:",BestTimeDifference)
			BestMagnitude = Magnitude
			BestTimeDifference = TimeDifference
			ReturningTable = RecordedCharData
		end
		
	end
	--[[ Debug
	local ReportMag = math.round(BestMagnitude*100)/100
	local ReportTD = math.round(BestTimeDifference*100000000)/100000000
	local Frames = math.floor((BestTimeDifference/(1/60)) + 0.5)
	local Steps = Frames*4
	print("Selected time stamp: ",ReturningTable[1],"Mag:",ReportMag,"TD:",ReportTD,"Frames:",Frames,"Steps:",Steps)
	]]
	return ReturningTable[1], ReturningTable[2] -- Time + Character data table
end

function PSPV:Verify(CharacterDataFrames, ProjectileCFrames, ProjectileSize, ProjectileShape, HitPlayerName, PhysicsFolder, SameParabola)
	if not _G.BB.Settings.Security.PSPV then
		return true
	end
	local info = PhysicsFolder and PhysicsFolder.UniqueID.Value or "Sword"

	--print(" >> PSPV","\n 1, Beginning PSPV for",info)
	
	--[[ Details
		CharacterDataFrames = {
			{Time, CFrameTable}, -- Post touch
			{Time, CFrameTable}, -- pre frame (if nec.)
			{Time, CFrameTable}, -- pre touch (if nec.)
		}
		Time = game.ReplicatedStorage.SERVER_TIME.Value
		Updated by server every heartbeat with time()
		CFrameTable = {
			Torso = CFrame
			Right Arm = CFrame
			etc
		}
	]]
	
	local ServerCFrames = {}
	
	-- Verify time
	for i,CharacterData in pairs(CharacterDataFrames) do
		
		-- Prevent long lag shadow hits
		local Now = time()
		local Lag = Now-CharacterData[1]
		if Lag>1 then -- Sorry BLOODTUSSK
			warn("\n\t Sent client time too old:","Client time:",CharacterData[1],"Now:",Now,"Lag:", math.round(Lag*100)/100)
			if PhysicsFolder then
				warn(
					"\tID:",PhysicsFolder.UniqueID.Value
				)
				PhysicsFolder.Active.Value = false
			end
			--return false
		end
		
		local SentRootPosition = CharacterData[2]["HumanoidRootPart"].Position
		local MatchingServerTime, ServerCFramesAtFrame = findTimeFromRoot(
			SentRootPosition,
			HitPlayerName,
			CharacterData[1] -- Time
		)
		
		-- For reference when verifying limb positions
		ServerCFrames[i] = ServerCFramesAtFrame

		-- Comparing server time when character was 
		-- at client seen position to client's seen time. 
		local TimeDifference = CharacterData[1] - MatchingServerTime

		if (TimeDifference>.33) then
			warn("\n\tPSPV failed time verification with dT:",TimeDifference,"\nServer time:",MatchingServerTime)
			if PhysicsFolder then
				warn(
					"\tID:",PhysicsFolder.UniqueID.Value
				)
				PhysicsFolder.Active.Value = false
			end
			return false
		end
	end
	
	--[[ Debug
	print("3, time difference of "..TimeDifference.." passed")
	
	local F = Instance.new("Folder")
	local Now = math.round(time()*100)/100
	F.Name = PhysicsFolder and PhysicsFolder.UniqueID.Value or "SwordHit"..Now
	F.Parent = workspace
	SecurityPart.Color = SameParabola and Color3.new(1, 0.941176, 0.278431) or Color3.new(0.615686, 0, 1)
	print("4, SameParabola = ",SameParabola)
	SecurityPart.Touched:Connect(function() end)
	SecurityPart.Parent = F
	
	
	 Position dummy projectile + character
	SecurityPart.Transparency = 0
	
	table.insert(CharacterCFrames,ServerCFrames)
	local Colors = {Color3.fromRGB(0, 170, 0),Color3.fromRGB(147, 147, 147),Color3.fromRGB(255, 255, 255)}
	local First
	]]
	
	local TrueHit = false
	local SecurityPart = self.SecurityPart
	local SecurityDummy = self.SecurityDummy
	SecurityPart.Size = ProjectileSize + Vector3.new(.35,.35,.35)
	SecurityPart.Shape = ProjectileShape
	
	-- Loop through character candidates (may contain candidates for
	-- multiple players, i.e., from a bomb explosion).
	for i,CharacterData in pairs(CharacterDataFrames) do
		local CharacterCFrames = CharacterData[2]
		
		--[[ Debug
		SecurityDummy.Parent = F

		if i == 1 then
			First = SecurityDummy
		end
		]]
		
		local Player = game.Players:FindFirstChild(HitPlayerName)
		
		-- Position limbs
		for PartName,PartCF in pairs(CharacterCFrames) do
			local Part = SecurityDummy:FindFirstChild(PartName)
			
			--[[ Inactive check
			-- Supposed to verify limb positions/distances
			if ServerFrames[i][PartName] then
				local ServerPart = ServerFrames[i][PartName]
				print(PartName,(PartCF.Position-ServerPart.Position).Magnitude)
			end
			
			local HRP = CharacterCFrames.HumanoidRootPart
			local Magnitude = (HRP.Position-PartCF.Position).Magnitude
			if MaxDistances[PartName] and (Magnitude>MaxDistances[PartName]) and Part then
				warn(PartName,"far from Root Part, will not be used in PSPV check,")
				continue
				--return false
			end
			if string.find(PartName,"Leg") then
				if (PartCF.Position.Y>(HRP.Position.Y-1.5)) then
					warn("Not counting",PartName)
					continue
					--return false
				end
			end
			]]
			if Part then
				Part.Size = Player.Character[PartName].Size -- Use server size
				Part.CFrame = PartCF -- Use firing client's seen position
				--Part.Transparency = 0
				--Part.Color = Colors[i]
			end
		end
		--local name = 1
		
		-- Position projectile candidates
		for _,CF in pairs(ProjectileCFrames) do
			-- Position
			SecurityPart.CFrame = CF

			--[[ Debug
			local visualPart
			if SameParabola then
				visualPart = SecurityPart:Clone()
				visualPart.Name = "Candidate projectile "..name
				visualPart.Parent = F
				visualPart.CFrame = CF
				visualPart.Color = Color3.new(0.172549, 0.0823529, 0.0196078) 
				name = name + 1
			end
			]]
			
			-- See if projectile is touching a limb
			local CollectedParts = SecurityPart:GetTouchingParts()
			for _,CharacterPart in pairs(SecurityDummy:GetChildren()) do
				if table.find(CollectedParts,CharacterPart) then
					--if visualPart and not TrueHit then
					--	visualPart.Color = Color3.new(0.615686, 1, 0) -- Touches sent frame
					--end
					TrueHit = true
				end
			end
		end
	end
	
	--[[ Debug
	if First then
		for _,DebugPart in pairs(First:GetChildren()) do
			DebugPart.Color = TrueHit and Color3.new(0.00784314, 0.490196, 0) or Color3.new(1, 0, 0.0156863)
			DebugPart.Transparency = 0
		end
	end
	
	if TrueHit then
		F:Destroy()
	end
	]]
	return TrueHit
end

function PSPV:CreateCharacterCFrameTable(Source)
	if not _G.BB.Settings.Security.PSPV then
		return
	end
	local Character = Source:IsA("Player") and Source.Character or Source:IsA("Humanoid") and Source.Parent
	if not Character then
		warn("Not generating character cframes (could not find char), any hit on this player will not count. ")
		return	
	end
	-- Grab character positional data at current seen server time
	local CharacterCFrame = {}
	for _,CharPart in pairs(Character:GetChildren()) do
		if CharPart:IsA("Part") then
			CharacterCFrame[CharPart.Name] = CharPart.CFrame
		elseif CharPart:IsA("Tool") and CharPart.Name == "Sword" then
			if CharPart:FindFirstChild("Handle") then
				CharacterCFrame[CharPart.Name] = CharPart.Handle.CFrame
			end
		end
	end
	local Time = _G.BB.ServerTime.Value
	return {Time,CharacterCFrame}
end

function PSPV:CreateCharFrameTables(Player)
	if not _G.BB.Settings.Security.PSPV then
		return
	end
	--assert(Player:IsA("Player"),"Arg1 must be a player obj.")
	--assert(TimeTable,"No time scope!")
	local PostFrameData = self:CreateCharacterCFrameTable(Player)
	local PreFrameData1 = _G.BB.SlaveTimeTable[Player.Name] and _G.BB.SlaveTimeTable[Player.Name][1]
	local PreFrameData2 = _G.BB.SlaveTimeTable[Player.Name] and _G.BB.SlaveTimeTable[Player.Name][2]
	--[[
		_G.BB.SlaveTimeTable[PlayerName] = {
			FrameData = {Time,CFrameTable} -- older
			FrameData = {Time,CFrameTable}
		}
	]]
		
	return {PostFrameData,PreFrameData1,PreFrameData2}
end

function PSPV:Init(SecurityPart, SecurityDummy, ServerTimeValue)
	
	if not _G.BB.Settings.Security.PSPV then
		RunService.Heartbeat:Connect(function()
			_G.BB.ServerTime.Value = time()
		end)
		return
	end
	
	self.SecurityDummy = SecurityDummy
	self.SecurityPart = SecurityPart
	
	SecurityPart.Parent = workspace
	SecurityDummy.Parent = workspace
	
	local function RecordPlayerPositions()
		local Time = time()
		_G.BB.ServerTime.Value = Time
		
		for _,Player in pairs (Players:GetPlayers()) do
			if Player.Character then
				
				local CharacterData = self:CreateCharacterCFrameTable(Player)
				
				table.insert(_G.BB.MasterTimeTable[Player.Name],CharacterData)
				
				if #_G.BB.MasterTimeTable[Player.Name] > 360 then
					table.remove(_G.BB.MasterTimeTable[Player.Name],1)
				end
			end
		end
	end
	
	RunService.Heartbeat:Connect(RecordPlayerPositions)
end

function PSPV:InitClient()
	
	if not _G.BB.Settings.Security.PSPV then
		return
	end
	
	local function addPlayer(Player)
		_G.BB.SlaveTimeTable[Player.Name] = {}
	end
	
	for _, Player in pairs(Players:GetPlayers()) do
		addPlayer(Player)
	end
	
	Players.PlayerAdded:Connect(addPlayer)
	
	local function RecordPlayerPositions()
		for _,Player in pairs (Players:GetPlayers()) do
			if Player.Character then
				local CharacterData = self:CreateCharacterCFrameTable(Player)
				
				table.insert(_G.BB.SlaveTimeTable[Player.Name], CharacterData)
				
				if #_G.BB.SlaveTimeTable[Player.Name] > 2 then
					table.remove(_G.BB.SlaveTimeTable[Player.Name],1)
				end
			end
		end
	end
	
	RunService.Heartbeat:Connect(RecordPlayerPositions)
	
end

return PSPV
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXCB302E18C30A4799B6C691FDCFCB5EBF">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">SafeWait</string>
								<string name="ScriptGuid">{D4505337-DFF3-4B6E-8BF1-E231B66B1A94}</string>
								<ProtectedString name="Source"><![CDATA[local module = {}

module.wait = function(t)
	local maxSafeWait = _G.BB.Settings.MaxSafeWait

	if maxSafeWait == 0 then
		return task.wait(t)
	end
	
	local totalWait = 0

	local timeRemaining = t
	while timeRemaining > 0 do
		local dt = task.wait()
		totalWait += dt
		if dt < maxSafeWait then
			timeRemaining -= dt
		end
	end
	
	return totalWait
end

return module]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX139EDC2B4FDB43C68A78D49B731B336E">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Hit</string>
							<string name="ScriptGuid">{030F41C6-9943-456E-9C59-EFB8067ED27B}</string>
							<ProtectedString name="Source"><![CDATA[-- GloriedRage, GFink, tyzone
-- Used in Superball, Paintball Gun, and Slingshot client modules.

local HitModule = {}

local Collections = game:GetService("CollectionService")
local Physics = game:GetService("PhysicsService")
local Players = game:GetService("Players")
local Debris = game:GetService("Debris")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

local Kill = require(_G.BB.Modules:WaitForChild("Kill"))
local Aesthetics = require(_G.BB.Modules:WaitForChild("Aesthetics"))
local PSPV = require(_G.BB.Modules.Security:WaitForChild("PSPV"))
local HitRemote = _G.BB.Remotes:WaitForChild("Hit")
local Settings = _G.BB.Settings

local PaintballColorCallback = require(_G.BB.Modules.Callbacks.PaintballColor)
local PBG_Classes = {"Accoutrement", "Tool", "Accessory"} -- if hit.Parent:IsA... then color it

local FPS = 0

if RunService:IsClient() then
	RunService.Stepped:Connect(
		function(_, dt)
			FPS = 1 / dt
		end
	)
end

function IsAcceptableHit(player, hit)
	return hit.Parent:FindFirstChildWhichIsA("Humanoid") or 
		not (
		Collections:HasTag(hit,"Projectile") 
			or (hit.CanCollide == false) 
			or hit.Name == "Handle"
	)
end

local function PaintballDamageMultiplier(Projectile, HitPart)
	
	local properPart = Settings.PaintballGun.MultiplierPartNames[HitPart.Name]
		
	if Projectile.ProjectileType.Value == "PaintballGun" and properPart then
		
		Projectile.Damage.Value *= 1 + 2 / 3
		
		return Projectile.Damage.Value
	end
	return false
end

--[[
	This function handles the hit detection for both the Superball and Slingshot.
	Incorporates hit detection, damage and indicators all on the client to maximize
	experience. 
]]

function HitModule:HandleHitDetection(projectile)
	--print("__________")
	--print("Initializing:", PhysicsFolder.UniqueID.Value)
	local Delete = require(_G.BB.ClientObjects:WaitForChild("Delete"))
	
	if projectile:FindFirstChildWhichIsA("TouchTransmitter") then 
		return 
	end
	
	projectile.Ready.Value = true
	
	local player = Players.LocalPlayer
	local ProjectileType = projectile.ProjectileType.Value
	local setting = Settings[ProjectileType]
	local damage = projectile.Damage.Value
	
	local CanHalfDamage = setting.RicochetDamage
	local hitHumanoid = false
	local SetGlobal = false
	
	--local p0, v0, t0 = PhysicsFolder.LastSentPosition, PhysicsFolder.LastSentVelocity, PhysicsFolder.LastSentTime
	
	local TouchedConnection
	
	TouchedConnection = projectile.Touched:Connect(function(hit)
		
		local humanoid = hit.Parent:FindFirstChildWhichIsA("Humanoid")
		local Player = Players:GetPlayerFromCharacter(hit.Parent)
		local hat = table.find(PBG_Classes, hit.Parent.ClassName)

		local p1 = projectile.Position
		local v1 = projectile.Velocity
		local t1 = time()

		local CharacterData
		local FireToServer = false

		-- Play boing sound
		if projectile:FindFirstChild("Boing") then
			if not projectile.Boing.IsPlaying and (damage > 12) then
				projectile.Boing:Play()
			end
		end
		
		-- Evaluate SB fly status
		if ProjectileType == "Superball" and (Player and Player == Players.LocalPlayer) and not SetGlobal then
			if Settings.SuperballJump and not Settings.SuperballFly then
				if _G.BB.CanSBFly then
					
					SetGlobal = true					
					task.delay(.1, function() _G.BB.CanSBFly = false end)
				end				
			end
		end
		
		-- Evaluate damage
		if humanoid and not hitHumanoid then
			if Kill:CanDamage(player, humanoid, false) then
				hitHumanoid = true
				FireToServer = true

				PaintballDamageMultiplier(projectile, hit)
				
				-- Instant damage
				if Settings.InstantDamage then
					if (humanoid.Health - projectile.Damage.Value) <= 0 then
						if (humanoid.Health == humanoid.MaxHealth) then --Fix health not updating if target player is full health
							task.delay(3, function() if math.abs(humanoid.Health - .1) < 1e6 then humanoid.Health = humanoid.MaxHealth end end)
						end
						humanoid.Health = .1
					else
						humanoid:TakeDamage(projectile.Damage.Value)
					end
				end
				
				-- Get character positions at multiple frames
				if Player then
					CharacterData = PSPV:CreateCharFrameTables(Player, _G.BB.SlaveTimeTable)
				end
				
				-- Play sound
				if _G.BB.Local.Hit ~= "None" then
					_G.BB.ClientObjects.Sounds.Hit[_G.BB.Local.Hit]:Play()
				end
				
				Aesthetics:CreateVisual(hit, player, false)
				
				TouchedConnection:Disconnect()
				
				if ProjectileType == "Superball" or ProjectileType == "Slingshot" then
					Delete(projectile, 1)
				end
				
			elseif humanoid.Parent ~= player.Character then
								
				if _G.BB.Local.BlockedHit ~="None" then
					local Sound = _G.BB.ClientObjects.Sounds.Blocked[_G.BB.Local.BlockedHit]
					if not Sound.Playing then
						Sound:Play()
					end
				end
				
				if ProjectileType == "PaintballGun" and PaintballColorCallback(hit, player) and Settings.InstantDamage then
					FireToServer = true
					
					projectile.Ready.Value = false
					Aesthetics:PaintballColor(hit, projectile.Color)
					Aesthetics:ExplodePaintball(projectile)
					
					TouchedConnection:Disconnect()
				end
			end
		elseif CanHalfDamage and IsAcceptableHit(player,hit) then
			CanHalfDamage = false
			
			-- Halving value on the client for instant damage purposes
			if ProjectileType == "Superball" or ProjectileType == "Slingshot" then
				local function halfDamage()
					projectile.Damage.Value = projectile.Damage.Value / 2
				end
				
				local halfDmgDelay = Settings.Ricochet.HalfDamageDelay
				local resetDelay = Settings.Ricochet.ResetStateDelay
				
				local function evaluateRicochet()
					if projectile.Damage.Value <= 3 then
						Delete(projectile, .2)
					else
						CanHalfDamage = true -- reset bool
					end
				end
				
				task.delay(halfDmgDelay, halfDamage)
				task.delay(resetDelay, evaluateRicochet)
			end
		end
		
		if IsAcceptableHit(player, hit) or (hat and ProjectileType == "PaintballGun" ) then
			FireToServer = true

			if ProjectileType == "PaintballGun" then
				if PaintballColorCallback(hit, player) and Settings.InstantDamage then
					Aesthetics:PaintballColor(hit, projectile.Color)
				end
				
				if humanoid ~= player.Character.Humanoid and not hat then
					TouchedConnection:Disconnect()
					
					projectile.Ready.Value = false
					Aesthetics:ExplodePaintball(projectile)
				end				
			end	
		end
		
		if FireToServer then
			local ID_array = {
				projectile.ProjectileType.Value, -- string
				projectile.Count.Value -- integer
			}
			
			
			local sendingTable = {
				ID_array, 
				hit,  -- hit part
				projectile.Damage.Value, -- integer
			}
			
			if _G.BB.Settings.Security.Master then
				
				local securityInfo = {
					p1, v1, t1, -- post hit position, velocity, and time
					CharacterData, -- table with cframe of char data (nil if security is off)
					FPS
				}
				
				for i = 1, #securityInfo do
					table.insert(sendingTable, securityInfo)
				end
			end
				
			HitRemote:FireServer(table.unpack(sendingTable))
		end
	end)
end

function HitModule:RegisterEvents()
	--[[
	Velocity parameter (v1) here can be spoofed, as we can't verify its direction component.
	Can't verify with a raycast because a ray is a singular collision point, 
	while the ball is a 3D collision box whose collision effects we cannot replicate
	
	p1 = PostPosition
	v1 = PostVelocity
	t1 = PostTime
	]]
	local Security = require(_G.BB.Modules.Security)
	HitRemote.OnServerEvent:Connect(function(playerFired, ID_array, HitPart, sentDmg, p1, v1, t1, CharacterData, ClientPhysicsFPS)
		local Now = time()
		
		local PhysicsFolder = Security:GetPhysicsFolder(ID_array, playerFired, true)
		
		if not PhysicsFolder then
			return
		end
		
		local ProjectileType = PhysicsFolder.ProjectileType.Value		
		
		local UniqueID = PhysicsFolder.UniqueID.Value
		local Humanoid = HitPart and (HitPart.Parent ~= nil) and HitPart.Parent:FindFirstChildWhichIsA("Humanoid")
		local HitPlayer = Humanoid and Players:GetPlayerFromCharacter(HitPart.Parent)
		
		local hat = HitPart and HitPart.Parent and table.find(PBG_Classes, HitPart.Parent.ClassName)
		
		if not Security:ApproveHit(PhysicsFolder, HitPlayer, p1, v1, t1, CharacterData, ClientPhysicsFPS) then
			return
		end
		
		if not HitPart or not HitPart.Parent then
			if _G.BB.Settings.Security.Update.Warn then
				--print("Projectile hit a local part!")
			end
			return
		end
		
		-- Verify hit via PSPV and deal damage
		if Humanoid
			and not hat
			and PhysicsFolder.Active.Value
			and Kill:CanDamage(playerFired, Humanoid, Settings[ProjectileType].SelfDamage) then
			
			local damage = PaintballDamageMultiplier(PhysicsFolder, HitPart) 
				or (Settings.Security.Ricochet and PhysicsFolder.Damage.Value 
					or sentDmg)
			
			if not ProjectileType == "PaintballGun" and (damage > Settings[ProjectileType].Damage) then
				warn(playerFired.Name.." exceeded max damage with weapon:", ProjectileType)
				return
			end
			
			-- Tag, deal damage, and deactivate
			Kill:TagHumanoid(playerFired, Humanoid, PhysicsFolder, ProjectileType)
			Humanoid:TakeDamage(damage)
			HitRemote:FireAllClients(playerFired, HitPart, false) -- Hit indicators
			PhysicsFolder.Active.Value = false			
		end
		
		if ProjectileType == "PaintballGun" and PaintballColorCallback(HitPart, playerFired) then
			local ProjectileColor = PhysicsFolder.RandomColor.Value
			Aesthetics:PaintballColor(HitPart, ProjectileColor)
		end
		
		if not HitPart.CanCollide and 
			(playerFired.Character:IsAncestorOf(HitPart)) and 
			not _G.BB.Settings[ProjectileType].SelfDamage then
			return
		end
				
		if (ProjectileType == "PaintballGun" and HitPart.CanCollide and not Humanoid) then
			PhysicsFolder.Active.Value = false
			return
		end
		
		-- Half damage
		if Settings.Security.Ricochet then
			local CanHalfDamage = PhysicsFolder:FindFirstChild("CanHalfDamage")
			if CanHalfDamage and CanHalfDamage.Value then
				CanHalfDamage.Value = false

				local function halfDamage()
					PhysicsFolder.Damage.Value = PhysicsFolder.Damage.Value / 2
				end

				local function evaluateRicochet()
					if PhysicsFolder.Damage.Value <= 3 then
						PhysicsFolder.Active.Value = false
					else
						CanHalfDamage.Value = true
					end
				end

				task.delay(Settings.Ricochet.HalfDamageDelay, halfDamage)
				task.delay(Settings.Ricochet.ResetStateDelay, evaluateRicochet)
			end
		end
		
	end)
end

return HitModule
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="BillboardGui" referent="RBX68FE904154E643AABB17BF55FEE0E1DC">
							<Properties>
								<bool name="Active">true</bool>
								<Ref name="Adornee">null</Ref>
								<bool name="AlwaysOnTop">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<float name="Brightness">1</float>
								<bool name="ClipsDescendants">true</bool>
								<float name="DistanceLowerLimit">0</float>
								<float name="DistanceStep">0</float>
								<float name="DistanceUpperLimit">-1</float>
								<bool name="Enabled">true</bool>
								<Vector3 name="ExtentsOffset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="ExtentsOffsetWorldSpace">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<float name="LightInfluence">0</float>
								<float name="MaxDistance">INF</float>
								<string name="Name">TimeDisplay</string>
								<Ref name="PlayerToHideFrom">null</Ref>
								<bool name="ResetOnSpawn">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<UDim2 name="Size">
									<XS>3</XS>
									<XO>0</XO>
									<YS>3</YS>
									<YO>0</YO>
								</UDim2>
								<Vector2 name="SizeOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<int64 name="SourceAssetId">-1</int64>
								<Vector3 name="StudsOffset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="StudsOffsetWorldSpace">
									<X>0</X>
									<Y>10</Y>
									<Z>0</Z>
								</Vector3>
								<BinaryString name="Tags"></BinaryString>
								<token name="ZIndexBehavior">1</token>
							</Properties>
							<Item class="Frame" referent="RBX265DD9CFC8C24D009793FBB9A7D7D00D">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">2</token>
									<int name="BorderSizePixel">2</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">Frame</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="TextLabel" referent="RBXFF3328C9AFB34BD7B5644508871A2D04">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">3</token>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/SourceSansPro.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
											<CachedFaceId><url>rbxasset://fonts/SourceSansPro-Regular.ttf</url></CachedFaceId>
										</Font>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">TextLabel</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.800000012</XS>
											<XO>0</XO>
											<YS>0.800000012</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">t = 0</string>
										<Color3 name="TextColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<bool name="TextScaled">true</bool>
										<float name="TextSize">14</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="NumberValue" referent="RBX2F2A5A70840A471CA2346A55B7CF05F9">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">SERVER_TIME</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<double name="Value">0</double>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX6035DADB68C84801A51E410003DCCC31">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">Themes</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX6176CD89098C47DBBC33DF47B859F00B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Normal</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Color3Value" referent="RBX593654DEF1A440ACAFED4E20B51BF773">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">HitColor</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<Color3 name="Value">
									<R>1</R>
									<G>0.505882382</G>
									<B>0.00784313772</B>
								</Color3>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX1B8C0B3F76D945CE98050B53FF9118BB">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">PaintballGun</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Part" referent="RBX5BC1A0F80FBE4F6A812DD90AE7C800A6">
								<Properties>
									<bool name="Anchored">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="BackParamA">-0.5</float>
									<float name="BackParamB">0.5</float>
									<token name="BackSurface">0</token>
									<token name="BackSurfaceInput">0</token>
									<float name="BottomParamA">-0.5</float>
									<float name="BottomParamB">0.5</float>
									<token name="BottomSurface">0</token>
									<token name="BottomSurfaceInput">0</token>
									<CoordinateFrame name="CFrame">
										<X>-253.131851</X>
										<Y>24.4894829</Y>
										<Z>-46.2263412</Z>
										<R00>1</R00>
										<R01>0</R01>
										<R02>0</R02>
										<R10>0</R10>
										<R11>1</R11>
										<R12>0</R12>
										<R20>0</R20>
										<R21>0</R21>
										<R22>1</R22>
									</CoordinateFrame>
									<bool name="CanCollide">true</bool>
									<bool name="CanQuery">true</bool>
									<bool name="CanTouch">true</bool>
									<bool name="CastShadow">true</bool>
									<string name="CollisionGroup">Default</string>
									<int name="CollisionGroupId">0</int>
									<Color3uint8 name="Color3uint8">4283804160</Color3uint8>
									<PhysicalProperties name="CustomPhysicalProperties">
										<CustomPhysics>false</CustomPhysics>
									</PhysicalProperties>
									<float name="FrontParamA">-0.5</float>
									<float name="FrontParamB">0.5</float>
									<token name="FrontSurface">0</token>
									<token name="FrontSurfaceInput">0</token>
									<float name="LeftParamA">-0.5</float>
									<float name="LeftParamB">0.5</float>
									<token name="LeftSurface">0</token>
									<token name="LeftSurfaceInput">0</token>
									<bool name="Locked">false</bool>
									<bool name="Massless">false</bool>
									<token name="Material">256</token>
									<string name="MaterialVariantSerialized"></string>
									<string name="Name">Paintball</string>
									<CoordinateFrame name="PivotOffset">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
										<R00>1</R00>
										<R01>0</R01>
										<R02>0</R02>
										<R10>0</R10>
										<R11>1</R11>
										<R12>0</R12>
										<R20>0</R20>
										<R21>0</R21>
										<R22>1</R22>
									</CoordinateFrame>
									<float name="Reflectance">0</float>
									<float name="RightParamA">-0.5</float>
									<float name="RightParamB">0.5</float>
									<token name="RightSurface">0</token>
									<token name="RightSurfaceInput">0</token>
									<int name="RootPriority">0</int>
									<Vector3 name="RotVelocity">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<float name="TopParamA">-0.5</float>
									<float name="TopParamB">0.5</float>
									<token name="TopSurface">0</token>
									<token name="TopSurfaceInput">0</token>
									<float name="Transparency">0</float>
									<Vector3 name="Velocity">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<token name="formFactorRaw">1</token>
									<token name="shape">0</token>
									<Vector3 name="size">
										<X>1</X>
										<Y>1</Y>
										<Z>1</Z>
									</Vector3>
								</Properties>
								<Item class="Trail" referent="RBXFD5F367EA70E4F69941ADA7EDA131954">
									<Properties>
										<Ref name="Attachment0">null</Ref>
										<Ref name="Attachment1">null</Ref>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<float name="Brightness">1</float>
										<ColorSequence name="Color">0 0.333333 0.666667 0 0 1 0.054902 0.113725 0 0 </ColorSequence>
										<bool name="Enabled">true</bool>
										<bool name="FaceCamera">true</bool>
										<float name="Lifetime">0.600000024</float>
										<float name="LightEmission">0</float>
										<float name="LightInfluence">0</float>
										<float name="MaxLength">20</float>
										<float name="MinLength">0.100000001</float>
										<string name="Name">Trail</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<Content name="Texture"><url>rbxassetid://6012541720</url></Content>
										<float name="TextureLength">0.920000017</float>
										<token name="TextureMode">0</token>
										<NumberSequence name="Transparency">0 0 0 0.92 1 0 1 1 0 </NumberSequence>
										<NumberSequence name="WidthScale">0 1 0 1 1 0 </NumberSequence>
									</Properties>
								</Item>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX05424612D5B84C2890541A1681DBAA83">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">Rocket</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Part" referent="RBXB783779ACAE44CD4A15B2750504064D3">
								<Properties>
									<bool name="Anchored">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="BackParamA">-0.5</float>
									<float name="BackParamB">0.5</float>
									<token name="BackSurface">3</token>
									<token name="BackSurfaceInput">0</token>
									<float name="BottomParamA">-0.5</float>
									<float name="BottomParamB">0.5</float>
									<token name="BottomSurface">3</token>
									<token name="BottomSurfaceInput">0</token>
									<CoordinateFrame name="CFrame">
										<X>-315.175781</X>
										<Y>28.1212273</Y>
										<Z>-198.968689</Z>
										<R00>0.152875558</R00>
										<R01>-0.390300572</R01>
										<R02>-0.907906651</R02>
										<R10>-5.60227065e-09</R10>
										<R11>0.918705642</R11>
										<R12>-0.394942939</R12>
										<R20>0.988245428</R20>
										<R21>0.0603771284</R21>
										<R22>0.140447631</R22>
									</CoordinateFrame>
									<bool name="CanCollide">false</bool>
									<bool name="CanQuery">true</bool>
									<bool name="CanTouch">true</bool>
									<bool name="CastShadow">true</bool>
									<string name="CollisionGroup">Default</string>
									<int name="CollisionGroupId">0</int>
									<Color3uint8 name="Color3uint8">4279069100</Color3uint8>
									<PhysicalProperties name="CustomPhysicalProperties">
										<CustomPhysics>false</CustomPhysics>
									</PhysicalProperties>
									<float name="FrontParamA">-0.5</float>
									<float name="FrontParamB">0.5</float>
									<token name="FrontSurface">3</token>
									<token name="FrontSurfaceInput">0</token>
									<float name="LeftParamA">-0.5</float>
									<float name="LeftParamB">0.5</float>
									<token name="LeftSurface">3</token>
									<token name="LeftSurfaceInput">0</token>
									<bool name="Locked">false</bool>
									<bool name="Massless">true</bool>
									<token name="Material">256</token>
									<string name="MaterialVariantSerialized"></string>
									<string name="Name">Rocket</string>
									<CoordinateFrame name="PivotOffset">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
										<R00>1</R00>
										<R01>0</R01>
										<R02>0</R02>
										<R10>0</R10>
										<R11>1</R11>
										<R12>0</R12>
										<R20>0</R20>
										<R21>0</R21>
										<R22>1</R22>
									</CoordinateFrame>
									<float name="Reflectance">0</float>
									<float name="RightParamA">-0.5</float>
									<float name="RightParamB">0.5</float>
									<token name="RightSurface">3</token>
									<token name="RightSurfaceInput">0</token>
									<int name="RootPriority">0</int>
									<Vector3 name="RotVelocity">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags">Um9ja2V0AFByb2plY3RpbGU=</BinaryString>
									<float name="TopParamA">-0.5</float>
									<float name="TopParamB">0.5</float>
									<token name="TopSurface">3</token>
									<token name="TopSurfaceInput">0</token>
									<float name="Transparency">0</float>
									<Vector3 name="Velocity">
										<X>54.4743996</X>
										<Y>23.6965771</Y>
										<Z>-8.42685795</Z>
									</Vector3>
									<token name="formFactorRaw">1</token>
									<token name="shape">1</token>
									<Vector3 name="size">
										<X>1</X>
										<Y>1</Y>
										<Z>4</Z>
									</Vector3>
								</Properties>
								<Item class="Trail" referent="RBXB98F06E0B8A44BA682FC9E771C4EEFD5">
									<Properties>
										<Ref name="Attachment0">null</Ref>
										<Ref name="Attachment1">null</Ref>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<float name="Brightness">1</float>
										<ColorSequence name="Color">0 0.0509804 0.411765 0.67451 0 1 0 0.121569 0.407843 0 </ColorSequence>
										<bool name="Enabled">true</bool>
										<bool name="FaceCamera">true</bool>
										<float name="Lifetime">0.600000024</float>
										<float name="LightEmission">0</float>
										<float name="LightInfluence">0</float>
										<float name="MaxLength">20</float>
										<float name="MinLength">0.100000001</float>
										<string name="Name">Trail</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<Content name="Texture"><url>rbxassetid://6012541720</url></Content>
										<float name="TextureLength">0.920000017</float>
										<token name="TextureMode">0</token>
										<NumberSequence name="Transparency">0 0 0 0.92 1 0 1 1 0 </NumberSequence>
										<NumberSequence name="WidthScale">0 1 0 1 1 0 </NumberSequence>
									</Properties>
								</Item>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX02B48EFC8E734A598C78FB0B6EC098DA">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">Slingshot</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Part" referent="RBX8B41DED368AF4B949184E387239157C9">
								<Properties>
									<bool name="Anchored">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="BackParamA">-0.5</float>
									<float name="BackParamB">0.5</float>
									<token name="BackSurface">0</token>
									<token name="BackSurfaceInput">0</token>
									<float name="BottomParamA">-0.5</float>
									<float name="BottomParamB">0.5</float>
									<token name="BottomSurface">0</token>
									<token name="BottomSurfaceInput">0</token>
									<CoordinateFrame name="CFrame">
										<X>-253.131851</X>
										<Y>24.4894829</Y>
										<Z>-46.2263412</Z>
										<R00>1</R00>
										<R01>0</R01>
										<R02>0</R02>
										<R10>0</R10>
										<R11>1</R11>
										<R12>0</R12>
										<R20>0</R20>
										<R21>0</R21>
										<R22>1</R22>
									</CoordinateFrame>
									<bool name="CanCollide">true</bool>
									<bool name="CanQuery">true</bool>
									<bool name="CanTouch">true</bool>
									<bool name="CastShadow">true</bool>
									<string name="CollisionGroup">Default</string>
									<int name="CollisionGroupId">0</int>
									<Color3uint8 name="Color3uint8">4284177769</Color3uint8>
									<PhysicalProperties name="CustomPhysicalProperties">
										<CustomPhysics>false</CustomPhysics>
									</PhysicalProperties>
									<float name="FrontParamA">-0.5</float>
									<float name="FrontParamB">0.5</float>
									<token name="FrontSurface">0</token>
									<token name="FrontSurfaceInput">0</token>
									<float name="LeftParamA">-0.5</float>
									<float name="LeftParamB">0.5</float>
									<token name="LeftSurface">0</token>
									<token name="LeftSurfaceInput">0</token>
									<bool name="Locked">false</bool>
									<bool name="Massless">false</bool>
									<token name="Material">256</token>
									<string name="MaterialVariantSerialized"></string>
									<string name="Name">Pellet</string>
									<CoordinateFrame name="PivotOffset">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
										<R00>1</R00>
										<R01>0</R01>
										<R02>0</R02>
										<R10>0</R10>
										<R11>1</R11>
										<R12>0</R12>
										<R20>0</R20>
										<R21>0</R21>
										<R22>1</R22>
									</CoordinateFrame>
									<float name="Reflectance">0</float>
									<float name="RightParamA">-0.5</float>
									<float name="RightParamB">0.5</float>
									<token name="RightSurface">0</token>
									<token name="RightSurfaceInput">0</token>
									<int name="RootPriority">0</int>
									<Vector3 name="RotVelocity">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<float name="TopParamA">-0.5</float>
									<float name="TopParamB">0.5</float>
									<token name="TopSurface">0</token>
									<token name="TopSurfaceInput">0</token>
									<float name="Transparency">0</float>
									<Vector3 name="Velocity">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<token name="formFactorRaw">1</token>
									<token name="shape">0</token>
									<Vector3 name="size">
										<X>1</X>
										<Y>1</Y>
										<Z>1</Z>
									</Vector3>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBXF3F595A9040347C08318B1B836BAC102">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">Superball</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Part" referent="RBX3BE5AAC68D9C408C9992E690E8C0F611">
								<Properties>
									<bool name="Anchored">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="BackParamA">-0.5</float>
									<float name="BackParamB">0.5</float>
									<token name="BackSurface">0</token>
									<token name="BackSurfaceInput">0</token>
									<float name="BottomParamA">-0.5</float>
									<float name="BottomParamB">0.5</float>
									<token name="BottomSurface">0</token>
									<token name="BottomSurfaceInput">0</token>
									<CoordinateFrame name="CFrame">
										<X>-253.131851</X>
										<Y>24.4894829</Y>
										<Z>-46.2263412</Z>
										<R00>1</R00>
										<R01>0</R01>
										<R02>0</R02>
										<R10>0</R10>
										<R11>1</R11>
										<R12>0</R12>
										<R20>0</R20>
										<R21>0</R21>
										<R22>1</R22>
									</CoordinateFrame>
									<bool name="CanCollide">true</bool>
									<bool name="CanQuery">true</bool>
									<bool name="CanTouch">true</bool>
									<bool name="CastShadow">true</bool>
									<string name="CollisionGroup">Default</string>
									<int name="CollisionGroupId">0</int>
									<Color3uint8 name="Color3uint8">4291045404</Color3uint8>
									<PhysicalProperties name="CustomPhysicalProperties">
										<CustomPhysics>false</CustomPhysics>
									</PhysicalProperties>
									<float name="FrontParamA">-0.5</float>
									<float name="FrontParamB">0.5</float>
									<token name="FrontSurface">0</token>
									<token name="FrontSurfaceInput">0</token>
									<float name="LeftParamA">-0.5</float>
									<float name="LeftParamB">0.5</float>
									<token name="LeftSurface">0</token>
									<token name="LeftSurfaceInput">0</token>
									<bool name="Locked">false</bool>
									<bool name="Massless">false</bool>
									<token name="Material">256</token>
									<string name="MaterialVariantSerialized"></string>
									<string name="Name">Superball</string>
									<CoordinateFrame name="PivotOffset">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
										<R00>1</R00>
										<R01>0</R01>
										<R02>0</R02>
										<R10>0</R10>
										<R11>1</R11>
										<R12>0</R12>
										<R20>0</R20>
										<R21>0</R21>
										<R22>1</R22>
									</CoordinateFrame>
									<float name="Reflectance">0</float>
									<float name="RightParamA">-0.5</float>
									<float name="RightParamB">0.5</float>
									<token name="RightSurface">0</token>
									<token name="RightSurfaceInput">0</token>
									<int name="RootPriority">0</int>
									<Vector3 name="RotVelocity">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<float name="TopParamA">-0.5</float>
									<float name="TopParamB">0.5</float>
									<token name="TopSurface">0</token>
									<token name="TopSurfaceInput">0</token>
									<float name="Transparency">0</float>
									<Vector3 name="Velocity">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<token name="formFactorRaw">1</token>
									<token name="shape">0</token>
									<Vector3 name="size">
										<X>2</X>
										<Y>2</Y>
										<Z>2</Z>
									</Vector3>
								</Properties>
								<Item class="Trail" referent="RBX7239FD5489254F0D9EA69A955D5C267C">
									<Properties>
										<Ref name="Attachment0">null</Ref>
										<Ref name="Attachment1">null</Ref>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<float name="Brightness">1</float>
										<ColorSequence name="Color">0 0.666667 0 0 0 1 0.333333 0 0 0 </ColorSequence>
										<bool name="Enabled">true</bool>
										<bool name="FaceCamera">true</bool>
										<float name="Lifetime">0.600000024</float>
										<float name="LightEmission">0</float>
										<float name="LightInfluence">0</float>
										<float name="MaxLength">20</float>
										<float name="MinLength">0.100000001</float>
										<string name="Name">Trail</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<Content name="Texture"><url>rbxassetid://6012541720</url></Content>
										<float name="TextureLength">0.920000017</float>
										<token name="TextureMode">0</token>
										<NumberSequence name="Transparency">0 0 0 0.92 1 0 1 1 0 </NumberSequence>
										<NumberSequence name="WidthScale">0 1 0 1 1 0 </NumberSequence>
									</Properties>
								</Item>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX326F226B161A411FAF367B9664592F9B">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">Sword</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Part" referent="RBXBAE9CBBB08C84A609A8A785CA44D0E9A">
								<Properties>
									<bool name="Anchored">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="BackParamA">-0.5</float>
									<float name="BackParamB">0.5</float>
									<token name="BackSurface">0</token>
									<token name="BackSurfaceInput">0</token>
									<float name="BottomParamA">-0.5</float>
									<float name="BottomParamB">0.5</float>
									<token name="BottomSurface">0</token>
									<token name="BottomSurfaceInput">0</token>
									<CoordinateFrame name="CFrame">
										<X>-260.254883</X>
										<Y>6.35914135</Y>
										<Z>-206.326324</Z>
										<R00>-0.99999994</R00>
										<R01>0</R01>
										<R02>0</R02>
										<R10>0</R10>
										<R11>0</R11>
										<R12>-1</R12>
										<R20>0</R20>
										<R21>-0.99999994</R21>
										<R22>0</R22>
									</CoordinateFrame>
									<bool name="CanCollide">true</bool>
									<bool name="CanQuery">true</bool>
									<bool name="CanTouch">true</bool>
									<bool name="CastShadow">true</bool>
									<string name="CollisionGroup">Default</string>
									<int name="CollisionGroupId">0</int>
									<Color3uint8 name="Color3uint8">4279308561</Color3uint8>
									<PhysicalProperties name="CustomPhysicalProperties">
										<CustomPhysics>false</CustomPhysics>
									</PhysicalProperties>
									<float name="FrontParamA">-0.5</float>
									<float name="FrontParamB">0.5</float>
									<token name="FrontSurface">0</token>
									<token name="FrontSurfaceInput">0</token>
									<float name="LeftParamA">-0.5</float>
									<float name="LeftParamB">0.5</float>
									<token name="LeftSurface">0</token>
									<token name="LeftSurfaceInput">0</token>
									<bool name="Locked">false</bool>
									<bool name="Massless">false</bool>
									<token name="Material">256</token>
									<string name="MaterialVariantSerialized"></string>
									<string name="Name">Handle</string>
									<CoordinateFrame name="PivotOffset">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
										<R00>1</R00>
										<R01>0</R01>
										<R02>0</R02>
										<R10>0</R10>
										<R11>1</R11>
										<R12>0</R12>
										<R20>0</R20>
										<R21>0</R21>
										<R22>1</R22>
									</CoordinateFrame>
									<float name="Reflectance">0.400000006</float>
									<float name="RightParamA">-0.5</float>
									<float name="RightParamB">0.5</float>
									<token name="RightSurface">0</token>
									<token name="RightSurfaceInput">0</token>
									<int name="RootPriority">0</int>
									<Vector3 name="RotVelocity">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<float name="TopParamA">-0.5</float>
									<float name="TopParamB">0.5</float>
									<token name="TopSurface">0</token>
									<token name="TopSurfaceInput">0</token>
									<float name="Transparency">0</float>
									<Vector3 name="Velocity">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<token name="formFactorRaw">1</token>
									<token name="shape">1</token>
									<Vector3 name="size">
										<X>1</X>
										<Y>0.800000012</Y>
										<Z>4</Z>
									</Vector3>
								</Properties>
								<Item class="SpecialMesh" referent="RBX85DFEDEC1C604BDFBDEE08B55331B844">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<token name="LODX">2</token>
										<token name="LODY">2</token>
										<Content name="MeshId"><url>rbxasset://fonts/sword.mesh</url></Content>
										<token name="MeshType">5</token>
										<string name="Name">Mesh</string>
										<Vector3 name="Offset">
											<X>0</X>
											<Y>0</Y>
											<Z>0</Z>
										</Vector3>
										<Vector3 name="Scale">
											<X>1</X>
											<Y>1</Y>
											<Z>1</Z>
										</Vector3>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<Content name="TextureId"><url>rbxasset://textures/SwordTexture.png</url></Content>
										<Vector3 name="VertexColor">
											<X>1</X>
											<Y>1</Y>
											<Z>1</Z>
										</Vector3>
									</Properties>
								</Item>
							</Item>
						</Item>
						<Item class="Folder" referent="RBXA22F0AFBAF614575B63227387BB95C5E">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">Trowel</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Part" referent="RBX1197F71858EC437AA60F5186E8B8E81D">
								<Properties>
									<bool name="Anchored">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="BackParamA">-0.5</float>
									<float name="BackParamB">0.5</float>
									<token name="BackSurface">0</token>
									<token name="BackSurfaceInput">0</token>
									<float name="BottomParamA">-0.5</float>
									<float name="BottomParamB">0.5</float>
									<token name="BottomSurface">0</token>
									<token name="BottomSurfaceInput">0</token>
									<CoordinateFrame name="CFrame">
										<X>-253.131851</X>
										<Y>-28.8704643</Y>
										<Z>-46.2263412</Z>
										<R00>1</R00>
										<R01>0</R01>
										<R02>0</R02>
										<R10>0</R10>
										<R11>1</R11>
										<R12>0</R12>
										<R20>0</R20>
										<R21>0</R21>
										<R22>1</R22>
									</CoordinateFrame>
									<bool name="CanCollide">true</bool>
									<bool name="CanQuery">true</bool>
									<bool name="CanTouch">true</bool>
									<bool name="CastShadow">true</bool>
									<string name="CollisionGroup">Default</string>
									<int name="CollisionGroupId">0</int>
									<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
									<PhysicalProperties name="CustomPhysicalProperties">
										<CustomPhysics>false</CustomPhysics>
									</PhysicalProperties>
									<float name="FrontParamA">-0.5</float>
									<float name="FrontParamB">0.5</float>
									<token name="FrontSurface">0</token>
									<token name="FrontSurfaceInput">0</token>
									<float name="LeftParamA">-0.5</float>
									<float name="LeftParamB">0.5</float>
									<token name="LeftSurface">0</token>
									<token name="LeftSurfaceInput">0</token>
									<bool name="Locked">false</bool>
									<bool name="Massless">false</bool>
									<token name="Material">256</token>
									<string name="MaterialVariantSerialized"></string>
									<string name="Name">Brick</string>
									<CoordinateFrame name="PivotOffset">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
										<R00>1</R00>
										<R01>0</R01>
										<R02>0</R02>
										<R10>0</R10>
										<R11>1</R11>
										<R12>0</R12>
										<R20>0</R20>
										<R21>0</R21>
										<R22>1</R22>
									</CoordinateFrame>
									<float name="Reflectance">0</float>
									<float name="RightParamA">-0.5</float>
									<float name="RightParamB">0.5</float>
									<token name="RightSurface">0</token>
									<token name="RightSurfaceInput">0</token>
									<int name="RootPriority">0</int>
									<Vector3 name="RotVelocity">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<float name="TopParamA">-0.5</float>
									<float name="TopParamB">0.5</float>
									<token name="TopSurface">0</token>
									<token name="TopSurfaceInput">0</token>
									<float name="Transparency">0</float>
									<Vector3 name="Velocity">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<token name="formFactorRaw">1</token>
									<token name="shape">1</token>
									<Vector3 name="size">
										<X>4</X>
										<Y>1</Y>
										<Z>2</Z>
									</Vector3>
								</Properties>
							</Item>
							<Item class="UIGradient" referent="RBX509C8BF43FD94F65AA769C8FE7F3559B">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<ColorSequence name="Color">0 0.498039 0.498039 0.498039 0 1 0.498039 0.498039 0.498039 0 </ColorSequence>
									<bool name="Enabled">true</bool>
									<string name="Name">Color</string>
									<Vector2 name="Offset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="Rotation">0</float>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX089F16FDF47F48D88B8357452C9F4FE1">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">Bomb</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Part" referent="RBX7E695E9CC2BE42D7B190D5AE5052B7E5">
								<Properties>
									<bool name="Anchored">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="BackParamA">-0.5</float>
									<float name="BackParamB">0.5</float>
									<token name="BackSurface">0</token>
									<token name="BackSurfaceInput">0</token>
									<float name="BottomParamA">-0.5</float>
									<float name="BottomParamB">0.5</float>
									<token name="BottomSurface">0</token>
									<token name="BottomSurfaceInput">0</token>
									<CoordinateFrame name="CFrame">
										<X>-253.131851</X>
										<Y>24.4894829</Y>
										<Z>-46.2263412</Z>
										<R00>1</R00>
										<R01>0</R01>
										<R02>0</R02>
										<R10>0</R10>
										<R11>1</R11>
										<R12>0</R12>
										<R20>0</R20>
										<R21>0</R21>
										<R22>1</R22>
									</CoordinateFrame>
									<bool name="CanCollide">true</bool>
									<bool name="CanQuery">true</bool>
									<bool name="CanTouch">true</bool>
									<bool name="CastShadow">true</bool>
									<string name="CollisionGroup">Default</string>
									<int name="CollisionGroupId">0</int>
									<Color3uint8 name="Color3uint8">4279970357</Color3uint8>
									<PhysicalProperties name="CustomPhysicalProperties">
										<CustomPhysics>false</CustomPhysics>
									</PhysicalProperties>
									<float name="FrontParamA">-0.5</float>
									<float name="FrontParamB">0.5</float>
									<token name="FrontSurface">0</token>
									<token name="FrontSurfaceInput">0</token>
									<float name="LeftParamA">-0.5</float>
									<float name="LeftParamB">0.5</float>
									<token name="LeftSurface">0</token>
									<token name="LeftSurfaceInput">0</token>
									<bool name="Locked">false</bool>
									<bool name="Massless">false</bool>
									<token name="Material">256</token>
									<string name="MaterialVariantSerialized"></string>
									<string name="Name">Base</string>
									<CoordinateFrame name="PivotOffset">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
										<R00>1</R00>
										<R01>0</R01>
										<R02>0</R02>
										<R10>0</R10>
										<R11>1</R11>
										<R12>0</R12>
										<R20>0</R20>
										<R21>0</R21>
										<R22>1</R22>
									</CoordinateFrame>
									<float name="Reflectance">0</float>
									<float name="RightParamA">-0.5</float>
									<float name="RightParamB">0.5</float>
									<token name="RightSurface">0</token>
									<token name="RightSurfaceInput">0</token>
									<int name="RootPriority">0</int>
									<Vector3 name="RotVelocity">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<float name="TopParamA">-0.5</float>
									<float name="TopParamB">0.5</float>
									<token name="TopSurface">0</token>
									<token name="TopSurfaceInput">0</token>
									<float name="Transparency">0</float>
									<Vector3 name="Velocity">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<token name="formFactorRaw">1</token>
									<token name="shape">0</token>
									<Vector3 name="size">
										<X>2</X>
										<Y>2</Y>
										<Z>2</Z>
									</Vector3>
								</Properties>
							</Item>
							<Item class="Color3Value" referent="RBX105828C628794C319DB07B5709923717">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">TickColor</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<Color3 name="Value">
										<R>0.666666687</R>
										<G>0</G>
										<B>0</B>
									</Color3>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX0246626118814140B95317B2256C2608">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">ExplosionParticles</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ParticleEmitter" referent="RBX6E303424F6364FF8B96D9340037151A0">
								<Properties>
									<Vector3 name="Acceleration">
										<X>0</X>
										<Y>1.25</Y>
										<Z>0</Z>
									</Vector3>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="Brightness">1</float>
									<ColorSequence name="Color">0 0.792157 0.0627451 0 0 1 0.976471 0.815686 0 0 </ColorSequence>
									<float name="Drag">0</float>
									<token name="EmissionDirection">1</token>
									<bool name="Enabled">false</bool>
									<NumberRange name="FlipbookFramerate">1 1 </NumberRange>
									<string name="FlipbookIncompatible">Particle texture must be 1024 by 1024 to use flipbooks.</string>
									<token name="FlipbookLayout">0</token>
									<token name="FlipbookMode">0</token>
									<bool name="FlipbookStartRandom">false</bool>
									<NumberRange name="Lifetime">0.25 0.5 </NumberRange>
									<float name="LightEmission">0.349999994</float>
									<float name="LightInfluence">0</float>
									<bool name="LockedToPart">false</bool>
									<string name="Name">Fire</string>
									<token name="Orientation">0</token>
									<float name="Rate">500</float>
									<NumberRange name="RotSpeed">-90 90 </NumberRange>
									<NumberRange name="Rotation">-45 45 </NumberRange>
									<token name="Shape">0</token>
									<token name="ShapeInOut">0</token>
									<float name="ShapePartial">1</float>
									<token name="ShapeStyle">0</token>
									<NumberSequence name="Size">0 0.5 0.45 0.494 1 0.5 0.903 0.5 0.45 1 0 0 </NumberSequence>
									<int64 name="SourceAssetId">-1</int64>
									<NumberRange name="Speed">7.5 15 </NumberRange>
									<Vector2 name="SpreadAngle">
										<X>1000</X>
										<Y>1000</Y>
									</Vector2>
									<NumberSequence name="Squash">0 0 0 1 0 0 </NumberSequence>
									<BinaryString name="Tags"></BinaryString>
									<Content name="Texture"><url>http://www.roblox.com/asset/?id=245591535</url></Content>
									<float name="TimeScale">1</float>
									<NumberSequence name="Transparency">0 1 0 0.113466 0.33125 0.1 0.334165 0.10625 0.0625 0.48005 0.05 0.05 0.73192 0.1125 0.04375 0.841646 0.34375 0.0972782 0.887781 0.6 0.1 0.958853 0.8375 0.0916895 1 1 0 </NumberSequence>
									<float name="VelocityInheritance">0</float>
									<float name="ZOffset">0</float>
								</Properties>
							</Item>
							<Item class="ParticleEmitter" referent="RBX3CF0608B0C9A4E2A82C5642CAAC4B83F">
								<Properties>
									<Vector3 name="Acceleration">
										<X>0</X>
										<Y>75</Y>
										<Z>0</Z>
									</Vector3>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="Brightness">1</float>
									<ColorSequence name="Color">0 0.686275 0.67451 0.596078 0 1 0.117647 0.117647 0.117647 0 </ColorSequence>
									<float name="Drag">0</float>
									<token name="EmissionDirection">1</token>
									<bool name="Enabled">false</bool>
									<NumberRange name="FlipbookFramerate">1 1 </NumberRange>
									<string name="FlipbookIncompatible">Particle texture must be 1024 by 1024 to use flipbooks.</string>
									<token name="FlipbookLayout">0</token>
									<token name="FlipbookMode">0</token>
									<bool name="FlipbookStartRandom">false</bool>
									<NumberRange name="Lifetime">0.45 0.5 </NumberRange>
									<float name="LightEmission">0</float>
									<float name="LightInfluence">0</float>
									<bool name="LockedToPart">false</bool>
									<string name="Name">Smoke</string>
									<token name="Orientation">0</token>
									<float name="Rate">75</float>
									<NumberRange name="RotSpeed">-90 90 </NumberRange>
									<NumberRange name="Rotation">-45 45 </NumberRange>
									<token name="Shape">0</token>
									<token name="ShapeInOut">0</token>
									<float name="ShapePartial">1</float>
									<token name="ShapeStyle">0</token>
									<NumberSequence name="Size">0 0.1 0.05 0.494 0.25 0.125 0.95 1.25 0.5 1 0 0 </NumberSequence>
									<int64 name="SourceAssetId">-1</int64>
									<NumberRange name="Speed">0 0 </NumberRange>
									<Vector2 name="SpreadAngle">
										<X>100</X>
										<Y>100</Y>
									</Vector2>
									<NumberSequence name="Squash">0 0 0 1 0 0 </NumberSequence>
									<BinaryString name="Tags"></BinaryString>
									<Content name="Texture"><url>http://www.roblox.com/asset/?id=245591535</url></Content>
									<float name="TimeScale">1</float>
									<NumberSequence name="Transparency">0 1 0 0.113466 0.33125 0.1 0.334165 0.10625 0.0625 0.48005 0.05 0.05 0.73192 0.1125 0.04375 0.841646 0.34375 0.0972782 0.887781 0.6 0.1 0.958853 0.8375 0.0916895 1 1 0 </NumberSequence>
									<float name="VelocityInheritance">0</float>
									<float name="ZOffset">0</float>
								</Properties>
							</Item>
							<Item class="ParticleEmitter" referent="RBXCF13F6B46A6C4E0480F190EFCAF94DE8">
								<Properties>
									<Vector3 name="Acceleration">
										<X>0</X>
										<Y>-10</Y>
										<Z>0</Z>
									</Vector3>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="Brightness">1</float>
									<ColorSequence name="Color">0 0.960784 0.639216 0 0 1 0.976471 0.815686 0 0 </ColorSequence>
									<float name="Drag">0</float>
									<token name="EmissionDirection">1</token>
									<bool name="Enabled">false</bool>
									<NumberRange name="FlipbookFramerate">1 1 </NumberRange>
									<string name="FlipbookIncompatible">Particle texture must be 1024 by 1024 to use flipbooks.</string>
									<token name="FlipbookLayout">0</token>
									<token name="FlipbookMode">0</token>
									<bool name="FlipbookStartRandom">false</bool>
									<NumberRange name="Lifetime">0.25 0.5 </NumberRange>
									<float name="LightEmission">1</float>
									<float name="LightInfluence">0</float>
									<bool name="LockedToPart">false</bool>
									<string name="Name">Sparks</string>
									<token name="Orientation">0</token>
									<float name="Rate">250</float>
									<NumberRange name="RotSpeed">-90 90 </NumberRange>
									<NumberRange name="Rotation">-45 45 </NumberRange>
									<token name="Shape">0</token>
									<token name="ShapeInOut">0</token>
									<float name="ShapePartial">1</float>
									<token name="ShapeStyle">0</token>
									<NumberSequence name="Size">0 0.05 0.025 0.494 0.1 0.05 0.903 0.05 0.025 1 0 0 </NumberSequence>
									<int64 name="SourceAssetId">-1</int64>
									<NumberRange name="Speed">15 15 </NumberRange>
									<Vector2 name="SpreadAngle">
										<X>1000</X>
										<Y>1000</Y>
									</Vector2>
									<NumberSequence name="Squash">0 0 0 1 0 0 </NumberSequence>
									<BinaryString name="Tags"></BinaryString>
									<Content name="Texture"><url>http://www.roblox.com/asset/?id=293257816</url></Content>
									<float name="TimeScale">1</float>
									<NumberSequence name="Transparency">0 1 0 0.113466 0.33125 0.1 0.334165 0.10625 0.0625 0.48005 0.05 0.05 0.73192 0.1125 0.04375 0.841646 0.34375 0.0972782 0.887781 0.6 0.1 0.958853 0.8375 0.0916895 1 1 0 </NumberSequence>
									<float name="VelocityInheritance">0</float>
									<float name="ZOffset">0</float>
								</Properties>
							</Item>
							<Item class="ParticleEmitter" referent="RBX28D8F2880C314FE89310087DDF3112E0">
								<Properties>
									<Vector3 name="Acceleration">
										<X>0</X>
										<Y>-1.25</Y>
										<Z>0</Z>
									</Vector3>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="Brightness">1</float>
									<ColorSequence name="Color">0 0.960784 0.290196 0.0235294 0 1 0.976471 0.192157 0.309804 0 </ColorSequence>
									<float name="Drag">0</float>
									<token name="EmissionDirection">1</token>
									<bool name="Enabled">false</bool>
									<NumberRange name="FlipbookFramerate">1 1 </NumberRange>
									<string name="FlipbookIncompatible">Particle texture must be 1024 by 1024 to use flipbooks.</string>
									<token name="FlipbookLayout">0</token>
									<token name="FlipbookMode">0</token>
									<bool name="FlipbookStartRandom">false</bool>
									<NumberRange name="Lifetime">0.25 0.5 </NumberRange>
									<float name="LightEmission">1</float>
									<float name="LightInfluence">0</float>
									<bool name="LockedToPart">false</bool>
									<string name="Name">Stars</string>
									<token name="Orientation">0</token>
									<float name="Rate">125</float>
									<NumberRange name="RotSpeed">-90 90 </NumberRange>
									<NumberRange name="Rotation">-45 45 </NumberRange>
									<token name="Shape">0</token>
									<token name="ShapeInOut">0</token>
									<float name="ShapePartial">1</float>
									<token name="ShapeStyle">0</token>
									<NumberSequence name="Size">0 0.05 0.025 0.494 0.1 0.05 0.903 0.05 0.025 1 0 0 </NumberSequence>
									<int64 name="SourceAssetId">-1</int64>
									<NumberRange name="Speed">15 15 </NumberRange>
									<Vector2 name="SpreadAngle">
										<X>1000</X>
										<Y>1000</Y>
									</Vector2>
									<NumberSequence name="Squash">0 0 0 1 0 0 </NumberSequence>
									<BinaryString name="Tags"></BinaryString>
									<Content name="Texture"><url>http://www.roblox.com/asset/?id=326141921</url></Content>
									<float name="TimeScale">1</float>
									<NumberSequence name="Transparency">0 1 0 0.113466 0.33125 0.1 0.334165 0.10625 0.0625 0.48005 0.05 0.05 0.73192 0.1125 0.04375 0.841646 0.34375 0.0972782 0.887781 0.6 0.1 0.958853 0.8375 0.0916895 1 1 0 </NumberSequence>
									<float name="VelocityInheritance">0</float>
									<float name="ZOffset">0</float>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX0EC04A40170640B5B90F90FB68A816DD">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">Explosion</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="NumberValue" referent="RBX7E652037484845C893F0054B4A594CD1">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">BaseTime</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">0.2999999999999999889</double>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBXA8E6E589D88145F1AEE21BB10853EC28">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">ThemeTime</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">0.5999999999999999778</double>
								</Properties>
							</Item>
							<Item class="Part" referent="RBX992514AD340746E19F6D646A0829C1AF">
								<Properties>
									<bool name="Anchored">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="BackParamA">-0.5</float>
									<float name="BackParamB">0.5</float>
									<token name="BackSurface">0</token>
									<token name="BackSurfaceInput">0</token>
									<float name="BottomParamA">-0.5</float>
									<float name="BottomParamB">0.5</float>
									<token name="BottomSurface">0</token>
									<token name="BottomSurfaceInput">0</token>
									<CoordinateFrame name="CFrame">
										<X>-253.131851</X>
										<Y>24.4894829</Y>
										<Z>-46.2263412</Z>
										<R00>1</R00>
										<R01>0</R01>
										<R02>0</R02>
										<R10>0</R10>
										<R11>1</R11>
										<R12>0</R12>
										<R20>0</R20>
										<R21>0</R21>
										<R22>1</R22>
									</CoordinateFrame>
									<bool name="CanCollide">true</bool>
									<bool name="CanQuery">true</bool>
									<bool name="CanTouch">true</bool>
									<bool name="CastShadow">false</bool>
									<string name="CollisionGroup">Default</string>
									<int name="CollisionGroupId">0</int>
									<Color3uint8 name="Color3uint8">4292815903</Color3uint8>
									<PhysicalProperties name="CustomPhysicalProperties">
										<CustomPhysics>false</CustomPhysics>
									</PhysicalProperties>
									<float name="FrontParamA">-0.5</float>
									<float name="FrontParamB">0.5</float>
									<token name="FrontSurface">0</token>
									<token name="FrontSurfaceInput">0</token>
									<float name="LeftParamA">-0.5</float>
									<float name="LeftParamB">0.5</float>
									<token name="LeftSurface">0</token>
									<token name="LeftSurfaceInput">0</token>
									<bool name="Locked">false</bool>
									<bool name="Massless">false</bool>
									<token name="Material">256</token>
									<string name="MaterialVariantSerialized"></string>
									<string name="Name">Base</string>
									<CoordinateFrame name="PivotOffset">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
										<R00>1</R00>
										<R01>0</R01>
										<R02>0</R02>
										<R10>0</R10>
										<R11>1</R11>
										<R12>0</R12>
										<R20>0</R20>
										<R21>0</R21>
										<R22>1</R22>
									</CoordinateFrame>
									<float name="Reflectance">0</float>
									<float name="RightParamA">-0.5</float>
									<float name="RightParamB">0.5</float>
									<token name="RightSurface">0</token>
									<token name="RightSurfaceInput">0</token>
									<int name="RootPriority">0</int>
									<Vector3 name="RotVelocity">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<float name="TopParamA">-0.5</float>
									<float name="TopParamB">0.5</float>
									<token name="TopSurface">0</token>
									<token name="TopSurfaceInput">0</token>
									<float name="Transparency">0.400000006</float>
									<Vector3 name="Velocity">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<token name="formFactorRaw">1</token>
									<token name="shape">0</token>
									<Vector3 name="size">
										<X>2</X>
										<Y>2</Y>
										<Z>2</Z>
									</Vector3>
								</Properties>
							</Item>
							<Item class="Part" referent="RBXC83A529E420D4DDCA0B9CCC77E619099">
								<Properties>
									<bool name="Anchored">false</bool>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="BackParamA">-0.5</float>
									<float name="BackParamB">0.5</float>
									<token name="BackSurface">0</token>
									<token name="BackSurfaceInput">0</token>
									<float name="BottomParamA">-0.5</float>
									<float name="BottomParamB">0.5</float>
									<token name="BottomSurface">0</token>
									<token name="BottomSurfaceInput">0</token>
									<CoordinateFrame name="CFrame">
										<X>-253.131851</X>
										<Y>24.4894829</Y>
										<Z>-46.2263412</Z>
										<R00>1</R00>
										<R01>0</R01>
										<R02>0</R02>
										<R10>0</R10>
										<R11>1</R11>
										<R12>0</R12>
										<R20>0</R20>
										<R21>0</R21>
										<R22>1</R22>
									</CoordinateFrame>
									<bool name="CanCollide">true</bool>
									<bool name="CanQuery">true</bool>
									<bool name="CanTouch">true</bool>
									<bool name="CastShadow">false</bool>
									<string name="CollisionGroup">Default</string>
									<int name="CollisionGroupId">0</int>
									<Color3uint8 name="Color3uint8">4294928387</Color3uint8>
									<PhysicalProperties name="CustomPhysicalProperties">
										<CustomPhysics>false</CustomPhysics>
									</PhysicalProperties>
									<float name="FrontParamA">-0.5</float>
									<float name="FrontParamB">0.5</float>
									<token name="FrontSurface">0</token>
									<token name="FrontSurfaceInput">0</token>
									<float name="LeftParamA">-0.5</float>
									<float name="LeftParamB">0.5</float>
									<token name="LeftSurface">0</token>
									<token name="LeftSurfaceInput">0</token>
									<bool name="Locked">false</bool>
									<bool name="Massless">false</bool>
									<token name="Material">288</token>
									<string name="MaterialVariantSerialized"></string>
									<string name="Name">Theme</string>
									<CoordinateFrame name="PivotOffset">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
										<R00>1</R00>
										<R01>0</R01>
										<R02>0</R02>
										<R10>0</R10>
										<R11>1</R11>
										<R12>0</R12>
										<R20>0</R20>
										<R21>0</R21>
										<R22>1</R22>
									</CoordinateFrame>
									<float name="Reflectance">0</float>
									<float name="RightParamA">-0.5</float>
									<float name="RightParamB">0.5</float>
									<token name="RightSurface">0</token>
									<token name="RightSurfaceInput">0</token>
									<int name="RootPriority">0</int>
									<Vector3 name="RotVelocity">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<float name="TopParamA">-0.5</float>
									<float name="TopParamB">0.5</float>
									<token name="TopSurface">0</token>
									<token name="TopSurfaceInput">0</token>
									<float name="Transparency">0</float>
									<Vector3 name="Velocity">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<token name="formFactorRaw">1</token>
									<token name="shape">0</token>
									<Vector3 name="size">
										<X>2</X>
										<Y>2</Y>
										<Z>2</Z>
									</Vector3>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXA879DBF2C86247589AA809313FE54169">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">StarterPack</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Tool" referent="RBX161B49F8933A447C83D21654128F66AC">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="CanBeDropped">false</bool>
						<bool name="Enabled">false</bool>
						<CoordinateFrame name="Grip">
							<X>0</X>
							<Y>0</Y>
							<Z>-1.5</Z>
							<R00>0</R00>
							<R01>0</R01>
							<R02>-1</R02>
							<R10>-1</R10>
							<R11>0</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>1</R21>
							<R22>0</R22>
						</CoordinateFrame>
						<bool name="ManualActivationOnly">true</bool>
						<string name="Name">Sword</string>
						<bool name="RequiresHandle">true</bool>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<Content name="TextureId"><url>rbxasset://Textures/Sword128.png</url></Content>
						<string name="ToolTip">Sword</string>
					</Properties>
					<Item class="RemoteEvent" referent="RBXF4F50A1717BE4CE4A40EA67E3DF3490C">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Grip</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX5042944B9D934108AC1C421A511FB1B7">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SwordModule</string>
							<string name="ScriptGuid">{CC71DFB7-A67F-48DD-A654-DB9223611B28}</string>
							<ProtectedString name="Source"><![CDATA[local Sword = {}
local Aesthetics = require(_G.BB.Modules:WaitForChild("Aesthetics"))

function Sword:PositionLunge(tool)
	Aesthetics:ToggleSwordTrail(tool.Handle,true)
	tool.GripForward = Vector3.new(0, 0, 1);
	tool.GripRight = Vector3.new(0, -1, 0);
	tool.GripUp = Vector3.new(-1, 0, 0);
	--tool.GripForward = Vector3.new(0,1,0)
	--tool.GripRight = Vector3.new(0,0,-1)
	--tool.GripUp = Vector3.new(1,0,0)
end

function Sword:PositionIdle(tool)
	Aesthetics:ToggleSwordTrail(tool.Handle)
	tool.GripForward = Vector3.new(-1 ,0 ,0);
	tool.GripRight = Vector3.new(0, 1, 0);
	tool.GripUp = Vector3.new(0, 0, 1);
	--tool.GripForward = Vector3.new(1,0,0)
	--tool.GripRight = Vector3.new(0,0,1)
	--tool.GripUp = Vector3.new(0,1,0)
end

function Sword:CheckJoint(Character,Handle)
	local Humanoid = Character:FindFirstChild("Humanoid")
	if not Humanoid then
		return false
	end
	local ArmOption1 = Character:FindFirstChild("Right Arm")
	local ArmOption2 = Character:FindFirstChild("RightHand")

	local Arm = Humanoid.RigType == Enum.HumanoidRigType.R6 and ArmOption1 or ArmOption2
	if not Arm then
		return false
	end
	local Joint = Arm:FindFirstChild("RightGrip")
	if not Joint then
		return false
	end
	if not (Joint.Part0 == Handle or Joint.Part1 == Handle) then
		return false
	end
	return true
end


return Sword
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBXE9DA5AD075DC4E3DA113F173AB610C2F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Client</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX42517E79C1654322B26F860D38041720">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">SwordClient</string>
								<string name="ScriptGuid">{84C76696-2076-4454-880F-D6A9DBDFE272}</string>
								<ProtectedString name="Source"><![CDATA[local Sword = {}

local tool = script.Parent.Parent
local UserInput = game:GetService("UserInputService")
local Collections = game:GetService("CollectionService")

local currentState = "Up"

local function createToolAnim(animName)
	local toolAnim = Instance.new("StringValue")
	toolAnim.Name = ("toolanim")
	toolAnim.Value = animName
	Collections:AddTag(toolAnim,"SwordObject")
	toolAnim.Parent = tool
end

local function createClientSound(Name, handle)
	local Sound = handle:WaitForChild(Name)

	local NewSound = Sound:Clone()
	NewSound.Name = "Client"..NewSound.Name 
	NewSound.Parent = handle
	Sound:Destroy()

	return NewSound
end



function Sword:Lunge()
	local FloatAmount = _G.BB.Settings.Sword.FloatAmount
	local JumpHeight = _G.BB.Settings.Sword.JumpHeight
	local LungeDelayTime = _G.BB.Settings.Sword.LungeDelayTime
	local LungeExtensionTime = _G.BB.Settings.Sword.LungeExtensionTime
	
	createToolAnim("Lunge")
	
	local root = self.Character:FindFirstChild("HumanoidRootPart")
	local isHoldingSpace = game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.Space)
	local isInAir = self.Humanoid.FloorMaterial == Enum.Material.Air
	
	if root and (isInAir or isHoldingSpace) and (FloatAmount > 0) then
		
		--Once upon a time the sword Handle had a mass, making the character mass 14.84.
		--Everyone defined their FloatAmount based on this mass value for the player.
		--We fixed the sword having a mass, but this means characters now weigh 12.6 units.
		--This correctionFactor makes it so people who override the floatAmount won't see a change in sword force when this is pushed.
		local correctionFactor = 12.6 / 14.84
		
		local lungeForce = Instance.new("BodyVelocity")
		lungeForce.Velocity = Vector3.new(0, JumpHeight, 0)
		lungeForce.MaxForce = Vector3.new(0, FloatAmount * correctionFactor, 0)
		lungeForce.Name = "LungeForce"
		
		Collections:AddTag(lungeForce, "SwordObject")
		
		lungeForce.Parent = root
		
		game:GetService("Debris"):AddItem(lungeForce, .5)
	end
	
	if LungeDelayTime > 0 then
		--task.wait(LungeDelayTime)
		SafeWait.wait(LungeDelayTime)
	end
	
	self.lungeSound:Play()	
	
	-- since input is delayed by .1 seconds to replicate classic feel, fire to the server ahead of time 
	self.GripEvent:FireServer("Out")

	-- client only animations
	currentState = ("Out")
	self.SwordModule:PositionLunge(tool)
	
	--task.wait(LungeExtensionTime)
	SafeWait.wait(LungeExtensionTime)
	
	currentState = ("Up")
	self.SwordModule:PositionIdle(tool)
	self.GripEvent:FireServer("Up")
end

function Sword:Slash()
	self.slashSound:Play()	
	currentState = ("Attack")
	createToolAnim("Slash")
	self.GripEvent:FireServer("Down")
end

function Sword:Init()
	local Player = game:GetService("Players").LocalPlayer
	local Character = Player.Character
	
	self.Character = Character
	self.Humanoid = Character:WaitForChild("Humanoid")
	
	tool:WaitForChild("Handle")
	self.GripEvent = tool:WaitForChild("Grip")
	self.SwordModule = require(tool:WaitForChild("SwordModule"))

	local HandleCrosshair = require(_G.BB.ClientObjects:WaitForChild("HandleCrosshair"))
	local Kill = require(_G.BB.Modules:WaitForChild("Kill"))
	local PSPV = require(_G.BB.Modules.Security:WaitForChild("PSPV"))
	SafeWait = require(_G.BB.Modules.Security:WaitForChild("SafeWait"))
	local Aesthetics = require(_G.BB.Modules:WaitForChild("Aesthetics"))

	local handle = tool:WaitForChild("Handle")
	local Activation = tool:WaitForChild("Activation")
	local Damage = tool:WaitForChild("Damage")
	
	local IsTrueMobile = UserInput.TouchEnabled and not UserInput.MouseEnabled
	local lastInput = -1
	local equipped = false

	HandleCrosshair(tool)
	Aesthetics:HandleSword(Player, handle)

	self.equipSound = createClientSound("Equip", handle)
	self.slashSound = createClientSound("Slash", handle)
	self.lungeSound = createClientSound("Lunge", handle)
	
	local function Activate()
		if not tool.Enabled or not equipped then 
			return
		end
		
		tool.Enabled = false
		
		local now = tick()
		if now - lastInput < _G.BB.Settings.Sword.DoubleClickTime then
			self:Lunge()
		else
			self:Slash()
		end
		
		lastInput = now
		
		task.wait(_G.BB.Settings.Sword.ReloadTime)
		
		tool.Enabled = true
	end
	
	Activation.Event:Connect(Activate)
	
	local mobileDoubleTapTime = 0.2
	local last = -10
	
	local function ActivateJump()
		local now = tick()

		if _G.BB.TrueMobile and _G.BB.Local.MobileJump then
						
			if now - last < mobileDoubleTapTime then
				Activate()
			end
			
			last = now
		end
	end
	
	
	if _G.BB.TrueMobile and _G.BB.Settings.Mobile.DoubleJumpToSwordLunge  
		and _G.BB.Local.MobileJump then
		UserInput.JumpRequest:Connect(ActivateJump)
	end
	
	tool:GetPropertyChangedSignal("GripPos"):Connect(function()
		if currentState == ("Out") then
			self.SwordModule:PositionLunge(tool)
		else
			self.SwordModule:PositionIdle(tool)
		end
	end)
	
	-- sword equip sound client:
	tool.Equipped:Connect(function()
		equipped = true
		--if not _G.BB.TrueMobile then
		--	equipSound.TimePosition = 0.1
		--end
		self.equipSound:Play()		
	end)
	
	tool.Unequipped:Connect(function()
		equipped = false
	end)
	
	handle.Touched:Connect(function(hit)
		if hit.Parent then
			
			-- Don't damage if hit is HRP, commonly manipulated by
			-- exploiters.
			if hit.Name == "HumanoidRootPart" then 
				return 
			end
			
			local hitHumanoid = hit.Parent:FindFirstChildWhichIsA("Humanoid")
			local hitPlayer = hitHumanoid and game.Players:GetPlayerFromCharacter(hitHumanoid.Parent)

			if hitHumanoid 
				and Kill:CanDamage(Player, hitHumanoid, false) 
				and self.SwordModule:CheckJoint(Character, handle) then
					
				-- Gather security data, will return nil if Security is off
				local Source = hitPlayer and hitPlayer or hitHumanoid
				local HitCharacterData = PSPV:CreateCharFrameTables(Source)
				local LocalCharacterData = PSPV:CreateCharFrameTables(Player)
				
				-- Send data to server (no debounce, stay true to old RBLX)
				Damage:FireServer(
					hit,
					HitCharacterData,
					LocalCharacterData
				)
			end
		end
	end)
end

return Sword]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX9D2039E050994BDF8DC32483C5B0A93D">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Server</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX65CBC135727043EFB97FFB63B3D1BB8B">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">SwordServer</string>
								<string name="ScriptGuid">{16C86D95-CEA4-444F-BF12-62B5BEECE93A}</string>
								<ProtectedString name="Source"><![CDATA[local Sword = {}

local players = game:GetService("Players")
local tool = script.Parent.Parent

local state = "Up"
local canDamage = true

function Sword:Damage(hitHumanoid)
	-- Find Character and Player
	local hitCharacter = hitHumanoid.Parent;
	local hitPlayer = players:GetPlayerFromCharacter(hitCharacter);
	
	if hitCharacter ~= nil then
		-- Find torsos
		local hitTorso = hitCharacter:FindFirstChild("HumanoidRootPart");
		local localTorso = self.Character:FindFirstChild("HumanoidRootPart");

		if hitTorso and localTorso then
			-- Make sure user is within reasonable distance.
			local mag = (hitTorso.Position - localTorso.Position).Magnitude;
			
			if mag < self.MaxKillDistance then
				-- if they're a player, do tk check
				if self.Kill:CanDamage(self.Player,hitHumanoid) 
					and (self.SwordModule:CheckJoint(self.Character, self.handle)) then
					
					-- Tag player
					self.Kill:TagHumanoid(self.Player,hitHumanoid, self.handle, "Sword");

					-- Decide damage
					local Damage = self.Damages[state]
					
					--print(self.Player,"is damaging",hitCharacter)
					
					-- Deal damage
					hitHumanoid:TakeDamage(Damage)
				end				
			end
		end
	end
end

function Sword:Init(Settings,Modules,Buffers,Player,Character)
	self.Player = Player
	self.Character = Character
	self.Humanoid = Character:WaitForChild("Humanoid")
	
	self.MaxKillDistance = Settings.Security.Hit.MaxSwordKillDistance
	self.Ties = Settings.WeaponDamageAfterDeath
	self.Damages = {
		Out = Settings.Sword.LungeDamage,
		Down = Settings.Sword.SlashDamage,
		Up  = Settings.Sword.IdleDamage
	} 
	
	self.Kill = require(Modules:WaitForChild("Kill"))
	
	self.handle = tool:WaitForChild("Handle")
	self.SwordModule = require(tool:WaitForChild("SwordModule"))

	local Damage = tool:WaitForChild("Damage")

	local equipSound = self.handle:WaitForChild("Equip")
	local slashSound = self.handle:WaitForChild("Slash")
	local lungeSound = self.handle:WaitForChild("Lunge")

	local gripEvent = tool:WaitForChild("Grip")
	
	local PSPV = require(Modules.Security:WaitForChild("PSPV"))
	local Security = require(Modules:WaitForChild("Security"))
	local Aesthetics = require(Modules.Aesthetics)
	
	Aesthetics:HandleSword(Player, self.handle, true)
	
	local Primary
	Primary = Damage.OnServerEvent:Connect(function(playerFired,hit,CharacterData,LocalCFrames)
		
		if playerFired~=Player then
			return
		end
		
		if hit and hit.Parent and hit.Parent:IsDescendantOf(workspace)  then
			
			if hit.Name == "HumanoidRootPart" 
				or Character:FindFirstChildWhichIsA("ForceField") then 
				return 
			end
			
			local hitHumanoid = hit.Parent:FindFirstChildWhichIsA("Humanoid");
			local HitPlayer = players:GetPlayerFromCharacter(hit.Parent)
			
			if hitHumanoid then
				
				local Alive = self.Character.Humanoid.Health>0
				local TrueHit = not HitPlayer or not Settings.Security.PSPV or not Settings.Security.Master
				
				if Settings.Security.Master then
					local SwordCFrames = {LocalCFrames[1][2].Sword,LocalCFrames[2][2].Sword,LocalCFrames[3][2].Sword}
					local size = self.handle.Size -- Vector3.new(.2,.2,.2)
					if HitPlayer then
						
						TrueHit = PSPV:Verify(
							CharacterData, 
							SwordCFrames, -- hmmm...
							size, 
							Enum.PartType.Block, 
							HitPlayer.Name,
							nil,
							true
						)
						
						if not TrueHit then
							warn("PSPV failed for sword hit, hit plr:",
								HitPlayer,"Sword owner:",
								Player,
								"Hit:",hit.Name)
							
							canDamage = false
							
							Primary:Disconnect()
							
							return
						end

						for _, sCF in pairs(SwordCFrames) do
							
							local CurrentPosition = Vector2.new(self.handle.Position.X, self.handle.Position.Z)
							
							local SentPosition = Vector2.new(sCF.Position.X, sCF.Position.Z)
							local Mag = (SentPosition-CurrentPosition).Magnitude
							
							if Mag > 9 then
								TrueHit = false
								warn(
									"High 2D distance for sword hit, hit plr:", HitPlayer,
									"Sword owner:", Player,
									"Hit:", hit.Name,
									"Mag:", Mag
								)
							end
						end
					end
					
					Security:ApproveHandlePositions(Player, LocalCFrames)
					Security:ApproveFuturePositions(Player, LocalCFrames)
				end
				
				if TrueHit and canDamage then
					self:Damage(hitHumanoid);
				end
			end
		end
	end)
	
	gripEvent.OnServerEvent:Connect(function(plr, gripType)
		if Player == plr then
			
			-- replicate state
			state = gripType
			
			if gripType == "Out" then
				lungeSound:Play()
				self.SwordModule:PositionLunge(tool)
				
			elseif gripType == "Down" then
				slashSound:Play()
				
			elseif gripType == "Up" then
				self.SwordModule:PositionIdle(tool)
			end
		end
	end)
	
	-- sword equip sound server:
	tool.Equipped:Connect(function()
		equipSound:Play()	
	end)
	
	tool.Enabled = true
end

return Sword]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="BindableEvent" referent="RBXD631BE3C10F748779B9A996F96D3B141">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Activation</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBXC3D6449E3E59465398FEAE88A4DE647B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Damage</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Part" referent="RBXFD342C19B92B4E5A8C082C426CA6036C">
						<Properties>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-260.254883</X>
								<Y>6.35914135</Y>
								<Z>-206.326324</Z>
								<R00>-0.99999994</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>0</R11>
								<R12>-1</R12>
								<R20>0</R20>
								<R21>-0.99999994</R21>
								<R22>0</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<bool name="CastShadow">true</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4284702562</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">true</bool>
							<token name="Material">256</token>
							<string name="MaterialVariantSerialized"></string>
							<string name="Name">Handle</string>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0.400000006</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>0.800000012</Y>
								<Z>4</Z>
							</Vector3>
						</Properties>
						<Item class="SpecialMesh" referent="RBX6A44B0C0075F41C791AF6F8471D1588F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<token name="LODX">2</token>
								<token name="LODY">2</token>
								<Content name="MeshId"><url>rbxasset://fonts/sword.mesh</url></Content>
								<token name="MeshType">5</token>
								<string name="Name">Mesh</string>
								<Vector3 name="Offset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="Scale">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<Content name="TextureId"><url>rbxasset://textures/SwordTexture.png</url></Content>
								<Vector3 name="VertexColor">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="ObjectValue" referent="RBX95F43FCAB40347878DC715BA6AF17FE6">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">creator</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<Ref name="Value">null</Ref>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX838278E9A995488C9B1F6C446D5ED2E7">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<float name="EmitterSize">10</float>
								<NumberRange name="LoopRegion">0 60000 </NumberRange>
								<bool name="Looped">false</bool>
								<string name="Name">Slash</string>
								<bool name="PlayOnRemove">false</bool>
								<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
								<bool name="PlaybackRegionsEnabled">false</bool>
								<float name="PlaybackSpeed">1</float>
								<bool name="Playing">false</bool>
								<token name="RollOffMode">0</token>
								<Ref name="SoundGroup">null</Ref>
								<Content name="SoundId"><url>rbxasset://sounds/swordslash.wav</url></Content>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<double name="TimePosition">0</double>
								<float name="Volume">0.200000003</float>
								<float name="xmlRead_MaxDistance_3">10000</float>
							</Properties>
						</Item>
						<Item class="Attachment" referent="RBX0276CE6FF0C44604BEBEF69154BDF27F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>0</X>
									<Y>0</Y>
									<Z>-0.719997406</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<string name="Name">A0</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
						<Item class="Attachment" referent="RBXB4C9DE8135084A75B06D2AC346A0BA97">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>0</X>
									<Y>0</Y>
									<Z>2.4000001</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<string name="Name">A1</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
						<Item class="Attachment" referent="RBX311DC81F4F4945129C3ED8B4FD3D3EE1">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>0</X>
									<Y>0</Y>
									<Z>0.680000305</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<string name="Name">A3</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<bool name="Visible">false</bool>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX44805E2934B84C489A8B6A6A2E0B06E5">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<float name="EmitterSize">10</float>
								<NumberRange name="LoopRegion">0 60000 </NumberRange>
								<bool name="Looped">false</bool>
								<string name="Name">Lunge</string>
								<bool name="PlayOnRemove">false</bool>
								<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
								<bool name="PlaybackRegionsEnabled">false</bool>
								<float name="PlaybackSpeed">1</float>
								<bool name="Playing">false</bool>
								<token name="RollOffMode">0</token>
								<Ref name="SoundGroup">null</Ref>
								<Content name="SoundId"><url>rbxasset://sounds/swordlunge.wav</url></Content>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<double name="TimePosition">0</double>
								<float name="Volume">0.600000024</float>
								<float name="xmlRead_MaxDistance_3">10000</float>
							</Properties>
							<Item class="EqualizerSoundEffect" referent="RBXCC362DEB233C478CB1DA751F5F631F1D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="Enabled">true</bool>
									<float name="HighGain">0</float>
									<float name="LowGain">-2</float>
									<float name="MidGain">-7.5</float>
									<string name="Name">EqualizerSoundEffect</string>
									<int name="Priority">0</int>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Sound" referent="RBXD5840C5124534920B4A349AE9640EA7A">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<float name="EmitterSize">10</float>
								<NumberRange name="LoopRegion">0 60000 </NumberRange>
								<bool name="Looped">false</bool>
								<string name="Name">Equip</string>
								<bool name="PlayOnRemove">false</bool>
								<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
								<bool name="PlaybackRegionsEnabled">false</bool>
								<float name="PlaybackSpeed">1</float>
								<bool name="Playing">false</bool>
								<token name="RollOffMode">0</token>
								<Ref name="SoundGroup">null</Ref>
								<Content name="SoundId"><url>http://www.roblox.com/asset/?id=12222225</url></Content>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<double name="TimePosition">0</double>
								<float name="Volume">0.5</float>
								<float name="xmlRead_MaxDistance_3">10000</float>
							</Properties>
							<Item class="EqualizerSoundEffect" referent="RBX135767CCF19F41748FA4E15A87EF1C36">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="Enabled">true</bool>
									<float name="HighGain">-5</float>
									<float name="LowGain">0</float>
									<float name="MidGain">-5</float>
									<string name="Name">EqualizerSoundEffect</string>
									<int name="Priority">0</int>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Tool" referent="RBX60AE1297D70E421D908C330EA093535A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="CanBeDropped">false</bool>
						<bool name="Enabled">true</bool>
						<CoordinateFrame name="Grip">
							<X>0</X>
							<Y>-0.699999988</Y>
							<Z>-0.0199999698</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="ManualActivationOnly">true</bool>
						<string name="Name">Slingshot</string>
						<bool name="RequiresHandle">true</bool>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<Content name="TextureId"><url>rbxasset://Textures/Slingshot.png</url></Content>
						<string name="ToolTip">Sling</string>
					</Properties>
					<Item class="Part" referent="RBX471FEED586284AADA90DB7AB6878BC10">
						<Properties>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">4</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-253.131851</X>
								<Y>24.4894829</Y>
								<Z>-46.2263412</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">false</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<bool name="CastShadow">false</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">true</bool>
							<token name="Material">256</token>
							<string name="MaterialVariantSerialized"></string>
							<string name="Name">Handle</string>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">3</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>2</X>
								<Y>5</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
						<Item class="SpecialMesh" referent="RBX9405BDF0AC0F4C1B8F66A096855D4D7A">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<token name="LODX">2</token>
								<token name="LODY">2</token>
								<Content name="MeshId"><url>rbxasset://fonts/slingshot.mesh</url></Content>
								<token name="MeshType">5</token>
								<string name="Name">Mesh</string>
								<Vector3 name="Offset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="Scale">
									<X>0.5</X>
									<Y>0.5</Y>
									<Z>0.5</Z>
								</Vector3>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<Content name="TextureId"><url>http://www.roblox.com/asset/?id=5320847360</url></Content>
								<Vector3 name="VertexColor">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX37D5EBE49BEE44E1A07F010636A73B74">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">SlingshotSounds</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Sound" referent="RBX754AB2396BB94665993DE92B98C922A1">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="EmitterSize">10</float>
									<NumberRange name="LoopRegion">0 60000 </NumberRange>
									<bool name="Looped">false</bool>
									<string name="Name">Classic</string>
									<bool name="PlayOnRemove">false</bool>
									<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
									<bool name="PlaybackRegionsEnabled">false</bool>
									<float name="PlaybackSpeed">1</float>
									<bool name="Playing">false</bool>
									<token name="RollOffMode">0</token>
									<Ref name="SoundGroup">null</Ref>
									<Content name="SoundId"><url>rbxassetid://844029237</url></Content>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="TimePosition">0</double>
									<float name="Volume">0.699999988</float>
									<float name="xmlRead_MaxDistance_3">10000</float>
								</Properties>
							</Item>
							<Item class="Sound" referent="RBX1B842CB6A3B94B9298F4A9D0843E2819">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="EmitterSize">10</float>
									<NumberRange name="LoopRegion">0 60000 </NumberRange>
									<bool name="Looped">false</bool>
									<string name="Name">Modern</string>
									<bool name="PlayOnRemove">false</bool>
									<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
									<bool name="PlaybackRegionsEnabled">false</bool>
									<float name="PlaybackSpeed">1.20000005</float>
									<bool name="Playing">false</bool>
									<token name="RollOffMode">0</token>
									<Ref name="SoundGroup">null</Ref>
									<Content name="SoundId"><url>http://www.roblox.com/asset/?id=94795238</url></Content>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="TimePosition">0</double>
									<float name="Volume">2</float>
									<float name="xmlRead_MaxDistance_3">10000</float>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="RemoteEvent" referent="RBX17DAB16843C04AEAB34804040354624B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Update</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBX61C0FC0347E54CF78BA9A74284348DF9">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Client</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXB64F34B673AE4759A00311C5D675FF9E">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">SlingshotClient</string>
								<string name="ScriptGuid">{0CA69765-E45C-461E-B5B1-D74B1B7DE5C7}</string>
								<ProtectedString name="Source"><![CDATA[local Slingshot = {}

local tool = script.Parent.Parent


local spawnDistances = {
	Flying = 4,
	Climbing = 8.5,
}

local ADDED_Y_VEL = 0.3

function Slingshot:ComputeLaunchAngle(dx, dy, grav, speed)
	local Gravity = workspace.Gravity--math.abs(workspace.Gravity)

	local SqSpeed = speed ^ 2

	local inRoot = (SqSpeed ^ 2) - (Gravity * ((Gravity * (dx^2)) + (2 * dy * SqSpeed)))

	if inRoot <= 0 then
		return -1
	end

	local root = math.sqrt(inRoot)

	local GravDist = Gravity * dx

	local inATan1 = (SqSpeed + root) / GravDist
	local inATan2 = (SqSpeed - root) / GravDist

	local answer1 = math.atan(inATan1)
	local answer2 = math.atan(inATan2)

	if answer1 < answer2 then 
		return answer1 
	end

	return answer2
end

function Slingshot:Fire(Hit, mouse_pos, pellet, count, collisionGroup, now)
	local dir = (mouse_pos - self.Character.PrimaryPart.Position).Unit
	local spawnDistance = _G.BB.Settings.SlingClimb and 6 or _G.BB.Settings.Slingshot.SpawnDistance
	local Speed = _G.BB.Settings.Slingshot.Speed
	local ShootInsideBricks = _G.BB.Settings.Slingshot.ShootInsideBricks
		
	if collisionGroup ~= "Standard" then
		spawnDistance = spawnDistances[collisionGroup]
	end
	
	local launch = self.Character.PrimaryPart.Position + dir * spawnDistance
	local delta = mouse_pos - launch
	local unit_delta = delta.Unit
	
	local dir = unit_delta
	
	if workspace.Gravity > 0 then
		local dy = delta.Y

		delta = Vector3.new(delta.X, 0, delta.Z)

		local dx = delta.Magnitude
		unit_delta = delta.Unit

		local theta = self:ComputeLaunchAngle(dx, dy, workspace.Gravity, Speed)
		
		if theta == -1 then
			dir = (mouse_pos - self.Character.PrimaryPart.Position).Unit
			dir = Vector3.new(dir.X, dir.Y + ADDED_Y_VEL, dir.Z)
		else
			local vy = math.sin(theta)
			local xz = math.cos(theta)
			local vx = unit_delta.X * xz
			local vz = unit_delta.Z * xz
			dir = Vector3.new(vx, vy, vz)
		end
	end
	
	local vel = dir * Speed
	pellet.Position = launch
	pellet.Velocity = vel
	pellet.Parent = self.ActiveFolder
	
	if (ShootInsideBricks == false) and self.isInsideSomething(pellet) then
		local pPartPos = self.Character.PrimaryPart.Position
		local clampedDist = math.clamp((mouse_pos - pPartPos).Magnitude, 0, spawnDistance)
		local pelletDir = (mouse_pos - pPartPos).Unit

		local camDir = workspace.CurrentCamera.CFrame.LookVector
		local finalPos = pPartPos + pelletDir * clampedDist - camDir * 1
		local pelletLook = pellet.CFrame.LookVector
		local cFrame = CFrame.lookAt(finalPos, finalPos + pelletLook)

		pellet.Anchored = true
		pellet.CFrame = cFrame
		pellet.Velocity = pelletLook * Speed
		pellet.Anchored = false

		if self.isInsideSomething(pellet, true) then
			pellet.Anchored = true
			pellet.CFrame = CFrame.lookAt(pPartPos, pPartPos + pelletLook)
			pellet.Velocity = pelletLook * Speed
			pellet.Anchored = false
		end
	end
	
	self.Delete(pellet, 4)
	
	self.Hit:HandleHitDetection(pellet)
	
	return pellet.Position, vel
end

local function touchingMiscPart(character, sourcePart)
	local TC = sourcePart.Touched:Connect(function() end)
	local CollectedParts = sourcePart:GetTouchingParts()
	TC:Disconnect()
	local TouchingMiscPart = false
	for _, Part in pairs(CollectedParts) do
		if not character:IsAncestorOf(Part) then
			TouchingMiscPart = true
			break
		end
	end
	return TouchingMiscPart
end

function Slingshot:Init()
	local Player = game:GetService("Players").LocalPlayer
	local Character = Player.Character
	local Mouse = Player:GetMouse()
	
	self.Hit = require(_G.BB.Modules:WaitForChild("Hit"))
	self.Delete = require(_G.BB.ClientObjects:WaitForChild("Delete"))
	self.ActiveFolder = workspace:WaitForChild("Projectiles"):WaitForChild("Active"):WaitForChild(Player.Name)

	local MakePellet = require(_G.BB.ClientObjects:WaitForChild("MakePellet"))
	local Targeting = require(_G.BB.ClientObjects:WaitForChild("Core"):WaitForChild("Targeting"))

	local SafeWait = require(_G.BB.Modules.Security:WaitForChild("SafeWait"))
	
	self.isInsideSomething = require(_G.BB.ClientObjects:WaitForChild("isInsideSomething"))
	local Security = require(_G.BB.Modules:WaitForChild("Security"))
	
	local handle = tool:WaitForChild("Handle")
	local Activation = tool:WaitForChild("Activation")
	local UpdateEvent = tool:WaitForChild("Update")
	local slingshotSounds = tool.Handle:WaitForChild("SlingshotSounds")
	local NewSounds  = slingshotSounds:Clone()
	NewSounds.Name = "ClientSounds"
	NewSounds.Parent = handle
	slingshotSounds:Destroy()
	
	local HandleCrosshair = require(_G.BB.ClientObjects:WaitForChild("HandleCrosshair"))
	HandleCrosshair(tool)
	
	self.Character = Character

	local down = false
	local jumpyDeltaTime = _G.BB.Settings.Slingshot.SlingFlyCooldown
	local jumpyT0 = time()

	local function Activate(Hit,targetPos)
		if not Security:ApproveActivation(Player, "Slingshot") then
			return
		end
		tool.Enabled = false
		
		local now = time()

		local CollisionGroup = _G.BB.Settings.Doomspire.SlingFly and "JumpyPellets" or "Pellets"

		local isHoldingSpace = game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.Space)
		local isJumping = (Character.Humanoid.FloorMaterial == Enum.Material.Air or isHoldingSpace)
		
		local mode = "Standard"
		
		-- Set mode (Standard, Climbing, or Flying)
		if handle then
			
			if _G.BB.Settings.SlingClimb or _G.BB.Settings.Doomspire.SlingFly then
				
				local TouchingMiscPart = touchingMiscPart(Character, handle)
				CollisionGroup = (TouchingMiscPart and isJumping) and "JumpyPellets" or "Pellets"
				
				if TouchingMiscPart then
					
					mode = "Climbing"
					jumpyT0 = now
					
				elseif _G.BB.Settings.Doomspire.SlingFly  then
					
					if ((now - jumpyT0) > jumpyDeltaTime) and isJumping then
						mode = "Flying"
						CollisionGroup = "JumpyPellets"
						jumpyT0 = now
					end
				end
			end
		end

		_G.BB.ProjectileCounts.Pellets += 1
		local count = _G.BB.ProjectileCounts.Pellets
		
		local Pellet = MakePellet(Player, CollisionGroup, count)
		
		local position, velocity = self:Fire(Hit, targetPos, Pellet, count, mode, now)
		UpdateEvent:FireServer(position, velocity, now, count, _G.BB.ServerTime.Value)	

		local Sound = NewSounds:FindFirstChild(_G.BB.Local.SlingshotSound)
		Sound.Parent = handle
		Sound:Play()
		Sound.Parent = NewSounds
		
		SafeWait.wait(_G.BB.Settings.Slingshot.ReloadTime)
		
		tool.Enabled = true
		
		return true
	end
	
	--This exception attempts to turn off automatic sling for mobile users, as it's nonfunctional and causes issues on the side.
	if not (game:GetService("UserInputService").MouseEnabled) and
		not (game:GetService("UserInputService").KeyboardEnabled) and
		game:GetService("UserInputService").TouchEnabled then
		_G.BB.Settings.Slingshot.Automatic = false
		warn("Your device was recognized as mobile and Slingshot Automatic fire was deactivated.")
		warn("If your device is not mobile, contact a developer to report the issue.")
	end
	
	local Thread = 0
	Activation.Event:Connect(function(Hit,targetPos)
		if tool.Enabled then
			if _G.BB.Settings.Slingshot.Automatic and not down then
				Thread = Thread + 1
				local CurrentThread = Thread
				down = true
				while down and CurrentThread == Thread do
					local Hit, TargetPosition = Targeting:Get3DPosition(Mouse.X, Mouse.Y, false)
					if not Activate(Hit,TargetPosition) then
						SafeWait.wait(_G.BB.Settings.Slingshot.ReloadTime)
					end
				end
				down = false
			elseif not _G.BB.Settings.Slingshot.Automatic then
				Activate(Hit,targetPos)
			end
		end
	end)

	if _G.BB.Settings.Slingshot.Automatic then
		game:GetService("UserInputService").InputEnded:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 
				or input.UserInputType == Enum.UserInputType.Gamepad1
				or input.UserInputType == Enum.UserInputType.Touch
			then
				if input.UserInputType == Enum.UserInputType.Touch  then
					task.wait(1/15)
				end
				down = false
			end
		end)
		
		tool.AncestryChanged:Connect(function()
			if tool.Parent ~= Character then
				down = false
			end
		end)
	end
end

return Slingshot]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX6595EFC9A5124044960A7B0CBC6F37B2">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Server</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXC80AE83AE44A42E48C51A12F089F3702">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">SlingshotServer</string>
								<string name="ScriptGuid">{EE774499-24E2-4CDE-84C0-CA7A25ABEB38}</string>
								<ProtectedString name="Source"><![CDATA[local Slingshot = {}

local tool = script.Parent.Parent

local Debris = game:GetService("Debris")
local Collections = game:GetService("CollectionService")
local Physics = game:GetService("PhysicsService")

function Slingshot:CreatePhysicsFolder(count)
	local PhysicsFolder = Instance.new("Folder")
	
	--_G.BB.ProjectileCounts[self.Player.Name].Pellets += 1

	--PhysicsFolder.Name = "Slingshot".._G.BB.ProjectileCounts[self.Player.Name].Pellets
	PhysicsFolder.Name = "Slingshot"..count

	-- Add creator tag
	local new_tag = Instance.new("ObjectValue")
	new_tag.Name = "creator"
	new_tag.Value = self.Player
	new_tag.Parent = PhysicsFolder
	
	local Active = Instance.new("BoolValue")
	Active.Name = "Active"
	Active.Value = true
	Active.Parent = PhysicsFolder
	
	local ProjectileType = Instance.new("StringValue")
	ProjectileType.Name = "ProjectileType"
	ProjectileType.Value = "Slingshot"
	ProjectileType.Parent = PhysicsFolder
	
	local CanHalfDamageValue = Instance.new("BoolValue")
	CanHalfDamageValue.Name = "CanHalfDamage"
	CanHalfDamageValue.Value = true
	CanHalfDamageValue.Parent = PhysicsFolder
	
	local Damage = Instance.new("IntValue")
	Damage.Name = "Damage"
	Damage.Value = self.Settings.Slingshot.Damage
	Damage.Parent = PhysicsFolder;
	
	local ID = Instance.new("StringValue")
	ID.Name = "UniqueID"
	ID.Value = PhysicsFolder.Name.._G.BB.ProjectileCounts[self.Player.Name].Pellets
	ID.Parent = PhysicsFolder
	
	local lp = Instance.new("Vector3Value")
	lp.Name = "LatestPosition"
	lp.Parent = PhysicsFolder

	local lv = Instance.new("Vector3Value")
	lv.Name = "LatestVelocity"
	lv.Parent = PhysicsFolder
	
	local lt = Instance.new("NumberValue")
	lt.Name = "LatestTime"
	lt.Parent = PhysicsFolder

	local LastUpdateTick = Instance.new("NumberValue")
	LastUpdateTick.Name = "LastUpdateTick"
	LastUpdateTick.Parent = PhysicsFolder

	local ThemeTag = Instance.new("StringValue")
	ThemeTag.Name = "Theme"
	ThemeTag.Value = self.Aesthetics:DetermineTheme(self.Player)
	ThemeTag.Parent = PhysicsFolder
	
	self.slingshotSounds:Clone().Parent = PhysicsFolder
		
	--print(PhysicsFolder:GetFullName())
	return PhysicsFolder
end

function Slingshot:Init(Settings, Modules, Buffers, Player, Character, Folder)	
	local handle = tool:WaitForChild("Handle")
	local UpdateEvent = tool:WaitForChild("Update")
	
	self.slingshotSounds = handle:WaitForChild("SlingshotSounds")
	self.ActiveFolder = Folder:WaitForChild("Active"):WaitForChild(Player.Name)
	self.Aesthetics = require(Modules:WaitForChild("Aesthetics"))
	self.Settings = Settings
	self.Player = Player
	
	local ActiveFolder = Folder:WaitForChild("Active"):WaitForChild(Player.Name)
	
	local Security = require(Modules:WaitForChild("Security"))

	-- First activation must always work event if time() returns 0. 
	local lastActivation = -0.2;
	
	UpdateEvent.OnServerEvent:Connect(function(firingPlayer, initPos, initVel, initTime, count, seenServerTime)
		local now = time()
		local Head = firingPlayer.Character and firingPlayer.Character:FindFirstChild("Head")
		local LenientReloadTime = math.max(Settings.Slingshot.ReloadTime - 1, Settings.Slingshot.ReloadTime * .5)
		
		if Head and firingPlayer == Player and (now - lastActivation) > LenientReloadTime then
			if Player.Character and Player.Character.Parent and Player.Character:FindFirstChild("Humanoid") and Player.Character.Humanoid.Health > 0 then
				lastActivation = now
							
				local PhysicsFolder = self:CreatePhysicsFolder(count)
		
				
				-- Replicate projectile
				PhysicsFolder.LatestPosition.Value = initPos
				PhysicsFolder.LatestVelocity.Value = initVel
				PhysicsFolder.LatestTime.Value = initTime
				PhysicsFolder.LastUpdateTick.Value = now
				PhysicsFolder.Active.Value = true
				
				if Security:ApproveInit(PhysicsFolder) then
					PhysicsFolder.Parent = self.ActiveFolder
				end
				
				Debris:AddItem(PhysicsFolder ,Settings.Slingshot.DespawnTime)
			end
		end
	end)
	
	tool.Enabled = true
end

return Slingshot]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="BindableEvent" referent="RBXB4E42BD78D414C89BA1EE3DDB2E0F501">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Activation</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Tool" referent="RBX65839DEBE8144B8689F7DB4FFFB8D4A6">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="CanBeDropped">false</bool>
						<bool name="Enabled">false</bool>
						<CoordinateFrame name="Grip">
							<X>-0.579281926</X>
							<Y>-0.578147471</Y>
							<Z>0.0743034482</Z>
							<R00>-0.000734454254</R00>
							<R01>0.00874789804</R01>
							<R02>0.999961615</R02>
							<R10>-0.0213966556</R10>
							<R11>0.999732733</R11>
							<R12>-0.0087616127</R12>
							<R20>-0.99977088</R20>
							<R21>-0.0214022659</R21>
							<R22>-0.000547082222</R22>
						</CoordinateFrame>
						<bool name="ManualActivationOnly">true</bool>
						<string name="Name">Rocket</string>
						<bool name="RequiresHandle">true</bool>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<Content name="TextureId"><url>rbxasset://Textures/Rocket.png</url></Content>
						<string name="ToolTip">Rocket</string>
					</Properties>
					<Item class="MeshPart" referent="RBX9DEF2ECA241C429CBB36796E67C64102">
						<Properties>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-252.317307</X>
								<Y>24.1118279</Y>
								<Z>-46.8062439</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>0.999999762</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>0.999999762</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<bool name="CastShadow">true</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4285822067</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DoubleSided">false</bool>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<bool name="HasJointOffset">false</bool>
							<bool name="HasSkinnedMesh">false</bool>
							<Vector3 name="InitialSize">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<Vector3 name="JointOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="LODData"></BinaryString>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">true</bool>
							<token name="Material">1088</token>
							<string name="MaterialVariantSerialized"></string>
							<Content name="MeshId"><null></null></Content>
							<string name="Name">Handle</string>
							<SharedString name="PhysicalConfigData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
							<BinaryString name="PhysicsData"></BinaryString>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<token name="RenderFidelity">1</token>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<Content name="TextureID"><null></null></Content>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int name="VertexCount">0</int>
							<Vector3 name="size">
								<X>4.20199585</X>
								<Y>1.04170036</Y>
								<Z>0.820400238</Z>
							</Vector3>
						</Properties>
						<Item class="Sound" referent="RBX53C75E69BC74447AAD614E707219F5DF">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<float name="EmitterSize">10</float>
								<NumberRange name="LoopRegion">0 60000 </NumberRange>
								<bool name="Looped">true</bool>
								<string name="Name">Swoosh</string>
								<bool name="PlayOnRemove">false</bool>
								<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
								<bool name="PlaybackRegionsEnabled">false</bool>
								<float name="PlaybackSpeed">1</float>
								<bool name="Playing">false</bool>
								<token name="RollOffMode">0</token>
								<Ref name="SoundGroup">null</Ref>
								<Content name="SoundId"><url>rbxasset://sounds/Rocket whoosh 01.wav</url></Content>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<double name="TimePosition">0</double>
								<float name="Volume">0.699999988</float>
								<float name="xmlRead_MaxDistance_3">300</float>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX4D1A9DD9E22F414C99031604A12E87FE">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">Boom</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Sound" referent="RBX8FAB1988CA0444178117C54D752C350A">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="EmitterSize">10</float>
									<NumberRange name="LoopRegion">0 60000 </NumberRange>
									<bool name="Looped">false</bool>
									<string name="Name">Modern</string>
									<bool name="PlayOnRemove">false</bool>
									<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
									<bool name="PlaybackRegionsEnabled">false</bool>
									<float name="PlaybackSpeed">2</float>
									<bool name="Playing">false</bool>
									<token name="RollOffMode">0</token>
									<Ref name="SoundGroup">null</Ref>
									<Content name="SoundId"><url>rbxassetid://3149249837</url></Content>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="TimePosition">0</double>
									<float name="Volume">4</float>
									<float name="xmlRead_MaxDistance_3">10000</float>
								</Properties>
							</Item>
							<Item class="Sound" referent="RBXC91496F817D4420390AEF33801CD3205">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="EmitterSize">10</float>
									<NumberRange name="LoopRegion">0 60000 </NumberRange>
									<bool name="Looped">false</bool>
									<string name="Name">Classic</string>
									<bool name="PlayOnRemove">false</bool>
									<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
									<bool name="PlaybackRegionsEnabled">false</bool>
									<float name="PlaybackSpeed">1</float>
									<bool name="Playing">false</bool>
									<token name="RollOffMode">0</token>
									<Ref name="SoundGroup">null</Ref>
									<Content name="SoundId"><url>rbxasset://sounds/collide.wav</url></Content>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="TimePosition">0</double>
									<float name="Volume">1</float>
									<float name="xmlRead_MaxDistance_3">300</float>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="RemoteEvent" referent="RBX374FF16EE83E4ACA9B89FF2C575E7EE0">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Update</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBXD40AE7B0EED247C8BB66B703E043D21E">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Client</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX8A365AAD2AC74F7C84B243B4D2D9F753">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">RocketClient</string>
								<string name="ScriptGuid">{5D493028-B993-496F-B43A-C2B32C219159}</string>
								<ProtectedString name="Source"><![CDATA[local Rocket = {}

local tool = script.Parent.Parent
local Players = game:GetService("Players")
local Debris = game:GetService("Debris")
local Collections = game:GetService("CollectionService")

function Rocket:ProcessTouched(rocket)
	local TouchedConnection;
	local hasExploded = false
	local CharacterData
	
	local Diamater = _G.BB.Settings.Rocket.Radius * 2
	
	rocket.Ready.Value = true
	
	TouchedConnection = rocket.Touched:Connect(function(hit)
		local RocketPosition = rocket.Position

		local hitCharacter = hit.Parent:IsA("Model") and hit.Parent
		local hitHumanoid = hit.Parent:FindFirstChildWhichIsA("Humanoid")
		
		local hitPlr = hitCharacter and Players:GetPlayerFromCharacter(hitCharacter)
		if hitPlr == self.Player and (not self.Kill:CanDamage(self.Player, hitHumanoid, _G.BB.Settings.Doomspire.RocketCollisions)) then
			return
		end
		
		local CallbackModule = _G.BB.Modules.Callbacks.RocketExplode
		local Callback = CallbackModule and require(CallbackModule)
		if Callback and Callback(hit) == false then
			-- IF FALSE, ROCKET PASSES THROUGH
			return
		end
		
		if hasExploded then
			return
		end
		
		hasExploded = true
		rocket.Ready.Value = false
		rocket.Anchored = true
		
		TouchedConnection:Disconnect()
		
		-- Move rocket forward 2 studs
		rocket.CFrame = rocket.CFrame + (rocket.CFrame * Vector3.new(0, 0, -2)) - rocket.Position
		
		-- Get character positions at two frames
		if hitPlr then
			CharacterData = self.PSPV:CreateCharFrameTables(hitPlr)
		end
		
		--Debris:AddItem(rocket, 3)
		
		rocket.Size = Vector3.new(Diamater, Diamater, Diamater)
		
		local function CreateExpl()
			
			rocket.Swoosh:Destroy()
			
			-- client rocket explosion sound
			local Sounds = rocket:WaitForChild("Boom")
			local Sound = Sounds:FindFirstChild(_G.BB.Local.RocketExplosion)
			Sound.Parent = rocket
			Sound:Play()
			
			self.Aesthetics:CreateCustomExplosion(self.Player, rocket)
		end
		
		task.spawn(CreateExpl)
		self.Explosion:HandleHitDetection(rocket, hit, RocketPosition, CharacterData)
	end)
end

function Rocket:Fire(rocket, TargetPosition, SpawnDistance)
	local InitialSpeed = _G.BB.Settings.Rocket.InitialSpeed
	local Speed = _G.BB.Settings.Rocket.Speed
	local RampUpDuration = _G.BB.Settings.Rocket.RampUpDuration
	local ShootInsideBricks = _G.BB.Settings.Rocket.ShootInsideBricks
	
	local InitPosition = tool.Handle.Position + (TargetPosition - tool.Handle.Position).unit * SpawnDistance
	local InitialCFrame = CFrame.lookAt(InitPosition, TargetPosition)
	
	rocket.Origin.Value = InitialCFrame -- have to buffer this on the client
	rocket.LastSentPosition.Value = InitialCFrame.Position
	
	rocket.CFrame = InitialCFrame
	
	local initialVelocity = rocket.CFrame.LookVector *InitialSpeed
	local velocity = rocket.CFrame.LookVector * Speed

	rocket.Velocity = initialVelocity
	rocket.RocketVelocity.Velocity = velocity
	
	local force = (velocity - initialVelocity) * rocket:GetMass() / RampUpDuration
	force = Vector3.new(math.abs(force.X), math.abs(force.Y), math.abs(force.Z))
	rocket.RocketVelocity.MaxForce = force
	
	rocket.Parent = self.ActiveFolder

	if not ShootInsideBricks and self.isInsideSomething(rocket) then
		rocket.Anchored = true
		local Position = tool.Handle.Position
		local cFrame = CFrame.lookAt(Position, TargetPosition)
		rocket.CFrame = cFrame
		local initialVelocity = rocket.CFrame.LookVector * InitialSpeed
		local velocity = rocket.CFrame.LookVector * Speed

		rocket.Velocity = initialVelocity
		rocket.RocketVelocity.Velocity = velocity
		rocket.Anchored = false
	end
	
	game:GetService("Debris"):AddItem(rocket,9.5)
	rocket.Swoosh:Play()
	
	self:ProcessTouched(rocket)
	return rocket.CFrame
end

function Rocket:Init()
	
	local Player = Players.LocalPlayer
	self.Player = Player
	self.Character = self.Player.Character
	
	self.Kill = require(_G.BB.Modules:WaitForChild("Kill"))
	self.Aesthetics = require(_G.BB.Modules:WaitForChild("Aesthetics"))
	self.Explosion = require(_G.BB.Modules:WaitForChild("Explosion"))
	self.PSPV = require(_G.BB.Modules.Security:WaitForChild("PSPV"))	
	self.isInsideSomething = require(_G.BB.ClientObjects:WaitForChild("isInsideSomething"))

	local SafeWait = require(_G.BB.Modules.Security:WaitForChild("SafeWait"))

	self.ActiveFolder = workspace:WaitForChild("Projectiles"):WaitForChild("Active"):WaitForChild(Player.Name)
	
	local MakeRocket = require(_G.BB.ClientObjects:WaitForChild("MakeRocket"))

	self.handle = tool:WaitForChild("Handle")

	
	local Activation = tool:WaitForChild("Activation")
	local UpdateEvent = tool:WaitForChild("Update")
	local HandleCrosshair = require(_G.BB.ClientObjects:WaitForChild("HandleCrosshair"))

	HandleCrosshair(tool)
	
	Activation.Event:Connect(function(Hit, TargetPosition)
		if tool.Enabled then 
			tool.Enabled = false

			local SpawnDistance = _G.BB.Settings.Rocket.SpawnDistance

			_G.BB.ProjectileCounts.Rockets += 1

			local rocket = MakeRocket(self.Player, _G.BB.ProjectileCounts.Rockets)
			local cframe = self:Fire(rocket, TargetPosition, SpawnDistance, _G.BB.ProjectileCounts.Rockets)
			UpdateEvent:FireServer(cframe, _G.BB.ServerTime.Value, _G.BB.ProjectileCounts.Rockets)
			
			SafeWait.wait(_G.BB.Settings.Rocket.ReloadTime)

			tool.Enabled = true
		end
	end)
end

return Rocket]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX4FE70C8B8FA546A29614049CD1E36DA7">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Server</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX120A6211A5674A2793995EC4DE20CB75">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">RocketServer</string>
								<string name="ScriptGuid">{4E3E30F3-425B-419F-9844-1D4ACDA2EFA4}</string>
								<ProtectedString name="Source"><![CDATA[local Rocket = {}

local tool = script.Parent.Parent;
local handle = tool:WaitForChild("Handle")
local UpdateEvent = tool:WaitForChild("Update");
local boom = handle:WaitForChild("Boom");
local swoosh = handle:WaitForChild("Swoosh");

local Players = game:GetService("Players")
local Debris = game:GetService("Debris")
local Collections = game:GetService("CollectionService")

function Rocket:CreatePhysicsFolder(count)
	--_G.BB.ProjectileCounts[self.Player.Name].Rockets += 1

	local PhysicsFolder = Instance.new("Folder")
	--PhysicsFolder.Name = "Rocket".._G.BB.ProjectileCounts[self.Player.Name].Rockets
	PhysicsFolder.Name = "Rocket"..count
	
	local ThemeTag = Instance.new("StringValue")
	ThemeTag.Name = "Theme"
	ThemeTag.Value = self.Aesthetics:DetermineTheme(self.Player)
	ThemeTag.Parent = PhysicsFolder
	
	local newTag = Instance.new("ObjectValue")
	newTag.Name = "creator"
	newTag.Value = self.Player
	newTag.Parent = PhysicsFolder
	
	local Active = Instance.new("BoolValue");
	Active.Name = "Active"
	Active.Value = true
	Active.Parent = PhysicsFolder
	
	local Exploded = Instance.new("BoolValue")
	Exploded.Name = "Exploded"
	Exploded.Value = false
	Exploded.Parent = PhysicsFolder
	
	local projType = Instance.new("StringValue")
	projType.Name = "ProjectileType"
	projType.Value = "Rocket"
	projType.Parent = PhysicsFolder
	
	local LastUpdateTick = Instance.new("NumberValue")
	LastUpdateTick.Name = "LastUpdateTick"
	LastUpdateTick.Parent = PhysicsFolder
	
	local cf = Instance.new("CFrameValue")
	cf.Name = "Origin"
	cf.Parent = PhysicsFolder
	
	local rdist = Instance.new("NumberValue")
	rdist.Name = "LatestDistance"
	rdist.Parent = PhysicsFolder

	--local rvel = Instance.new("Vector3Value")
	--rvel.Name = "LatestVelocity"
	--rvel.Parent = PhysicsFolder
	
	local st = Instance.new("NumberValue")
	st.Name = "ClientTime"
	st.Parent = PhysicsFolder
	
	local mt = Instance.new("NumberValue")
	mt.Name = "ServerTime"
	mt.Parent = PhysicsFolder

	local ID = Instance.new("StringValue")
	ID.Name = "UniqueID"
	ID.Value = PhysicsFolder.Name.._G.BB.ProjectileCounts[self.Player.Name].Rockets
	ID.Parent = PhysicsFolder
	
	-- Add the "shoosh" and "boom"
	boom:Clone().Parent = PhysicsFolder
	swoosh:Clone().Parent = PhysicsFolder
	
	return PhysicsFolder
end

function Rocket:Init(Settings,Modules,Buffers,Player,Character,Folder)
	self.Aesthetics = require(Modules:WaitForChild("Aesthetics"))
	self.Player = Player
	self.Character = Character
	
	local Security = require(Modules:WaitForChild("Security"))
	
	local ActiveFolder = Folder:WaitForChild("Active"):WaitForChild(Player.Name)
	
	local lastActivation = -10;
	UpdateEvent.OnServerEvent:connect(function(playerFired, initCF, clientTime, count)
		local now = tick()
		local LenientReloadTime = math.max(Settings.Rocket.ReloadTime - 1, Settings.Rocket.ReloadTime * .6)
		if playerFired == Player and (now - lastActivation) > LenientReloadTime then
			if Player.Character and Player.Character.Parent and Player.Character:FindFirstChild("Humanoid") and Player.Character.Humanoid.Health > 0 then
				lastActivation = now;

				local PhysicsFolder = self:CreatePhysicsFolder(count)
				
				-- Begin replication
				PhysicsFolder.ServerTime.Value = _G.BB.ServerTime.Value
				PhysicsFolder.ClientTime.Value = clientTime
				PhysicsFolder.Origin.Value = initCF
				PhysicsFolder.LatestDistance.Value = 0
				PhysicsFolder.LastUpdateTick.Value = now
				
				if Security:ApproveInit(PhysicsFolder, handle) then
					PhysicsFolder.Parent = ActiveFolder
				end
		
				-- Clean up and prepare for next rocket
				Debris:AddItem(PhysicsFolder, Settings.Rocket.DespawnTime)
			end
		end
	end)
	tool.Enabled = true
end

return Rocket]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="BindableEvent" referent="RBXD2EFAF0A71184B599BB0FA3583254438">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Activation</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Tool" referent="RBXA79DA27BF94E413BB2EB59C275A9D133">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="CanBeDropped">false</bool>
						<bool name="Enabled">false</bool>
						<CoordinateFrame name="Grip">
							<X>0</X>
							<Y>-1.29999995</Y>
							<Z>0.28000015</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="ManualActivationOnly">true</bool>
						<string name="Name">Trowel</string>
						<bool name="RequiresHandle">true</bool>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<Content name="TextureId"><url>rbxasset://Textures/Wall.png</url></Content>
						<string name="ToolTip">Wall</string>
					</Properties>
					<Item class="RemoteEvent" referent="RBXD6BE725E158F448992FA55A6663F051C">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Update</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Part" referent="RBXB0E83A1524E44AB7BA46C95519D216E4">
						<Properties>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">2</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">4</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-253.131851</X>
								<Y>24.4894829</Y>
								<Z>-46.2263412</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>-0</R02>
								<R10>0</R10>
								<R11>0</R11>
								<R12>1</R12>
								<R20>0</R20>
								<R21>-1</R21>
								<R22>0</R22>
							</CoordinateFrame>
							<bool name="CanCollide">false</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<bool name="CastShadow">false</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4284702562</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">2</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">true</bool>
							<token name="Material">256</token>
							<string name="MaterialVariantSerialized"></string>
							<string name="Name">Handle</string>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">3</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>4.4000001</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
						<Item class="Sound" referent="RBX82B78FD2CE83402DAA4F06E4B036A315">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<float name="EmitterSize">10</float>
								<NumberRange name="LoopRegion">0 60000 </NumberRange>
								<bool name="Looped">false</bool>
								<string name="Name">BuildSound</string>
								<bool name="PlayOnRemove">false</bool>
								<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
								<bool name="PlaybackRegionsEnabled">false</bool>
								<float name="PlaybackSpeed">1</float>
								<bool name="Playing">false</bool>
								<token name="RollOffMode">0</token>
								<Ref name="SoundGroup">null</Ref>
								<Content name="SoundId"><url>rbxasset://sounds//bass.wav</url></Content>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<double name="TimePosition">0</double>
								<float name="Volume">1</float>
								<float name="xmlRead_MaxDistance_3">10000</float>
							</Properties>
						</Item>
						<Item class="SpecialMesh" referent="RBXC6863E77E2854E48A79D31EA06A882B4">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<token name="LODX">2</token>
								<token name="LODY">2</token>
								<Content name="MeshId"><url>rbxasset://fonts/trowel.mesh</url></Content>
								<token name="MeshType">5</token>
								<string name="Name">Mesh</string>
								<Vector3 name="Offset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="Scale">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<Content name="TextureId"><url>http://www.roblox.com/asset/?id=5320846984</url></Content>
								<Vector3 name="VertexColor">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX650FEB56C0254DFB89C78C5F0064E3C8">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Client</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX775934E10C5748C9AAF3A63640783558">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">TrowelClient</string>
								<string name="ScriptGuid">{82E34265-BF85-478F-84C5-2CF83907D722}</string>
								<ProtectedString name="Source"><![CDATA[local Trowel = {}

local tool = script.Parent.Parent

local function snap(Vector)
	return (math.abs(Vector.x)>math.abs(Vector.z))
	and ((Vector.x>0) and Vector3.new(1,0,0) or Vector3.new(-1,0,0))
	or ((Vector.z>0) and Vector3.new(0,0,1) or Vector3.new(0,0,-1))
end

function Trowel:Place(TargetPosition)
	local Head = self.Character.PrimaryPart
	local Lifetime = _G.BB.Settings.Trowel.Lifetime

		
	local vectorConstructor = Vector3.new(
		math.ceil(TargetPosition.X-0.5),
		math.floor(TargetPosition.Y*100)*0.01,
		math.ceil(TargetPosition.Z-0.5)
	)
	
	local lookAt = snap((vectorConstructor - Head.Position).unit)
	
	local cf = CFrame.new(vectorConstructor, vectorConstructor + lookAt)
	local wall = self.Buffer.Value
	
	for _,Brick in pairs(wall:GetChildren()) do
		local SB = Brick:FindFirstChildWhichIsA("SelectionBox")
		if SB then
			SB.Visible = _G.BB.Local.TrowelOutlines
		end
	end
	
	--wall.Parent = workspace
	
	game:GetService("Debris"):AddItem(wall, Lifetime)
	local ct = wall.PhysicsFolder.RandomColor.Value
	
	-- Build client wall
	local function BuildWall()
		self.TrowelModule:BuildWall(cf,wall,.04, ct)
	end
	task.spawn(BuildWall)
	
	return cf
end

function Trowel:Init()
	local Player = game:GetService("Players").LocalPlayer
	
	self.ActiveFolder = workspace:WaitForChild("Projectiles"):WaitForChild("Active"):WaitForChild(Player.Name)
	
	self.Character = game:GetService("Players").LocalPlayer.Character
	
	self.Buffer = _G.BB.Buffers:WaitForChild("Wall")
	
	self.TrowelModule = require(tool:WaitForChild("TrowelModule"))

	local verifyBuffer = require(tool:WaitForChild("VerifyBuffer"))
	local Activation = tool:WaitForChild("Activation")
	local UpdateEvent = tool:WaitForChild("Update")

	local ReloadTime = _G.BB.Settings.Trowel.ReloadTime
	
	local SafeWait = require(_G.BB.Modules.Security:WaitForChild("SafeWait"))

	local HandleCrosshair = require(_G.BB.ClientObjects:WaitForChild("HandleCrosshair"))
	HandleCrosshair(tool)

	Activation.Event:Connect(function(Hit, TargetPosition)
		if tool.Enabled then 
			if not verifyBuffer(self.Buffer, self.ActiveFolder) then
				UpdateEvent:FireServer()
				tool.Enabled = true
				return
			end

			if Hit then
				local cf = self:Place(TargetPosition)
				UpdateEvent:FireServer(cf)

			else
				return
			end
			
			tool.Enabled = false

			SafeWait.wait(ReloadTime)
			tool.Enabled = true
		end
	end)
end

return Trowel]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBXF4E08910592243E5A1C9DFFC0FC90079">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Server</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXB9870CD256314864B08DD4E6521248D9">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">TrowelServer</string>
								<string name="ScriptGuid">{D4BE263B-202B-464A-B694-0C2483766562}</string>
								<ProtectedString name="Source"><![CDATA[local Trowel = {}

local tool = script.Parent.Parent;

local UpdateEvent = tool:WaitForChild("Update")
local BuildSound = tool.Handle:WaitForChild("BuildSound");
local Aesthetics = require(_G.BB.Modules:WaitForChild("Aesthetics"))

local Debris = game:GetService("Debris")
local Collections = game:GetService("CollectionService")
local Physics = game:GetService("PhysicsService")

function Trowel:CreateBrick(brickModel)
	
	local Folder,Theme = Aesthetics:GetThemeObject(self.Player,"Trowel");
	
	local brick = Folder:FindFirstChildWhichIsA("Part"):Clone()
	local BrickIndex = #brickModel:GetChildren() + 1
	local Gradient = Folder:FindFirstChildWhichIsA("UIGradient")
	
	local RowNum = math.ceil(BrickIndex / self.BricksPerRow)
	local Alpha = (RowNum - 1) / (self.BricksPerColumn - 1)

	brick.Color = Aesthetics:GetColorAtTime(Gradient.Color, 1 - Alpha)
	brick.Color = Theme == "Team Color" and self.Player.TeamColor.Color or brick.Color

	brick.Massless = false
	brick.CanCollide = true
	brick.CastShadow = true
	brick.Shape = Enum.PartType.Block
	brick.BottomSurface = Enum.SurfaceType.Inlet
	brick.TopSurface = Enum.SurfaceType.Studs
	brick.Size = self.BrickSize
	brick.Position = self.Character.PrimaryPart.Position + Vector3.new(0,8000,0)
	
	if self.Outlines then
		-- Add an aesthetic outline
		local outLine = Instance.new("SelectionBox")
		outLine.LineThickness = 0.01
		outLine.Color3 = Color3.fromRGB(30, 30, 30)
		outLine.Parent = brick
		outLine.Adornee = brick
	end
	
	brick.Parent = brickModel
	
	-- Make sure the first placed brick has the sound
	if BrickIndex == 1 then
		BuildSound:Clone().Parent = brick
	end
	
	-- Add creator tag
	local new_tag = Instance.new("ObjectValue")
	new_tag.Name = ("creator")
	new_tag.Value = self.Player
	new_tag.Parent = brick
	
	-- Name the brick a number, which will determine when it is placed when a wall is built.
	brick.Name = BrickIndex
	
	-- Pretty sure the "Trowel Exploit" happened because of this
	--brick:SetNetworkOwner(self.Player)
	
	-- Temporarily anchor the briccc.
	brick.Anchored = true
	
	Collections:AddTag(brick, "TrowelWallBrick")
end

function Trowel:PrepareBufferWall()
	local name = (self.Player.Name.."'s Wall")
	
	if self.Buffer.Value ~= nil then
		return
	end
	
	-- Create new buffer wall model, now stored inside the buffer folder.
	local Wall = Instance.new("Model")
	Wall.Name = name;

	-- Create buffer bricks. Wall is not formatted for now.
	local BrickCount = self.BricksPerRow * self.BricksPerColumn
	for i = 1,BrickCount do
		self:CreateBrick(Wall)
	end
	
	local PhysicsFolder = Instance.new("Folder")
	PhysicsFolder.Name = "PhysicsFolder"
	
	local CT = Instance.new("Color3Value")
	CT.Name = "RandomColor"
	CT.Value = self.Aesthetics:RandomColor()
	CT.Parent = PhysicsFolder
	
	local CF = Instance.new("CFrameValue")
	CF.Name = "PlaceCFrame"
	CF.Parent = PhysicsFolder
	
	local creator = Instance.new("ObjectValue")
	creator.Name = "creator"
	creator.Value = self.Player
	creator.Parent = PhysicsFolder
	
	local wV = Instance.new("ObjectValue")
	wV.Name = "Wall"
	wV.Value = Wall
	wV.Parent = PhysicsFolder
	
	local ProjectileType = Instance.new("StringValue")
	ProjectileType.Name = "ProjectileType"
	ProjectileType.Value = "Wall"
	ProjectileType.Parent = PhysicsFolder
	
	PhysicsFolder.Parent = Wall
	
	Wall.Parent = self.BufferFolder
	self.Buffer.Value = Wall
end

function Trowel:Init(Settings,Modules,Buffers,Player,Character,Folder)
	self.BrickSize = Settings.Trowel.BrickSize
	self.BricksPerRow = Settings.Trowel.BricksPerRow
	self.BricksPerColumn = Settings.Trowel.BricksPerColumn
	self.Outlines = Settings.Trowel.Outlines
	
	self.BufferFolder = Folder:WaitForChild("Buffers"):WaitForChild(Player.Name)	
	
	self.Buffer = Buffers:WaitForChild("Wall")
	
	self.Aesthetics = require(Modules:WaitForChild("Aesthetics"))
	self.TrowelModule = require(tool:WaitForChild("TrowelModule"))

	self.Player = Player
	self.Character = Character
	
	local ActiveFolder = Folder:WaitForChild("Active"):WaitForChild(Player.Name)

	local Lifetime = Settings.Trowel.Lifetime

	local verifyBuffer = require(tool:WaitForChild("VerifyBuffer"))

	local lastActivation = -5
	
	UpdateEvent.OnServerEvent:connect(function(playerFired,cf)
		local now = time()
		
		-- Ensure firing player is the owner of the tool and is waiting reload time.
		local LenientReloadTime = math.max(Settings.Trowel.ReloadTime - 1, Settings.Trowel.ReloadTime * .6)
		
		if playerFired == Player and (now - lastActivation) > LenientReloadTime then
			if Player.Character and Player.Character.Parent and Player.Character:FindFirstChild("Humanoid") and Player.Character.Humanoid.Health > 0 then
				lastActivation = now;
				
				if verifyBuffer(self.Buffer, ActiveFolder) then
					local wall = self.Buffer.Value
					local PhysicsFolder = wall.PhysicsFolder
			
					wall.Parent = ActiveFolder
					
					PhysicsFolder.PlaceCFrame.Value = cf
					wall.AncestryChanged:Connect(function()
						PhysicsFolder:Destroy()
					end)
					
					Debris:AddItem(wall, Lifetime);
					
					local function BuildWall()
						self.TrowelModule:BuildWall(cf,wall, 0.04, true);
					end
					task.spawn(BuildWall)
				end
			
				self.Buffer.Value = nil
				self:PrepareBufferWall()
			end
		end
	end)
	
	self:PrepareBufferWall()
	
	tool.Enabled = true
end

return Trowel]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="BindableEvent" referent="RBXCFC3FB22AF114FDF99DCC82F1F755971">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Activation</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX488E277F6B084B5B9EADD3B5B05F1F6D">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">TrowelModule</string>
							<string name="ScriptGuid">{1FB03DE3-6104-4DAD-A7C9-1FEF2127D61D}</string>
							<ProtectedString name="Source"><![CDATA[-- GloriedRage
-- Created module to minimize code repetition.
local Trowel = {}
local Aesthetics = require(_G.BB.Modules:WaitForChild("Aesthetics"))

function Trowel:PositionBrick(CF,wallModel,BrickIndex,ct)
	local WallBricks = wallModel:GetChildren()
	
	-- Bricks are named with numbers. Allows for the same brick to be placed in the same
	-- place on both the client and server.
	local Brick = wallModel:FindFirstChild(BrickIndex)
	
	-- Place the brick.
	if Brick then
		--Brick:FindFirstChildWhichIsA("BodyForce"):Destroy()
		local Sound = Brick:FindFirstChildWhichIsA("Sound")
		Brick.CFrame = CF
		Brick.Anchored = false;
		
		if not (game.Players.LocalPlayer) then
			Brick:MakeJoints()
			if Sound then
				Sound:Play()
			end
		else
			if Sound then -- Client sound
				local NewSound = Sound:Clone()
				Sound:Destroy()
				NewSound.Name = "ClientTrowelSound"
				NewSound.Parent = Brick
				--print("Playing sound")
				NewSound:Play()
			end
			Aesthetics:ApplyWallColors(Brick,ct)
			if game.Players.LocalPlayer~= Brick.creator.Value then
				Brick:MakeJoints()
			end
		end
	end

	for k,j in pairs(Brick:GetJoints()) do
		local m = j.Part1:FindFirstAncestorWhichIsA("Model")
		if m and m:FindFirstChildWhichIsA("Humanoid") then
			j:Destroy()
		end
	end
	
	return Brick;
end
--[[
function Trowel:CreateServerWeld(wallModel,BrickIndex,CF)
	local WallBricks = wallModel:GetChildren();
	local Brick = wallModel:FindFirstChild(BrickIndex);
	
	if Brick then
		if (Brick.Position - CF.Position).Magnitude > 0.1 then
			print("Waiting")
			task.wait(.1)
		end
		print("Making joints for",Brick.Name)
		Brick:FindFirstChildWhichIsA("BodyForce"):Destroy()
		Brick:MakeJoints()
	end
end
]]
function Trowel:BuildWall(cf,wall,Speed,ct)
	local yPos = 0;
	local BrickIndex = 0
	local Settings = _G.BB.Settings
	
	-- Build y rows
	for i = 1,Settings.Trowel.BricksPerColumn do
		local RunningVector
		local xPos = -6
		
		-- Build x bricks per row
		for i2 = 1,Settings.Trowel.BricksPerRow do
			
			-- Increase BrickIndex before each brick is placed for proper reference
			BrickIndex = BrickIndex + 1
			local Position = Vector3.new(xPos, yPos, 0)
			local CF = cf * CFrame.new(Position + Settings.Trowel.BrickSize / 2)

			self:PositionBrick(CF,wall,BrickIndex,ct)
			
			RunningVector = (Vector3.new(xPos, yPos, 0) + Settings.Trowel.BrickSize)
			xPos = RunningVector.x
			
			task.wait(Speed)
		end
		
		yPos = RunningVector.y
	end
end

return Trowel]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXCB58578D34004BE28846D49ECB2729F3">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">VerifyBuffer</string>
							<string name="ScriptGuid">{425E06D4-1C0E-4E5A-9A69-AB17B3216755}</string>
							<ProtectedString name="Source"><![CDATA[local module = {}

return function(ObjectValue, ActiveFolder)
	local Success,Error = pcall(function()
		assert(ObjectValue,"ObjectValue does not exist.")
		assert(ObjectValue.Value,"ObjectValue's value does not exist.")
		assert(ObjectValue.Value.Parent ~= nil,"ObjectValue's value is parented to nil.")
		assert(ObjectValue.Value.Parent ~= ActiveFolder, "ObjectValue's value has already been parented to ActiveFolder.")	
		assert(ObjectValue.Value:IsA("Model"), "Improper class, msut be model.")	
	end)
	
	if Success then
		--print("Verification succeeded for: ",ObjectValue.Value.Name)
		return true
	elseif Error then
		local ValueName = ObjectValue and ObjectValue.Name or "NIL_OBJVAL_NAME"
		local ObjectName = (ObjectValue and ObjectValue.Value) and ObjectValue.Value.Name or "NIL_OBJ_NAME"
		
		warn(
			"\n Error verifying ObjectValue...",
			"\n Value:",ValueName,
			"\n Object:",ObjectName,
			"\n Error:",Error
		)
		
		return false
	end
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Tool" referent="RBXE7527DF06AF44440A6E6EB1AFD6E5616">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="CanBeDropped">false</bool>
						<bool name="Enabled">false</bool>
						<CoordinateFrame name="Grip">
							<X>6.40836242e-06</X>
							<Y>-0.0700001493</Y>
							<Z>-6.40829876e-06</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>0</R11>
							<R12>-1</R12>
							<R20>0</R20>
							<R21>1</R21>
							<R22>0</R22>
						</CoordinateFrame>
						<bool name="ManualActivationOnly">true</bool>
						<string name="Name">Bomb</string>
						<bool name="RequiresHandle">true</bool>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<Content name="TextureId"><url>rbxasset://Textures/Bomb.png</url></Content>
						<string name="ToolTip">Bomb</string>
					</Properties>
					<Item class="RemoteEvent" referent="RBXC63C7162F4164796BCC15303EF7FA8C2">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Update</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBX351FA2212B5A496AA08E5BEED450FA50">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Client</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX1A21917D965D46A3B111CBC111257E37">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">BombClient</string>
								<string name="ScriptGuid">{144D79A0-808F-4731-A013-D797AA69875A}</string>
								<ProtectedString name="Source"><![CDATA[-- Bomb
local Bomb = {}

local Players = game:GetService("Players")
local PhysicsService = game:GetService("PhysicsService")

local tool = script.Parent.Parent

local clickTime = 0
local jumpTime = 0

local regular = "http://www.roblox.com/asset/?id=5320848090"
local reload = "http://www.roblox.com/asset/?id=5321216729"

function Bomb:TryBombJump(Bomb, override)	
	local handle = tool:WaitForChild("Handle")
	local BombSettings = _G.BB.Settings.Bomb
	
	if self.Character.Humanoid.FloorMaterial == Enum.Material.Air then
		return
	end

	local BombJumpReloadTime = BombSettings.BombJumpReloadTime
	local BombJumpPosWindow = BombSettings.BombJumpPosWindow
	local BombJumpNegWindow = BombSettings.BombJumpNegWindow
	local BombJumpPowerFormula = BombSettings.BombJumpPowerFormula
	local MaxBombJumpPower =  BombSettings.MaxBombJumpPower
	local WalkingBombJump = BombSettings.WalkingBombJump

	if _G.BB.TrueMobile then
		BombJumpNegWindow  = math.min(-.2, BombJumpNegWindow)
		BombJumpPosWindow = math.max(.3, BombJumpPosWindow)
	end

	if Bomb and Bomb.Parent and (override or self.Character.Humanoid.MoveDirection == Vector3.new(0, 0, 0) or WalkingBombJump) then	
		if not self.canBombJump then
			return
		end
		
		if not override and (not jumpTime or not clickTime) then 
			return
		end	

		-- Click then jump (jumpTime ought to be larger since it comes after clickTime)
		local Difference = jumpTime-clickTime

		-- Slight leniency with the activation order
		if override or (Difference <= BombJumpPosWindow and Difference >= BombJumpNegWindow) then
			Bomb.Ready.Value = false
			PhysicsService:SetPartCollisionGroup(Bomb, "BombJumpBombs")
			Bomb.Ready.Value = true

			Difference = math.abs(Difference)

			local JumpPower
			
			if override then
				JumpPower = MaxBombJumpPower
			elseif BombJumpPowerFormula == "Quadratic" then
				JumpPower = MaxBombJumpPower * (1 - (Difference / (BombJumpPosWindow + .01))^2)
			elseif BombJumpPowerFormula == "Linear" then
				JumpPower = MaxBombJumpPower * (1 - (Difference / (BombJumpPosWindow + .01)))
			elseif BombJumpPowerFormula == "Constant" then
				JumpPower = MaxBombJumpPower
			else
				warn("Incorrect BombJumpPowerFormula value: "..BombJumpPowerFormula)
				JumpPower = MaxBombJumpPower
			end

			local rounded = math.round(JumpPower * 10) / 10
			print("Bomb jumped "..rounded.. " studs.")

			local primary = self.Character.PrimaryPart
			primary.Velocity = Vector3.new(primary.Velocity.X, JumpPower, primary.Velocity.Z)

			local function HandleReload()
				if BombJumpReloadTime > 0 then

					handle.Mesh.TextureId = reload
					handle.BrickColor = BrickColor.new("Medium stone grey")

					self.canBombJump = false
					self.bombJumpTimestamp = os.clock()

					task.wait(BombJumpReloadTime)

					if handle then
						handle.Mesh.TextureId = regular
						handle.BrickColor = BrickColor.new("Really black")
					end

					self.canBombJump = true
				end
			end

			task.spawn(HandleReload)
			
			task.delay(BombJumpPosWindow + 0.5, function()
				-- Reset collision group
				Bomb.Ready.Value = false
				PhysicsService:SetPartCollisionGroup(Bomb, "Default")
				Bomb.Ready.Value = true
			end)
		end
	end
end

function Bomb:BlowUp(Explosion)
	if Explosion.BlownUpClient.Value == true then
		return
	end
	
	Explosion.Ready.Value = false
	Explosion.BlownUpClient.Value = true

	local Size = _G.BB.Settings.Bomb.Radius * 2
	Explosion.Anchored = true
	Explosion.Size = Vector3.new(Size, Size, Size)
	Explosion.Tick:Destroy()
	
	-- Client explosion sound:
	local Sounds = Explosion:WaitForChild("Boom")
	local Sound = Sounds:FindFirstChild(_G.BB.Local.BombExplosion)
	Sound.Parent = Explosion
	Sound:Play()
	
	local function CreateVisual()
		self.Aesthetics:CreateCustomExplosion(self.Player, Explosion)
	end
	
	task.spawn(CreateVisual)
	self.Explosion:HandleHitDetection(Explosion)
end

function Bomb:HandleTick(Bomb)
	local updateInterval = 0.4
	local currentColor = 1
	local TickColor = Bomb.TickColor.Value
	local BaseColor = Bomb.BaseColor.Value

	--Bomb color was BaseColor on first two ticks.
	--Bomb.Color = TickColor
	
	local looping = true
	
	Bomb.BlownUpClient.Changed:Connect(function()
		if Bomb.BlownUpClient.Value == false then
			looping = false
		end
	end)
	
	Bomb.Ready.Value = true
	
	local expectedTime = 0
	local totalTime = 0
	
	while (updateInterval > 0.1) and looping do
		
		Bomb.Tick:Stop()
		
		-- For some reason, when changing TimePosition mobile players
		-- could not hear the sound.
		if not _G.BB.TrueMobile then
			Bomb.Tick.TimePosition = 0.12
		end
		
		Bomb.Tick:Play()
		
		expectedTime += updateInterval
		totalTime += SafeWait.wait(updateInterval)
		
		if looping then
			currentColor = currentColor == 1 and 2 or 1
			
			Bomb.Ready.Value = false
			Bomb.Color = currentColor == 1 and TickColor or BaseColor
			Bomb.Ready.Value = true
			updateInterval = updateInterval * 0.9
		end
	end
	
	return (totalTime - expectedTime < 1)
end

function Bomb:AssignTouchEvent(Bomb)
	local TouchedConnection
	local hasExploded = false
	local CharacterData

	TouchedConnection = Bomb.Touched:Connect(function(hit)
		if Bomb.BlownUpClient.Value == true then
			return
		end

		local hitCharacter = hit.Parent:IsA("Model") and hit.Parent
		local hitHumanoid = hit.Parent:FindFirstChildWhichIsA("Humanoid")

		if not hitCharacter or not hitHumanoid then
			return
		end

		local hitPlr = Players:GetPlayerFromCharacter(hitCharacter)
		local canHitSelf = self.Kill:CanDamage(self.Player, hitHumanoid, _G.BB.Settings.Bomb.TouchExplodeSelf)
		
		if hitPlr == self.Player and not canHitSelf then
			return
		end

		if not self.Kill:CanDamage(self.Player, hitHumanoid) then
			return
		end

		self:BlowUp(Bomb)
	end)
end

function Bomb:FireAndBombJump()
	if tool.Enabled and not self.Character:FindFirstChildWhichIsA("ForceField") and self.canBombJump then
		self:Fire()
		self:TryBombJump(self.CurrentBomb, true)
		return true
	end
	
	return false
end

function Bomb:Fire()
	if tool.Enabled then 

		tool.Enabled = false

		clickTime = tick()

		_G.BB.ProjectileCounts.Bombs += 1
		
		local NewBomb = self.MakeBomb(self.Player, _G.BB.ProjectileCounts.Bombs)

		self.CurrentBomb = NewBomb

		local Head = self.Character.PrimaryPart

		if _G.BB.Settings.Doomspire.BombSpawnToCam then
			local Cam = workspace.CurrentCamera
			NewBomb.CFrame = ((Cam.CFrame - Cam.CFrame.Position) + Head.Position):toWorldSpace(CFrame.new(0, 4, -2))
		else
			NewBomb.CFrame = Head.CFrame + (Head.CFrame.UpVector * 4)
		end

		NewBomb.LatestPosition.Value = NewBomb.Position
		NewBomb.LastSentPosition.Value = NewBomb.Position
		NewBomb.LastSentVelocity.Value = Vector3.new(0,0,0)
		NewBomb.LocalOriginTime.Value = clickTime
		NewBomb.Parent = self.ActiveFolder

		self.UpdateEvent:FireServer(NewBomb.CFrame, NewBomb.Velocity, clickTime, _G.BB.ProjectileCounts.Bombs)

		local function RunBomb()
			if _G.BB.Settings.Bomb.TouchExplode then
				self:AssignTouchEvent(NewBomb)
			end

			local shouldBlowUp = self:HandleTick(NewBomb)
			if shouldBlowUp then
				self:BlowUp(NewBomb)
			else
				NewBomb:Destroy()
			end
		end

		task.spawn(RunBomb)
		
		task.spawn(function()
			SafeWait.wait(_G.BB.Settings.Bomb.ReloadTime)
			tool.Enabled = true
		end)
	end
end

function Bomb:Init()
	self.canBombJump = true
	self.bombJumpTimestamp = 0
	self.CurrentBomb = nil
	
	self.Player = game:GetService("Players").LocalPlayer
	self.Character = self.Player.Character
	
	self.Tool = tool
	self.UpdateEvent = tool:WaitForChild("Update")
	local Activation = tool:WaitForChild("Activation")

	self.Aesthetics = require(_G.BB.Modules:WaitForChild("Aesthetics"))
	self.Explosion = require(_G.BB.Modules:WaitForChild("Explosion"))
	self.Kill = require(_G.BB.Modules:WaitForChild("Kill"))

	SafeWait = require(_G.BB.Modules.Security:WaitForChild("SafeWait"))

	self.ActiveFolder = workspace:WaitForChild("Projectiles"):WaitForChild("Active"):WaitForChild(self.Player.Name)
	self.MakeBomb = require(_G.BB.ClientObjects:WaitForChild("MakeBomb"))

	local HandleCrosshair = require(_G.BB.ClientObjects:WaitForChild("HandleCrosshair"))
	HandleCrosshair(tool)

	Activation.Event:Connect(function()
		self:Fire()
	end)
	
	-- Only fires once per jump.
	self.Character.Humanoid.StateChanged:Connect(function(State)
		if State == Enum.HumanoidStateType.Jumping then
			if _G.BB.Settings.BombJump or _G.BB.TrueMobile then
				-- Record jump time
				jumpTime = tick()
				self:TryBombJump(self.CurrentBomb)
			end
		end
	end)
end

return Bomb]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBXDFED440906EE4EC693897CC36D2C98A4">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Server</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXA652248782524909BBEE75277C4D57E3">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">BombServer</string>
								<string name="ScriptGuid">{5F36B4B5-7684-40AA-9FF4-3C5FCBA2CFDF}</string>
								<ProtectedString name="Source"><![CDATA[local Bomb = {}

local tool = script.Parent.Parent;

local handle = tool:WaitForChild("Handle")
local TickSound = handle:WaitForChild("Tick")
local BoomSound = handle:WaitForChild("Boom")

local UpdateEvent = tool:WaitForChild("Update")

local Players = game:GetService("Players");
local Collections = game:GetService("CollectionService");
local Physics = game:GetService("PhysicsService")

function Bomb:CreatePhysicsFolder(count)
	--_G.BB.ProjectileCounts[self.Player.Name].Bombs += 1
	
	local PhysicsFolder = Instance.new("Folder")
		
	PhysicsFolder.Name = "Bomb".._G.BB.ProjectileCounts[self.Player.Name].Bombs
	PhysicsFolder.Name = "Bomb"..count
	local new_tag = Instance.new("ObjectValue")
	new_tag.Name = ("creator")
	new_tag.Value = self.Player
	new_tag.Parent = PhysicsFolder
	
	
	local projType = Instance.new("StringValue")
	projType.Name = "ProjectileType"
	projType.Value = "Bomb"
	projType.Parent = PhysicsFolder
	
	local Exploded = Instance.new("BoolValue")
	Exploded.Name = ("Exploded")
	Exploded.Value = false;
	Exploded.Parent = PhysicsFolder;
	
	local LastUpdateTick = Instance.new("NumberValue")
	LastUpdateTick.Name = "LastUpdateTick"
	LastUpdateTick.Parent = PhysicsFolder
	
	local ID = Instance.new("StringValue")
	ID.Name = "UniqueID"
	ID.Value = PhysicsFolder.Name.._G.BB.ProjectileCounts[self.Player.Name].Bombs
	ID.Parent = PhysicsFolder
	
	local ThemeTag = Instance.new("StringValue")
	ThemeTag.Name = "Theme"
	ThemeTag.Value = self.Aesthetics:DetermineTheme(self.Player)
	ThemeTag.Parent = PhysicsFolder
	
	local realCF = Instance.new("Vector3Value")
	realCF.Name = "LatestPosition"
	realCF.Parent = PhysicsFolder
	
	local LastCF = Instance.new("Vector3Value")
	LastCF.Name = "LastSentPosition"
	LastCF.Parent = PhysicsFolder
	
	local realVel = Instance.new("Vector3Value")
	realVel.Name = "LatestVelocity"
	realVel.Parent = PhysicsFolder
	
	--You need this because clocks aren't synchronized. Can't use a global timestamp.
	--Bwuh bwuh bwuh why don't you synchronize the clocks? Well why don't YOU do it lole
	local realFT = Instance.new("NumberValue")
	realFT.Name = "LatestTime"
	realFT.Value = 0
	realFT.Parent = PhysicsFolder
	
	local realOT = Instance.new("NumberValue")
	realOT.Name = "LocalOriginTime"
	realOT.Value = 0
	realOT.Parent = PhysicsFolder
	
	local ActiveTag = Instance.new("BoolValue")
	ActiveTag.Name = ("Active")
	ActiveTag.Value = false
	ActiveTag.Parent = PhysicsFolder;
	
	local AssignedTouch = Instance.new("BoolValue")
	AssignedTouch.Name = ("BlownUpClient")
	AssignedTouch.Value = false
	AssignedTouch.Parent = PhysicsFolder;
	
	-- Add sounds
	TickSound:Clone().Parent = PhysicsFolder
	BoomSound:Clone().Parent = PhysicsFolder
	
	return PhysicsFolder
end

function Bomb:Init(Settings,Modules,Buffers,Player,Character,Folder)
	self.Settings = Settings
	
	local Security = require(Modules:WaitForChild("Security"))

	self.Aesthetics = require(Modules:WaitForChild("Aesthetics"))
	
	local ActiveFolder = Folder:WaitForChild("Active"):WaitForChild(Player.Name)
	
	self.Player = Player
	
	-- First activation must always work even if time() returns 0.
	local lastActivation = -5;	
	UpdateEvent.OnServerEvent:Connect(function(playerFired, initCF, initVel, initClientTime, count)
		local now = tick()
		local LenientReloadTime = math.max(Settings.Bomb.ReloadTime - 1, Settings.Bomb.ReloadTime * .6)
		
		if playerFired == Player and (now - lastActivation) > LenientReloadTime then
			if Player.Character and Player.Character.Parent and Player.Character:FindFirstChild("Humanoid") and Player.Character.Humanoid.Health > 0 then
				lastActivation = now
				
				local PhysicsFolder = self:CreatePhysicsFolder(count)
				
				PhysicsFolder.LatestPosition.Value = initCF.Position
				PhysicsFolder.LatestVelocity.Value = initVel
				PhysicsFolder.LatestTime.Value = 0
				
				PhysicsFolder.LocalOriginTime.Value = initClientTime
				PhysicsFolder.LastUpdateTick.Value = now
				
				PhysicsFolder.Active.Value = true

				
				if Security:ApproveInit(PhysicsFolder) then
					PhysicsFolder.Parent = ActiveFolder
				end

				local function ForceExplode()
					if PhysicsFolder.Parent
						and PhysicsFolder.Active.Value then
						
						--print("Forced explosion for:",PhysicsFolder.UniqueID.Value)
						
						PhysicsFolder.Active.Value = false
						game:GetService("Debris"):AddItem(PhysicsFolder, 0)
					end
				end
				task.delay(Settings.Bomb.DespawnTime, ForceExplode)
			end
		end	
	end)
	tool.Enabled = true
	
end

return Bomb]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="BindableEvent" referent="RBXC325078375B247169601F56BE2B1FF84">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Activation</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Part" referent="RBX430AED33E53F4CC9862EC475F42DD744">
						<Properties>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-253.131851</X>
								<Y>24.4894829</Y>
								<Z>-46.2263412</Z>
								<R00>-9.15471464e-05</R00>
								<R01>1</R01>
								<R02>9.15480778e-05</R02>
								<R10>3.05157155e-05</R10>
								<R11>-9.15452838e-05</R11>
								<R12>1</R12>
								<R20>1</R20>
								<R21>9.15499404e-05</R21>
								<R22>-3.05073336e-05</R22>
							</CoordinateFrame>
							<bool name="CanCollide">false</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<bool name="CastShadow">false</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4279308561</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>true</CustomPhysics>
								<Density>7.8499999</Density>
								<Friction>0.400000006</Friction>
								<Elasticity>0.25</Elasticity>
								<FrictionWeight>1</FrictionWeight>
								<ElasticityWeight>1</ElasticityWeight>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">true</bool>
							<token name="Material">1088</token>
							<string name="MaterialVariantSerialized"></string>
							<string name="Name">Handle</string>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">0</token>
							<Vector3 name="size">
								<X>2</X>
								<Y>2</Y>
								<Z>2</Z>
							</Vector3>
						</Properties>
						<Item class="SpecialMesh" referent="RBXCF21DB5A275D42778AEA02ABA56B4491">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<token name="LODX">2</token>
								<token name="LODY">2</token>
								<Content name="MeshId"><url>rbxasset://fonts/timebomb.mesh</url></Content>
								<token name="MeshType">5</token>
								<string name="Name">Mesh</string>
								<Vector3 name="Offset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="Scale">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<Content name="TextureId"><url>http://www.roblox.com/asset/?id=5320848090</url></Content>
								<Vector3 name="VertexColor">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBX5D48A4AE303943C28DB50E51DAC698EE">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<float name="EmitterSize">10</float>
								<NumberRange name="LoopRegion">0 60000 </NumberRange>
								<bool name="Looped">false</bool>
								<string name="Name">Tick</string>
								<bool name="PlayOnRemove">false</bool>
								<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
								<bool name="PlaybackRegionsEnabled">false</bool>
								<float name="PlaybackSpeed">1</float>
								<bool name="Playing">false</bool>
								<token name="RollOffMode">0</token>
								<Ref name="SoundGroup">null</Ref>
								<Content name="SoundId"><url>rbxasset://sounds//clickfast.wav</url></Content>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<double name="TimePosition">0</double>
								<float name="Volume">0.699999988</float>
								<float name="xmlRead_MaxDistance_3">10000</float>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBXAB686530A69B4FB7A341B0500820EB0B">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">Boom</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Sound" referent="RBXB1B3FFD49808484E905C3584E9C27CA2">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="EmitterSize">10</float>
									<NumberRange name="LoopRegion">0 60000 </NumberRange>
									<bool name="Looped">false</bool>
									<string name="Name">Modern</string>
									<bool name="PlayOnRemove">false</bool>
									<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
									<bool name="PlaybackRegionsEnabled">false</bool>
									<float name="PlaybackSpeed">1</float>
									<bool name="Playing">false</bool>
									<token name="RollOffMode">0</token>
									<Ref name="SoundGroup">null</Ref>
									<Content name="SoundId"><url>rbxassetid://1842360200</url></Content>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="TimePosition">0</double>
									<float name="Volume">8</float>
									<float name="xmlRead_MaxDistance_3">10000</float>
								</Properties>
							</Item>
							<Item class="Sound" referent="RBX980B3252F4BB49CFAE2F98FDB3A1AE99">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="EmitterSize">10</float>
									<NumberRange name="LoopRegion">0 60000 </NumberRange>
									<bool name="Looped">false</bool>
									<string name="Name">Classic</string>
									<bool name="PlayOnRemove">false</bool>
									<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
									<bool name="PlaybackRegionsEnabled">false</bool>
									<float name="PlaybackSpeed">1</float>
									<bool name="Playing">false</bool>
									<token name="RollOffMode">0</token>
									<Ref name="SoundGroup">null</Ref>
									<Content name="SoundId"><url>rbxasset://sounds/Rocket shot.wav</url></Content>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="TimePosition">0</double>
									<float name="Volume">1</float>
									<float name="xmlRead_MaxDistance_3">10000</float>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Tool" referent="RBXEC7208EF9F1246F5919F6662012FFFBC">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="CanBeDropped">false</bool>
						<bool name="Enabled">false</bool>
						<CoordinateFrame name="Grip">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="ManualActivationOnly">true</bool>
						<string name="Name">Superball</string>
						<bool name="RequiresHandle">true</bool>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<Content name="TextureId"><url>rbxasset://Textures/Superball.png</url></Content>
						<string name="ToolTip">Super Ball</string>
					</Properties>
					<Item class="RemoteEvent" referent="RBX18B2D37CF0D04792B42A030D8ED9EFFA">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Update</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBX519C4250E0F74483803D6C4B0522E1D1">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Client</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX347A339F993C4B699A12D82A0E9AFD8B">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">SuperballClient</string>
								<string name="ScriptGuid">{641C4EAA-B454-4622-A3ED-4A9A8A9F7E65}</string>
								<ProtectedString name="Source"><![CDATA[local Superball = {}

local tool = script.Parent.Parent

local function canSBJump(Character)
	return (_G.BB.Settings.SuperballJump 
		and Character.Humanoid.FloorMaterial == Enum.Material.Air 
		and _G.BB.CanSBFly)
end

function Superball:Fire(Superball, TargetPosition, SpawnDistance, count)
	
	local Speed = _G.BB.Settings.Superball.Speed
	local ShootInsideBricks = _G.BB.Settings.Superball.ShootInsideBricks
	
	local now = time()
	local SpawnPosition = self.Head.Position + (TargetPosition - self.Head.Position).unit * SpawnDistance
	local LaunchCF = CFrame.new(SpawnPosition, TargetPosition)
	local Velocity = LaunchCF.LookVector * Speed
	
	Superball.LastSentPosition.Value = LaunchCF.Position
	Superball.LastSentVelocity.Value = Velocity
	Superball.LastSentTime.Value = now
	
	Superball.CFrame = LaunchCF
	Superball.Velocity = Velocity
	Superball.Parent = self.ClientActiveFolder
	
	if not ShootInsideBricks and self.isInsideSomething(Superball) then
		Superball.Anchored = true
		local Position = self.handle.Position
		local cFrame = CFrame.lookAt(Position, TargetPosition)
		Superball.CFrame = cFrame
		Superball.Velocity = Superball.CFrame.LookVector * Speed
		Superball.Anchored = false
	end
	
	self.handle.Boing:Play() -- or handle.Boing:Play()
	
	self.Delete(Superball, 8) -- exists for 8 seconds		
	self.Hit:HandleHitDetection(Superball, count)
	return LaunchCF.Position, Velocity, now
end

function Superball:Init()
	local Player = game:GetService("Players").LocalPlayer
	local Character = Player.Character
	
	self.Hit = require(_G.BB.Modules:WaitForChild("Hit"))
	self.Delete = require(_G.BB.ClientObjects:WaitForChild("Delete"))
	self.isInsideSomething = require(_G.BB.ClientObjects:WaitForChild("isInsideSomething"))

	local MakeSuperball = require(_G.BB.ClientObjects:WaitForChild("MakeSuperball"))

	self.ClientActiveFolder = workspace:WaitForChild("Projectiles"):WaitForChild("Active"):WaitForChild(Player.Name)
	
	self.handle = tool:WaitForChild("Handle")

	self.Head = Character:WaitForChild("Head")
	
	local ReloadTime = _G.BB.Settings.Superball.ReloadTime

	local Aesthetics = require(_G.BB.Modules:WaitForChild("Aesthetics"))
	local HandleCrosshair = require(_G.BB.ClientObjects:WaitForChild("HandleCrosshair"))
	
	local UpdateEvent = tool:WaitForChild("Update")
	local Activation = tool:WaitForChild("Activation")
	local colorEvent = tool:WaitForChild("Color")
	
	local SafeWait = require(_G.BB.Modules.Security:WaitForChild("SafeWait"))

	Aesthetics:HandleSBHandle(Player, self.handle, colorEvent, true)
	HandleCrosshair(tool)
	
	Activation.Event:Connect(function(Hit, targetPos)
		if tool.Enabled then 
			tool.Enabled = false
			
			_G.BB.ProjectileCounts.Superballs += 1
			
			local count = _G.BB.ProjectileCounts.Superballs
			local CollisionGroup = "Superballs" 
			local SpawnDistance = _G.BB.Settings.Superball.SpawnDistance
			
			if canSBJump(Character) then
				CollisionGroup = "JumpySuperballs"
				SpawnDistance = 5 -- optimal spawn distance for superball jumping
			end
						
			local Superball = MakeSuperball(Player, CollisionGroup, count, self.handle.Color)
						
			local position, velocity, now = self:Fire(Superball, targetPos, SpawnDistance, count)
			UpdateEvent:FireServer(position, velocity, now, Superball.Color, count)

			Aesthetics:HandleSBHandle(Player, self.handle, colorEvent)

			SafeWait.wait(ReloadTime)
			
			tool.Enabled = true
		end
	end)
end

return Superball]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBXF2A30DC3AA59410C98E18BE2CE7A85F0">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Server</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXBB650A722C0644478CEBFAB651429491">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">SuperballServer</string>
								<string name="ScriptGuid">{31A2BAF4-1E47-49BB-9198-32441E1E2A4F}</string>
								<ProtectedString name="Source"><![CDATA[local Superball = {}

local tool = script.Parent.Parent

function Superball:CreatePhysicsFolder(color, count)
	--_G.BB.ProjectileCounts[self.Player.Name].Superballs += 1

	local PhysicsFolder = Instance.new("Folder")
	--PhysicsFolder.Name = "Superball".._G.BB.ProjectileCounts[self.Player.Name].Superballs
	PhysicsFolder.Name = "Superball"..count

	-- Aesthetics:
	local Folder, Theme = self.Aesthetics:GetThemeObject(self.Player, "Superball")
	local Part = Folder:FindFirstChildWhichIsA("Part")
	
	self.handle.Material = Part.Material
	self.handle.Reflectance = Part.Reflectance
	self.handle.Color = Theme == "Team Color" and self.Player.TeamColor.Color or Part.Color
	self.handle.Transparency = Part.Transparency
	
	local CT = Instance.new("Color3Value")
	CT.Name = "RandomColor"
	CT.Value = self.handle.Color 
	CT.Parent = PhysicsFolder
	
	local ThemeTag = Instance.new("StringValue")
	ThemeTag.Name = "Theme"
	ThemeTag.Value = self.Aesthetics:DetermineTheme(self.Player)
	ThemeTag.Parent = PhysicsFolder
	
	if _G.BB.Settings.Themes.RandomSuperballColors and ThemeTag.Value == "Normal" then
		CT.Value = color
		self.handle.Color = color
	end

	-- Add the creator tag
	local new_tag = Instance.new("ObjectValue")
	new_tag.Name = ("creator")
	new_tag.Value = self.Player;
	new_tag.Parent = PhysicsFolder
	
	local lastUpdateCFrame = Instance.new("Vector3Value")
	lastUpdateCFrame.Name = "LastSentPosition"
	lastUpdateCFrame.Parent = PhysicsFolder
	
	local lastSentTime = Instance.new("NumberValue")
	lastSentTime.Name = "LastSentTime"
	lastSentTime.Parent = PhysicsFolder
	
	local LastUpdateTick = Instance.new("NumberValue")
	LastUpdateTick.Name = "LastUpdateTick"
	LastUpdateTick.Parent = PhysicsFolder

	local lp = Instance.new("Vector3Value")
	lp.Name = "LatestPosition"
	lp.Parent = PhysicsFolder
	
	local lv = Instance.new("Vector3Value")
	lv.Name = "LatestVelocity"
	lv.Parent = PhysicsFolder
	
	local lt = Instance.new("NumberValue")
	lt.Name = "LatestTime"
	lt.Parent = PhysicsFolder

	local projType = Instance.new("StringValue")
	projType.Name = "ProjectileType"
	projType.Value = "Superball"
	projType.Parent = PhysicsFolder
	
	local ID = Instance.new("StringValue")
	ID.Name = "UniqueID"
	ID.Value = PhysicsFolder.Name.._G.BB.ProjectileCounts[self.Player.Name].Superballs
	ID.Parent = PhysicsFolder
	
	local ActiveVal = Instance.new("BoolValue")
	ActiveVal.Name = "Active"
	ActiveVal.Value = true
	ActiveVal.Parent = PhysicsFolder
	
	local CanHalfDamageValue = Instance.new("BoolValue")
	CanHalfDamageValue.Name = "CanHalfDamage"
	CanHalfDamageValue.Value = true
	CanHalfDamageValue.Parent = PhysicsFolder
	
	local Hacking = Instance.new("BoolValue")
	Hacking.Name = "Hacking"
	Hacking.Value = false
	Hacking.Parent = PhysicsFolder
	
	local Damage = Instance.new("NumberValue")
	Damage.Name = "Damage"
	Damage.Value = _G.BB.Settings.Superball.Damage;
	Damage.Parent = PhysicsFolder;
	
	self.Boing:Clone().Parent = PhysicsFolder
		
	return PhysicsFolder
end

function Superball:Init(Settings, Modules, Buffers, Player, Character, Folder)
	self.Aesthetics = require(Modules:WaitForChild("Aesthetics"))

	self.ActiveFolder = Folder:WaitForChild("Active"):WaitForChild(Player.Name)
	self.Player = Player
	
	self.handle = tool:WaitForChild("Handle")
	self.Boing = self.handle:WaitForChild("Boing")
	
	local Security = require(Modules:WaitForChild("Security"))
	local UpdateEvent = tool:WaitForChild("Update")
	local ColorEvent = tool:WaitForChild("Color")

	--self.Aesthetics:HandleSBHandle(Player, self.handle)
		
	-- First activation must always work even if time() returns 0. 
	local lastActivation = -10
	
	UpdateEvent.OnServerEvent:Connect(function(playerFired, initPos, initVel, initTime, color, count)
		
		local now = time()
		local LenientReloadTime = math.max(Settings.Superball.ReloadTime - 1, Settings.Superball.ReloadTime * .6)
		
		if playerFired == Player and (now - lastActivation) > LenientReloadTime then
			if Player.Character and Player.Character.Parent and Player.Character:FindFirstChild("Humanoid") and Player.Character.Humanoid.Health > 0 then
				lastActivation = now
				
				local PhysicsFolder = self:CreatePhysicsFolder(color, count)
				
				-- Begin replication
				PhysicsFolder.LatestPosition.Value = initPos
				PhysicsFolder.LatestVelocity.Value = initVel
				PhysicsFolder.LatestTime.Value = initTime
				PhysicsFolder.LastUpdateTick.Value = now
				PhysicsFolder.Active.Value = true
				
				if Security:ApproveInit(PhysicsFolder) then
					PhysicsFolder.Parent = self.ActiveFolder
				end
				
				game:GetService("Debris"):AddItem(PhysicsFolder, Settings.Superball.DespawnTime)
			end
		end
	end)
	
	ColorEvent.OnServerEvent:Connect(function(player, color, transparency, reflectance, material)
		self.handle.Color = color
		self.handle.Material = material
		self.handle.Reflectance = reflectance
		self.handle.Transparency = transparency
	end)
	
	tool.Enabled = true
end

return Superball]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="BindableEvent" referent="RBX841F69044F4947B6B43B915338B46EF8">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Activation</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Part" referent="RBX6A4F453CA9BF4DF28646DFE22297A424">
						<Properties>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-253.131851</X>
								<Y>24.4894829</Y>
								<Z>-46.2263412</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">false</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<bool name="CastShadow">false</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4291045404</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">true</bool>
							<token name="Material">272</token>
							<string name="MaterialVariantSerialized"></string>
							<string name="Name">Handle</string>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">0</token>
							<Vector3 name="size">
								<X>2</X>
								<Y>2</Y>
								<Z>2</Z>
							</Vector3>
						</Properties>
						<Item class="Sound" referent="RBXA1B4028CD6374055A27DBE53A661B07D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<float name="EmitterSize">10</float>
								<NumberRange name="LoopRegion">0 60000 </NumberRange>
								<bool name="Looped">false</bool>
								<string name="Name">Boing</string>
								<bool name="PlayOnRemove">false</bool>
								<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
								<bool name="PlaybackRegionsEnabled">false</bool>
								<float name="PlaybackSpeed">1</float>
								<bool name="Playing">false</bool>
								<token name="RollOffMode">0</token>
								<Ref name="SoundGroup">null</Ref>
								<Content name="SoundId"><url>rbxasset://sounds//short spring sound.wav</url></Content>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<double name="TimePosition">0</double>
								<float name="Volume">0.5</float>
								<float name="xmlRead_MaxDistance_3">10000</float>
							</Properties>
						</Item>
					</Item>
					<Item class="RemoteEvent" referent="RBXA01C920D8622471B9788B9660E072B1D">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Color</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Tool" referent="RBXE241A5BB46F149948A4829439BA7A60C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="CanBeDropped">false</bool>
						<bool name="Enabled">true</bool>
						<CoordinateFrame name="Grip">
							<X>-0.400000006</X>
							<Y>-0.5</Y>
							<Z>-0.0700000003</Z>
							<R00>0</R00>
							<R01>0</R01>
							<R02>-1</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>1</R20>
							<R21>0</R21>
							<R22>0</R22>
						</CoordinateFrame>
						<bool name="ManualActivationOnly">true</bool>
						<string name="Name">PaintballGun</string>
						<bool name="RequiresHandle">true</bool>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<Content name="TextureId"><url>rbxasset://Textures/PaintballIcon.png</url></Content>
						<string name="ToolTip"></string>
					</Properties>
					<Item class="Part" referent="RBXB8B0EABEF1C5413298509A8E261CABE4">
						<Properties>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>-145.704361</X>
								<Y>4.96128368</Y>
								<Z>60.2607651</Z>
								<R00>-0.309016764</R00>
								<R01>0.951056659</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>0</R11>
								<R12>-1</R12>
								<R20>-0.9510566</R20>
								<R21>-0.309016794</R21>
								<R22>0</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<bool name="CastShadow">true</bool>
							<string name="CollisionGroup">Default</string>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4293900344</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>true</CustomPhysics>
								<Density>0.699999988</Density>
								<Friction>0.300000012</Friction>
								<Elasticity>0.5</Elasticity>
								<FrictionWeight>1</FrictionWeight>
								<ElasticityWeight>1</ElasticityWeight>
							</PhysicalProperties>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">true</bool>
							<token name="Material">256</token>
							<string name="MaterialVariantSerialized"></string>
							<string name="Name">Handle</string>
							<CoordinateFrame name="PivotOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>3</X>
								<Y>2</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
						<Item class="SpecialMesh" referent="RBX5041719410FF4414A84279BC1EDC3A95">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<token name="LODX">2</token>
								<token name="LODY">2</token>
								<Content name="MeshId"><url>rbxassetid://998137795</url></Content>
								<token name="MeshType">5</token>
								<string name="Name">Mesh</string>
								<Vector3 name="Offset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="Scale">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<Content name="TextureId"><url>rbxasset://textures/PaintballGunTex128.png</url></Content>
								<Vector3 name="VertexColor">
									<X>1</X>
									<Y>1</Y>
									<Z>1</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBXBEF70CF6CF7D4AB5934752CBF58AB44B">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<float name="EmitterSize">10</float>
								<NumberRange name="LoopRegion">0 60000 </NumberRange>
								<bool name="Looped">false</bool>
								<string name="Name">Fire</string>
								<bool name="PlayOnRemove">false</bool>
								<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
								<bool name="PlaybackRegionsEnabled">false</bool>
								<float name="PlaybackSpeed">1</float>
								<bool name="Playing">false</bool>
								<token name="RollOffMode">0</token>
								<Ref name="SoundGroup">null</Ref>
								<Content name="SoundId"><url>rbxasset://sounds//paintball.wav</url></Content>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<double name="TimePosition">0</double>
								<float name="Volume">1</float>
								<float name="xmlRead_MaxDistance_3">10000</float>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX9613F9067981402589FE6EA546C7C426">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Client</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXB60F709FA30647FA8B775A6572246FE1">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">PaintballClient</string>
								<string name="ScriptGuid">{1A019DB7-33C3-407B-9CFE-D6A8F0FA3970}</string>
								<ProtectedString name="Source"><![CDATA[local Paintball = {}

local tool = script.Parent.Parent

function Paintball:Fire(Paintball, TargetPosition, SpawnDistance, count)
	local Speed = _G.BB.Settings.PaintballGun.Speed
	local ShootInsideBricks = _G.BB.Settings.PaintballGun.ShootInsideBricks

	local Head = self.Character.PrimaryPart
	local SpawnPosition = Head.Position + (TargetPosition - self.handle.Position).unit * SpawnDistance
	local LaunchCF = CFrame.lookAt(SpawnPosition, TargetPosition)
	local Velocity = LaunchCF.LookVector * Speed

	Paintball.CFrame = LaunchCF
	Paintball.Velocity = Velocity
	Paintball.Parent = self.ClientActiveFolder
	
	if ShootInsideBricks == false and self.isInsideSomething(Paintball) then
		Paintball.Anchored = true
		local Position = tool.Handle.Position
		Paintball.CFrame = CFrame.lookAt(Position, TargetPosition)
		Paintball.Velocity = Paintball.CFrame.LookVector * Speed
		Paintball.Anchored = false
	end
	
	game:GetService("Debris"):AddItem(Paintball, 10)
	
	self.Hit:HandleHitDetection(Paintball)
	return LaunchCF.Position, Velocity
end

function Paintball:Init()
	local Player = game:GetService("Players").LocalPlayer
	
	self.Hit = require(_G.BB.Modules:WaitForChild("Hit"))
	
	self.ClientActiveFolder = workspace:WaitForChild("Projectiles"):WaitForChild("Active"):WaitForChild(Player.Name)
	self.handle = tool:WaitForChild("Handle")
	local UpdateEvent = tool:WaitForChild("Update")

	local SafeWait = require(_G.BB.Modules.Security:WaitForChild("SafeWait"))
	
	self.Character = Player.Character
	
	local Activation = tool:WaitForChild("Activation")
	local MakePaintball = require(_G.BB.ClientObjects:WaitForChild("MakePaintball"))
	
	local HandleCrosshair = require(_G.BB.ClientObjects:WaitForChild("HandleCrosshair"))
	HandleCrosshair(tool)
	
	self.isInsideSomething = require(_G.BB.ClientObjects:WaitForChild("isInsideSomething"))

	Activation.Event:Connect(function(Hit,targetPos)
		if tool.Enabled then 
			tool.Enabled = false

			_G.BB.ProjectileCounts.Paintballs += 1
			local count = _G.BB.ProjectileCounts.Paintballs	
			
			local Paintball = MakePaintball(Player, "Paintballs", count)

			local position, velocity = self:Fire(Paintball, targetPos, _G.BB.Settings.PaintballGun.SpawnDistance, count)
			UpdateEvent:FireServer(position, velocity, time(), count, Paintball.Color)

			SafeWait.wait(_G.BB.Settings.PaintballGun.ReloadTime)
			tool.Enabled = true
		end
	end)
end

return Paintball]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX6DAC582E89D34E44800E682BE4E3FFAB">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Server</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXA3E148E1D1AB485CB124262883CAEA2D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">PaintballServer</string>
								<string name="ScriptGuid">{3954DCC2-7AD4-4BC0-B0F4-CAEFF5774C9B}</string>
								<ProtectedString name="Source"><![CDATA[local Paintball = {}

local tool = script.Parent.Parent

function Paintball:CreatePhysicsFolder(color, count)
	
	local PhysicsFolder = Instance.new("Folder")
	
	--_G.BB.ProjectileCounts[self.Player.Name].Paintballs += 1
	
	--PhysicsFolder.Name = "PaintballGun".._G.BB.ProjectileCounts[self.Player.Name].Paintballs
	PhysicsFolder.Name = "PaintballGun"..count
	
	local ThemeTag = Instance.new("StringValue")
	ThemeTag.Name = "Theme"
	ThemeTag.Value = self.Aesthetics:DetermineTheme(self.Player)
	ThemeTag.Parent = PhysicsFolder
	
	local Folder,Theme = self.Aesthetics:GetThemeObject(self.Player,"PaintballGun");
	local Pb = Folder:FindFirstChildWhichIsA("Part")
	
	local CT = Instance.new("Color3Value")
	CT.Name = "RandomColor"
	CT.Value = color
	CT.Parent = PhysicsFolder	
	
	-- Add the creator tag
	local new_tag = Instance.new("ObjectValue")
	new_tag.Name = "creator"
	new_tag.Value = self.Player
	new_tag.Parent = PhysicsFolder

	local projType = Instance.new("StringValue")
	projType.Name = "ProjectileType"
	projType.Value = "PaintballGun"
	projType.Parent = PhysicsFolder
	
	local ID = Instance.new("StringValue")
	ID.Name = "UniqueID"
	ID.Value = PhysicsFolder.Name.._G.BB.ProjectileCounts[self.Player.Name].Paintballs
	ID.Parent = PhysicsFolder

	local pbSettings = _G.BB.Settings.PaintballGun

	local vf = Instance.new("Vector3Value")
	vf.Name = "VectorForce"
	vf.Value = pbSettings.VectorForce
	vf.Parent = PhysicsFolder

	local m = Instance.new("NumberValue")
	m.Name = "Mass"
	m.Value = self.GetMass(pbSettings.Shape, pbSettings.Size, pbSettings.Density)
	m.Parent = PhysicsFolder
	
	local lp = Instance.new("Vector3Value")
	lp.Name = "LatestPosition"
	lp.Parent = PhysicsFolder

	local lv = Instance.new("Vector3Value")
	lv.Name = "LatestVelocity"
	lv.Parent = PhysicsFolder

	local lt = Instance.new("NumberValue")
	lt.Name = "LatestTime"
	lt.Parent = PhysicsFolder
	
	local LastUpdateTick = Instance.new("NumberValue")
	LastUpdateTick.Name = "LastUpdateTick"
	LastUpdateTick.Parent = PhysicsFolder
	
	local ActiveVal = Instance.new("BoolValue")
	ActiveVal.Name = "Active"
	ActiveVal.Value = true
	ActiveVal.Parent = PhysicsFolder
	
	local ActiveVal = Instance.new("BoolValue")
	ActiveVal.Name = "Exploded"
	ActiveVal.Value = false
	ActiveVal.Parent = PhysicsFolder
	
	local Damage = Instance.new("NumberValue")
	Damage.Name = "Damage"
	Damage.Value = self.Settings.PaintballGun.Damage
	Damage.Parent = PhysicsFolder
	
	
	return PhysicsFolder
end

function Paintball:Init(Settings, Modules, Buffers ,Player, Character, Folder)	
	self.Aesthetics = require(Modules:WaitForChild("Aesthetics"))
	self.GetMass = require(tool:WaitForChild("GetMass"))
	
	self.ActiveFolder = Folder:WaitForChild("Active"):WaitForChild(Player.Name)
	
	self.Player = Player
	
	self.Settings = Settings
	
	local handle = tool:WaitForChild("Handle")
	local UpdateEvent = tool:WaitForChild("Update")

	local Security = require(Modules:WaitForChild("Security"))
	
	-- First activation must always work event if time() returns 0. 
	local lastActivation = -10;
	
	UpdateEvent.OnServerEvent:Connect(function(playerFired,initPos,initVel, initTime, count, color)
		
		-- Verifying firer == player and reload time was waited upon.
		local now = time()
		local LenientReloadTime = math.max(Settings.PaintballGun.ReloadTime - 1, Settings.PaintballGun.ReloadTime * .6)
		
		if playerFired == Player and (now - lastActivation) > LenientReloadTime then
			if Player.Character and Player.Character.Parent and Player.Character:FindFirstChild("Humanoid") and Player.Character.Humanoid.Health > 0 then
			
				lastActivation = now
				
				local PhysicsFolder = self:CreatePhysicsFolder(color, count)
				
				-- Replicate projectile
				PhysicsFolder.LatestPosition.Value = initPos or Vector3.new()
				PhysicsFolder.LatestVelocity.Value = initVel or Vector3.new()
				PhysicsFolder.LatestTime.Value = initTime			
				
				handle:FindFirstChild("Fire"):Play()
				
				if Security:ApproveInit(PhysicsFolder) then
					PhysicsFolder.Parent = self.ActiveFolder
				end

				-- Clean up and prepare for next paintball
				game:GetService("Debris"):AddItem(PhysicsFolder, Settings.PaintballGun.DespawnTime)
			end
		end
	end)
	tool.Enabled = true
end

return Paintball]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="BindableEvent" referent="RBX031AB3AA27CA4B1F89F2E989B6F94CE5">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Activation</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="RemoteEvent" referent="RBX01629DED09184E25BD6DD54CF8090830">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Update</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXFD632F76CA034D07A700FC8840E36AFF">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">GetMass</string>
							<string name="ScriptGuid">{B680C083-E7C0-4A7A-9AF0-F210EA1637B2}</string>
							<ProtectedString name="Source"><![CDATA[return function(Shape, Size, Density) -- Does not account for unions
	if Shape == "Block" or Shape == "Wedge" then
		local Mass = Size.X * Size.Y * Size.Z * Density
		-- Wedges and cornerwedges do not currently have 
		-- variant mass from regular blocks
		--if Shape == "Wedge" then 
		--	Mass /= 2
		--end
		return Mass
	elseif Shape == "Ball" then
		local Radius = Size.Y / 2
		return (4 / 3) * math.pi * (Radius ^ 3) * Density 
		-- Roblox does not support irregular spheres unless using meshes, 
		-- but because you can't actually resize spheres outside of 
		-- equilaterial sides, we dont need to find the smallest axis
	elseif Shape == "Cylinder" then
		local SmallestAxis = Size.Y > Size.Z and Size.Z or Size.Y
		-- Roblox does not support irregular cylinders, 
		-- and so because we can freely resize the cylinder regardless, 
		-- we have to see which axis is smaller so we can use that as 
		-- the radius.
		local Radius = SmallestAxis / 2
		return math.pi * (Radius ^ 2) * Size.X * Density
	end
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXB1298E0DFC1942EC8A01D801B0B51BFF">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">StarterPlayerScripts</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX729BBBB4D9D54A5B87F2218F4ED53C66">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">ToolObjects</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX0B7D21AB39A847F984F4C45C71D1B327">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Sounds</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX1524A24595A949D5A24CE81D3A7F120D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">Hit</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Sound" referent="RBXC626AEF304274966B9C18A3856CA4FE4">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="EmitterSize">10</float>
									<NumberRange name="LoopRegion">0 60000 </NumberRange>
									<bool name="Looped">false</bool>
									<string name="Name">Ping</string>
									<bool name="PlayOnRemove">false</bool>
									<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
									<bool name="PlaybackRegionsEnabled">false</bool>
									<float name="PlaybackSpeed">0.75</float>
									<bool name="Playing">false</bool>
									<token name="RollOffMode">0</token>
									<Ref name="SoundGroup">null</Ref>
									<Content name="SoundId"><url>rbxassetid://1053296915</url></Content>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="TimePosition">0</double>
									<float name="Volume">1.29999995</float>
									<float name="xmlRead_MaxDistance_3">10000</float>
								</Properties>
							</Item>
							<Item class="Sound" referent="RBX4C6230C12DDC4AE1A1F5F029962C80D3">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="EmitterSize">10</float>
									<NumberRange name="LoopRegion">0 60000 </NumberRange>
									<bool name="Looped">false</bool>
									<string name="Name">Tyzone</string>
									<bool name="PlayOnRemove">false</bool>
									<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
									<bool name="PlaybackRegionsEnabled">false</bool>
									<float name="PlaybackSpeed">0.800000012</float>
									<bool name="Playing">false</bool>
									<token name="RollOffMode">0</token>
									<Ref name="SoundGroup">null</Ref>
									<Content name="SoundId"><url>rbxassetid://1053296915</url></Content>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="TimePosition">0</double>
									<float name="Volume">1.29999995</float>
									<float name="xmlRead_MaxDistance_3">10000</float>
								</Properties>
								<Item class="EqualizerSoundEffect" referent="RBX3F667EF512404C0280E6A1D3A63153B1">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="Enabled">true</bool>
										<float name="HighGain">-20.6000004</float>
										<float name="LowGain">0</float>
										<float name="MidGain">0</float>
										<string name="Name">EqualizerSoundEffect</string>
										<int name="Priority">0</int>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="Sound" referent="RBXD39C7DEF42074AE9B5812547A24687F0">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="EmitterSize">10</float>
									<NumberRange name="LoopRegion">0 60000 </NumberRange>
									<bool name="Looped">false</bool>
									<string name="Name">Mario</string>
									<bool name="PlayOnRemove">false</bool>
									<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
									<bool name="PlaybackRegionsEnabled">false</bool>
									<float name="PlaybackSpeed">1</float>
									<bool name="Playing">false</bool>
									<token name="RollOffMode">0</token>
									<Ref name="SoundGroup">null</Ref>
									<Content name="SoundId"><url>rbxassetid://131323304</url></Content>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="TimePosition">0</double>
									<float name="Volume">0.5</float>
									<float name="xmlRead_MaxDistance_3">10000</float>
								</Properties>
							</Item>
							<Item class="Sound" referent="RBX44156DE604DF4974A93945E39F9E6339">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="EmitterSize">10</float>
									<NumberRange name="LoopRegion">0 60000 </NumberRange>
									<bool name="Looped">false</bool>
									<string name="Name">TF2</string>
									<bool name="PlayOnRemove">false</bool>
									<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
									<bool name="PlaybackRegionsEnabled">false</bool>
									<float name="PlaybackSpeed">1</float>
									<bool name="Playing">false</bool>
									<token name="RollOffMode">0</token>
									<Ref name="SoundGroup">null</Ref>
									<Content name="SoundId"><url>rbxassetid://2868331684</url></Content>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="TimePosition">0</double>
									<float name="Volume">0.5</float>
									<float name="xmlRead_MaxDistance_3">10000</float>
								</Properties>
							</Item>
							<Item class="Sound" referent="RBX17649D2DDD484394A952304D3E9296A3">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="EmitterSize">10</float>
									<NumberRange name="LoopRegion">0 60000 </NumberRange>
									<bool name="Looped">false</bool>
									<string name="Name">Custom</string>
									<bool name="PlayOnRemove">false</bool>
									<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
									<bool name="PlaybackRegionsEnabled">false</bool>
									<float name="PlaybackSpeed">1</float>
									<bool name="Playing">false</bool>
									<token name="RollOffMode">0</token>
									<Ref name="SoundGroup">null</Ref>
									<Content name="SoundId"><url>rbxassetid://1053296915</url></Content>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="TimePosition">0</double>
									<float name="Volume">1</float>
									<float name="xmlRead_MaxDistance_3">10000</float>
								</Properties>
							</Item>
							<Item class="Sound" referent="RBX908DF5CD57B44F9097210BF547C9B325">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="EmitterSize">10</float>
									<NumberRange name="LoopRegion">0 60000 </NumberRange>
									<bool name="Looped">false</bool>
									<string name="Name">Minecraft</string>
									<bool name="PlayOnRemove">false</bool>
									<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
									<bool name="PlaybackRegionsEnabled">false</bool>
									<float name="PlaybackSpeed">0.5</float>
									<bool name="Playing">false</bool>
									<token name="RollOffMode">0</token>
									<Ref name="SoundGroup">null</Ref>
									<Content name="SoundId"><url>rbxassetid://1053296915</url></Content>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="TimePosition">0</double>
									<float name="Volume">1.29999995</float>
									<float name="xmlRead_MaxDistance_3">10000</float>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBXF938640338FF4A0586DCE884EDD71497">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">Kill</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Sound" referent="RBX8F4FF3E7783F47358E23F74378BF1D61">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="EmitterSize">10</float>
									<NumberRange name="LoopRegion">0 60000 </NumberRange>
									<bool name="Looped">false</bool>
									<string name="Name">TF2</string>
									<bool name="PlayOnRemove">false</bool>
									<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
									<bool name="PlaybackRegionsEnabled">false</bool>
									<float name="PlaybackSpeed">1</float>
									<bool name="Playing">false</bool>
									<token name="RollOffMode">0</token>
									<Ref name="SoundGroup">null</Ref>
									<Content name="SoundId"><url>rbxassetid://2866718318</url></Content>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="TimePosition">0</double>
									<float name="Volume">0.400000006</float>
									<float name="xmlRead_MaxDistance_3">10000</float>
								</Properties>
							</Item>
							<Item class="Sound" referent="RBX0F1AD396FDE94797B9B1DE73EDED7E58">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="EmitterSize">10</float>
									<NumberRange name="LoopRegion">0 60000 </NumberRange>
									<bool name="Looped">false</bool>
									<string name="Name">Digital</string>
									<bool name="PlayOnRemove">false</bool>
									<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
									<bool name="PlaybackRegionsEnabled">false</bool>
									<float name="PlaybackSpeed">1</float>
									<bool name="Playing">false</bool>
									<token name="RollOffMode">0</token>
									<Ref name="SoundGroup">null</Ref>
									<Content name="SoundId"><url>rbxassetid://3378242441</url></Content>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="TimePosition">0</double>
									<float name="Volume">0.5</float>
									<float name="xmlRead_MaxDistance_3">10000</float>
								</Properties>
							</Item>
							<Item class="Sound" referent="RBX1CDB57DCA3D04EED92B6801B45A0569E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="EmitterSize">10</float>
									<NumberRange name="LoopRegion">0 60000 </NumberRange>
									<bool name="Looped">false</bool>
									<string name="Name">Robot</string>
									<bool name="PlayOnRemove">false</bool>
									<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
									<bool name="PlaybackRegionsEnabled">false</bool>
									<float name="PlaybackSpeed">1</float>
									<bool name="Playing">false</bool>
									<token name="RollOffMode">0</token>
									<Ref name="SoundGroup">null</Ref>
									<Content name="SoundId"><url>rbxassetid://2275312128</url></Content>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="TimePosition">0</double>
									<float name="Volume">0.5</float>
									<float name="xmlRead_MaxDistance_3">10000</float>
								</Properties>
							</Item>
							<Item class="Sound" referent="RBX457576F5542E48D08A22B394F007DBFA">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="EmitterSize">10</float>
									<NumberRange name="LoopRegion">0 60000 </NumberRange>
									<bool name="Looped">false</bool>
									<string name="Name">Tyzone</string>
									<bool name="PlayOnRemove">false</bool>
									<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
									<bool name="PlaybackRegionsEnabled">false</bool>
									<float name="PlaybackSpeed">0.699999988</float>
									<bool name="Playing">false</bool>
									<token name="RollOffMode">0</token>
									<Ref name="SoundGroup">null</Ref>
									<Content name="SoundId"><url>rbxassetid://1053296915</url></Content>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="TimePosition">0</double>
									<float name="Volume">1.29999995</float>
									<float name="xmlRead_MaxDistance_3">10000</float>
								</Properties>
								<Item class="EqualizerSoundEffect" referent="RBXC9C56EADB04A45079728DCC08A396C4A">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="Enabled">true</bool>
										<float name="HighGain">0</float>
										<float name="LowGain">0</float>
										<float name="MidGain">0</float>
										<string name="Name">EqualizerSoundEffect</string>
										<int name="Priority">0</int>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="Sound" referent="RBX8A086E1263EE4408803711578C57C363">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="EmitterSize">10</float>
									<NumberRange name="LoopRegion">0 60000 </NumberRange>
									<bool name="Looped">false</bool>
									<string name="Name">Cannon</string>
									<bool name="PlayOnRemove">false</bool>
									<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
									<bool name="PlaybackRegionsEnabled">false</bool>
									<float name="PlaybackSpeed">3.5</float>
									<bool name="Playing">false</bool>
									<token name="RollOffMode">0</token>
									<Ref name="SoundGroup">null</Ref>
									<Content name="SoundId"><url>rbxassetid://4607149531</url></Content>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="TimePosition">0</double>
									<float name="Volume">3.5</float>
									<float name="xmlRead_MaxDistance_3">10000</float>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX4CE9515254244400BFA99E028C05B158">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">Blocked</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Sound" referent="RBX3AD8D278A28042FAB16EF645FC1DA208">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="EmitterSize">10</float>
									<NumberRange name="LoopRegion">0 60000 </NumberRange>
									<bool name="Looped">false</bool>
									<string name="Name">Tyzone</string>
									<bool name="PlayOnRemove">false</bool>
									<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
									<bool name="PlaybackRegionsEnabled">false</bool>
									<float name="PlaybackSpeed">5</float>
									<bool name="Playing">false</bool>
									<token name="RollOffMode">0</token>
									<Ref name="SoundGroup">null</Ref>
									<Content name="SoundId"><url>rbxassetid://1053296915</url></Content>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="TimePosition">0</double>
									<float name="Volume">1.29999995</float>
									<float name="xmlRead_MaxDistance_3">10000</float>
								</Properties>
								<Item class="EqualizerSoundEffect" referent="RBX8AE812F228684D1B8DEEE2C221DB3730">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="Enabled">true</bool>
										<float name="HighGain">-12</float>
										<float name="LowGain">0</float>
										<float name="MidGain">0</float>
										<string name="Name">EqualizerSoundEffect</string>
										<int name="Priority">0</int>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="PitchShiftSoundEffect" referent="RBX90453FCD5ED14412AC98AD3B2D9F36C5">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="Enabled">true</bool>
										<string name="Name">PitchShiftSoundEffect</string>
										<float name="Octave">0.5</float>
										<int name="Priority">0</int>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="PitchShiftSoundEffect" referent="RBX92A40334017B49ADB6FB6EC0B1DE4DD0">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="Enabled">true</bool>
										<string name="Name">PitchShiftSoundEffect</string>
										<float name="Octave">0.5</float>
										<int name="Priority">0</int>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="PitchShiftSoundEffect" referent="RBX5FE953636ED94FCF94133ACC870368B4">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="Enabled">true</bool>
										<string name="Name">PitchShiftSoundEffect</string>
										<float name="Octave">0.5</float>
										<int name="Priority">0</int>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="Sound" referent="RBX56E8CC013654470AA866C92AD2AF8FA0">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="EmitterSize">10</float>
									<NumberRange name="LoopRegion">0 60000 </NumberRange>
									<bool name="Looped">false</bool>
									<string name="Name">Punch</string>
									<bool name="PlayOnRemove">false</bool>
									<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
									<bool name="PlaybackRegionsEnabled">false</bool>
									<float name="PlaybackSpeed">1</float>
									<bool name="Playing">false</bool>
									<token name="RollOffMode">0</token>
									<Ref name="SoundGroup">null</Ref>
									<Content name="SoundId"><url>rbxassetid://3041192327</url></Content>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="TimePosition">0</double>
									<float name="Volume">0.5</float>
									<float name="xmlRead_MaxDistance_3">10000</float>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX025FD6EC1B094098B9C19A6649ABE16D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">SuperballSounds</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Sound" referent="RBX4DC9F2B4B6FB4BE0AD3F5111FB928D18">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="EmitterSize">10</float>
									<NumberRange name="LoopRegion">0 60000 </NumberRange>
									<bool name="Looped">false</bool>
									<string name="Name">Boing</string>
									<bool name="PlayOnRemove">false</bool>
									<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
									<bool name="PlaybackRegionsEnabled">false</bool>
									<float name="PlaybackSpeed">1</float>
									<bool name="Playing">false</bool>
									<token name="RollOffMode">0</token>
									<Ref name="SoundGroup">null</Ref>
									<Content name="SoundId"><url>rbxasset://sounds//short spring sound.wav</url></Content>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="TimePosition">0</double>
									<float name="Volume">0.5</float>
									<float name="xmlRead_MaxDistance_3">300</float>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX3152B480679B413DBDBCF394AE06FF0E">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">SlingshotSounds</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Sound" referent="RBXBBCEAF66A7A24095BBB8B02C526A8DDC">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="EmitterSize">10</float>
									<NumberRange name="LoopRegion">0 60000 </NumberRange>
									<bool name="Looped">false</bool>
									<string name="Name">Classic</string>
									<bool name="PlayOnRemove">false</bool>
									<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
									<bool name="PlaybackRegionsEnabled">false</bool>
									<float name="PlaybackSpeed">1</float>
									<bool name="Playing">false</bool>
									<token name="RollOffMode">0</token>
									<Ref name="SoundGroup">null</Ref>
									<Content name="SoundId"><url>rbxassetid://844029237</url></Content>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="TimePosition">0</double>
									<float name="Volume">0.699999988</float>
									<float name="xmlRead_MaxDistance_3">500</float>
								</Properties>
							</Item>
							<Item class="Sound" referent="RBXC8D0617AAC2540D7BEF9AEEA73DBBF0E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="EmitterSize">10</float>
									<NumberRange name="LoopRegion">0 60000 </NumberRange>
									<bool name="Looped">false</bool>
									<string name="Name">Modern</string>
									<bool name="PlayOnRemove">false</bool>
									<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
									<bool name="PlaybackRegionsEnabled">false</bool>
									<float name="PlaybackSpeed">1.20000005</float>
									<bool name="Playing">false</bool>
									<token name="RollOffMode">0</token>
									<Ref name="SoundGroup">null</Ref>
									<Content name="SoundId"><url>http://www.roblox.com/asset/?id=94795238</url></Content>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="TimePosition">0</double>
									<float name="Volume">2</float>
									<float name="xmlRead_MaxDistance_3">500</float>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBXA70D1265D8DA4F359AE7039075EA4127">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">RocketSounds</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBX8BD0BA2BF2254879B92AAD41BBCEF101">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Boom</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Sound" referent="RBXE7A2E406FC904A38B12A3DD824DC51BD">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<float name="EmitterSize">10</float>
										<NumberRange name="LoopRegion">0 60000 </NumberRange>
										<bool name="Looped">false</bool>
										<string name="Name">Modern</string>
										<bool name="PlayOnRemove">false</bool>
										<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
										<bool name="PlaybackRegionsEnabled">false</bool>
										<float name="PlaybackSpeed">2</float>
										<bool name="Playing">false</bool>
										<token name="RollOffMode">0</token>
										<Ref name="SoundGroup">null</Ref>
										<Content name="SoundId"><url>rbxassetid://3149249837</url></Content>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<double name="TimePosition">0</double>
										<float name="Volume">4</float>
										<float name="xmlRead_MaxDistance_3">300</float>
									</Properties>
								</Item>
								<Item class="Sound" referent="RBX1655273729D742D69E057C7129092166">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<float name="EmitterSize">10</float>
										<NumberRange name="LoopRegion">0 60000 </NumberRange>
										<bool name="Looped">false</bool>
										<string name="Name">Classic</string>
										<bool name="PlayOnRemove">false</bool>
										<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
										<bool name="PlaybackRegionsEnabled">false</bool>
										<float name="PlaybackSpeed">1</float>
										<bool name="Playing">false</bool>
										<token name="RollOffMode">0</token>
										<Ref name="SoundGroup">null</Ref>
										<Content name="SoundId"><url>rbxasset://sounds/collide.wav</url></Content>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<double name="TimePosition">0</double>
										<float name="Volume">1</float>
										<float name="xmlRead_MaxDistance_3">300</float>
									</Properties>
								</Item>
							</Item>
							<Item class="Sound" referent="RBXF024160087DC4DB98E81E4E6023AB599">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="EmitterSize">10</float>
									<NumberRange name="LoopRegion">0 60000 </NumberRange>
									<bool name="Looped">true</bool>
									<string name="Name">Swoosh</string>
									<bool name="PlayOnRemove">false</bool>
									<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
									<bool name="PlaybackRegionsEnabled">false</bool>
									<float name="PlaybackSpeed">1</float>
									<bool name="Playing">false</bool>
									<token name="RollOffMode">0</token>
									<Ref name="SoundGroup">null</Ref>
									<Content name="SoundId"><url>rbxasset://sounds/Rocket whoosh 01.wav</url></Content>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="TimePosition">0</double>
									<float name="Volume">0.699999988</float>
									<float name="xmlRead_MaxDistance_3">300</float>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX83C2E1487412465597FF28191B65E7B8">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">BombSounds</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBX9588479FEC074DC7AC3E648E8190CE35">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Boom</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Sound" referent="RBXA4C0155B61FF443D8126CB9BC25B8EC5">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<float name="EmitterSize">10</float>
										<NumberRange name="LoopRegion">0 60000 </NumberRange>
										<bool name="Looped">false</bool>
										<string name="Name">Modern</string>
										<bool name="PlayOnRemove">false</bool>
										<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
										<bool name="PlaybackRegionsEnabled">false</bool>
										<float name="PlaybackSpeed">1</float>
										<bool name="Playing">false</bool>
										<token name="RollOffMode">0</token>
										<Ref name="SoundGroup">null</Ref>
										<Content name="SoundId"><url>rbxassetid://1842360200</url></Content>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<double name="TimePosition">0</double>
										<float name="Volume">8</float>
										<float name="xmlRead_MaxDistance_3">300</float>
									</Properties>
								</Item>
								<Item class="Sound" referent="RBX7A79F7ADD5D947FE87E65B2DCD961238">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<float name="EmitterSize">10</float>
										<NumberRange name="LoopRegion">0 60000 </NumberRange>
										<bool name="Looped">false</bool>
										<string name="Name">Classic</string>
										<bool name="PlayOnRemove">false</bool>
										<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
										<bool name="PlaybackRegionsEnabled">false</bool>
										<float name="PlaybackSpeed">1</float>
										<bool name="Playing">false</bool>
										<token name="RollOffMode">0</token>
										<Ref name="SoundGroup">null</Ref>
										<Content name="SoundId"><url>rbxasset://sounds/Rocket shot.wav</url></Content>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<double name="TimePosition">0</double>
										<float name="Volume">1</float>
										<float name="xmlRead_MaxDistance_3">300</float>
									</Properties>
								</Item>
							</Item>
							<Item class="Sound" referent="RBX8A3B83604E9C4B9F8665F44FCF812983">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="EmitterSize">10</float>
									<NumberRange name="LoopRegion">0 60000 </NumberRange>
									<bool name="Looped">false</bool>
									<string name="Name">Tick</string>
									<bool name="PlayOnRemove">false</bool>
									<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
									<bool name="PlaybackRegionsEnabled">false</bool>
									<float name="PlaybackSpeed">1</float>
									<bool name="Playing">false</bool>
									<token name="RollOffMode">0</token>
									<Ref name="SoundGroup">null</Ref>
									<Content name="SoundId"><url>rbxasset://sounds//clickfast.wav</url></Content>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="TimePosition">0</double>
									<float name="Volume">0.699999988</float>
									<float name="xmlRead_MaxDistance_3">300</float>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX04329079AF2A4D809DABFF12B9922608">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MakeSuperball</string>
							<string name="ScriptGuid">{8F4427C0-73B2-42F9-A912-04712B2097F7}</string>
							<ProtectedString name="Source"><![CDATA[local Collections = game:GetService("CollectionService")
local Debris = game:GetService("Debris")
local Physics = game:GetService("PhysicsService")
local Aesthetics = require(_G.BB.Modules:WaitForChild("Aesthetics"))

-- Create the superball
return function(Creator, CollisionGroup, count, _color)
	local Folder,Theme = Aesthetics:GetThemeObject(Creator, "Superball");
	local Part = Folder:FindFirstChildWhichIsA("Part"):Clone()
	
	Collections:AddTag(Part,"Superball")
	Collections:AddTag(Part,"Projectile")
	
	Part.Name = Creator.Name.."'s Superball"
	Part.CastShadow = true
	Part.Massless = false
	Part.Anchored = false
	Part.CanCollide = true
	Part.Size = Vector3.new(2, 2, 2)
	Part.Shape = Enum.PartType.Ball
	Part.BottomSurface = Enum.SurfaceType.Smooth
	Part.TopSurface = Enum.SurfaceType.Smooth
	
	if _G.BB.Settings.Themes.RandomSuperballColors and Theme == "Normal" then
		Part.Color =  _color
	elseif Theme == "Team Color" then
		Part.Color = Creator.TeamColor.Color
	end
	
	_G.BB.ClientObjects.Sounds.SuperballSounds.Boing:Clone().Parent = Part
	
	Aesthetics:HandleProjectileVisuals(Creator, Part, Theme)
	
	--local PhysicsFolderVal = Instance.new("ObjectValue")
	--PhysicsFolderVal.Name = "PhysicsFolder"
	--PhysicsFolderVal.Value = PhysicsFolder
	--PhysicsFolderVal.Parent = Part
	
	Part.CustomPhysicalProperties = PhysicalProperties.new(0.7, 0, 1, 1, 1)
	Physics:SetPartCollisionGroup(Part, CollisionGroup)
	
	-- In order to remove the PhysicsFolder buffer, had to make the projectile
	-- the location of data storage.
	
	local lastUpdateVel = Instance.new("Vector3Value")
	lastUpdateVel.Name = "LastSentVelocity"
	lastUpdateVel.Parent = Part

	local lastUpdateCFrame = Instance.new("Vector3Value")
	lastUpdateCFrame.Name = "LastSentPosition"
	lastUpdateCFrame.Parent = Part

	local lastSentTime = Instance.new("NumberValue")
	lastSentTime.Name = "LastSentTime"
	lastSentTime.Parent = Part
	
	local Damage = Instance.new("NumberValue")
	Damage.Name = "Damage"
	Damage.Value = _G.BB.Settings.Superball.Damage
	Damage.Parent = Part
	
	local Type = Instance.new("StringValue")
	Type.Name = "ProjectileType"
	Type.Value = "Superball"
	Type.Parent = Part
	
	local c = Instance.new("ObjectValue")
	c.Name = "creator"
	c.Value = Creator
	c.Parent = Part
	
	local active = Instance.new("BoolValue")
	active.Name = "Active"
	active.Value = true
	active.Parent = Part
	
	local Ready = Instance.new("BoolValue")
	Ready.Name = "Ready"
	Ready.Value = false
	Ready.Parent = Part
	
	if count then
		local countVal = Instance.new("NumberValue")
		countVal.Name = "Count"
		countVal.Value = count
		countVal.Parent = Part
	end
	
	return Part
end
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX4C43A19FD8E644EC916E71624797B3E8">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MakeRocket</string>
							<string name="ScriptGuid">{A2D69476-6201-420B-8886-5C649404AADC}</string>
							<ProtectedString name="Source"><![CDATA[local Collections = game:GetService("CollectionService")
local Players = game:GetService("Players")
local Debris = game:GetService("Debris")
local Physics = game:GetService("PhysicsService")

local Aesthetics = require(_G.BB.Modules:WaitForChild("Aesthetics"))

-- Create the Rocket
return function(Creator, count, PhysicsFolder)

	local Folder,Theme = Aesthetics:GetThemeObject(Creator, "Rocket")
	
	local Part = Folder:FindFirstChildWhichIsA("Part"):Clone()
	Part.Name = Creator.Name.."s Rocket"
	Part.Size = Vector3.new(1, 1, 4)
	Part.BottomSurface = 3
	Part.TopSurface = 3
	Part.LeftSurface = 3
	Part.RightSurface = 3
	Part.FrontSurface = 3
	Part.BackSurface = 3
	Part.CanCollide = false
	Part.CastShadow = true
	Part.Massless = true
	
	Collections:AddTag(Part,"Rocket")
	Collections:AddTag(Part,"Projectile")
	
	if Theme == "Team Color" then
		Part.Color = Creator.TeamColor.Color
	end
	
	-- Make it float
	local force = Instance.new("BodyForce")
	force.Name = "Floater"
	force.Force = Vector3.new(0, Part:GetMass() * workspace.Gravity, 0)
	force.Parent = Part
	
	-- Used for ramp-up
	local vel = Instance.new("BodyVelocity")
	vel.Name = "RocketVelocity"
	vel.Velocity = Vector3.new(0, 0, 0)
	vel.MaxForce = Vector3.new(0, 0, 0)
	vel.Parent = Part
	
	Aesthetics:HandleProjectileVisuals(Creator, Part)

	_G.BB.ClientObjects.Sounds.RocketSounds.Boom:Clone().Parent = Part
	_G.BB.ClientObjects.Sounds.RocketSounds.Swoosh:Clone().Parent = Part

	local v = Instance.new("NumberValue")
	v.Name = "LastReceivedDistance"
	v.Value = 0
	v.Parent = Part

	local ld = Instance.new("Vector3Value")
	ld.Name = "LastSentPosition"
	ld.Parent = Part
	
	local lastUpdateVel = Instance.new("Vector3Value")
	lastUpdateVel.Name = "LastSentVelocity"
	lastUpdateVel.Parent = Part

	local Damage = Instance.new("NumberValue")
	Damage.Name = "Damage"
	Damage.Value = _G.BB.Settings.Rocket.Damage
	Damage.Parent = Part

	local Type = Instance.new("StringValue")
	Type.Name = "ProjectileType"
	Type.Value = "Rocket"
	Type.Parent = Part

	local c = Instance.new("ObjectValue")
	c.Name = "creator"
	c.Value = Creator
	c.Parent = Part
	
	local LastUpdateTick = Instance.new("NumberValue")
	LastUpdateTick.Name = "LastUpdateTick"
	LastUpdateTick.Parent = Part

	local cf = Instance.new("CFrameValue")
	cf.Name = "Origin"
	cf.Parent = Part

	local active = Instance.new("BoolValue")
	active.Name = "Active"
	active.Value = true
	active.Parent = Part
	
	local Ready = Instance.new("BoolValue")
	Ready.Name = "Ready"
	Ready.Value = false
	Ready.Parent = Part

	if count then
		local countVal = Instance.new("NumberValue")
		countVal.Name = "Count"
		countVal.Value = count
		countVal.Parent = Part
	end
		
	if _G.BB.Settings.Doomspire.RocketCollisions then
		Physics:SetPartCollisionGroup(Part, "RideableRockets")
		Part.CanCollide = true
	end
		
	
	return Part
end
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBX3DA93877AAC74A4A97736626EDE1092F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Core</string>
							<token name="RunContext">0</token>
							<string name="ScriptGuid">{5A8803E0-D3CE-434F-84E9-46AAD542867B}</string>
							<ProtectedString name="Source"><![CDATA[-- GloriedRage

local Physics = game:GetService("PhysicsService")
local repStorage = game:GetService("ReplicatedStorage");
local Collections = game:GetService("CollectionService")
local UserInputService = game:GetService("UserInputService")
local CollectionService = game:GetService("CollectionService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local Player = Players.LocalPlayer
local Mouse = Player:GetMouse()

local ProjectileFolder = workspace:WaitForChild("Projectiles")
local Remotes = repStorage:WaitForChild("ToolNetworking")
local Modules = repStorage:WaitForChild("ToolModules")
local TimeValue = repStorage:WaitForChild("SERVER_TIME")
local Buffers = Player:WaitForChild("Buffers") -- stored in player bc server doesn't have access to PS
local ClientObjects = script.Parent

local ExtapolationModule = require(script:WaitForChild("Extrapolation"))
local Targeting = require(script:WaitForChild("Targeting"))
local SuperballCollisions = require(script:WaitForChild("SuperballCollisions"))

local Security = require(Modules:WaitForChild("Security"))
local PSPV = require(Modules.Security:WaitForChild("PSPV"))
local Aesthetics = require(Modules:WaitForChild("Aesthetics"))

local Settings = Remotes:WaitForChild("AcquireSettings"):InvokeServer()

local function getNumParts(char)
	local count = 0
	
	for _, charPart in pairs(char:GetDescendants()) do
		if charPart:IsA("BasePart") then
			count += 1
		end
	end
	
	return count
end

local function partsLoaded(char, rigType)
	local min = rigType == Enum.HumanoidRigType.R15 and 16 or 7
	
	return getNumParts(char) >= min
end

function SetCollisions(char)

	while not _G.BB do
		task.wait()
	end
	
	_G.BB.CanSBFly = true
	
	local humanoid = char:FindFirstChildWhichIsA("Humanoid")
	
	while not partsLoaded(char, humanoid.RigType) do
		task.wait()
	end
	
	for _,CharacterPart in pairs(char:GetDescendants()) do
		if CharacterPart:IsA("BasePart") then
			--print("Set collisions for: "..CharacterPart.Name)
			Physics:SetPartCollisionGroup(CharacterPart,"PlayerParts")
		end
	end
	
	local Humanoid = char:FindFirstChildWhichIsA("Humanoid")
	if Humanoid and Settings.SuperballJump and not Settings.SuperballFly then
		SuperballCollisions(Humanoid)
	end
end

-- Initialize an individual tool
function LoadTool(Tool)
	local ClientFolder = Tool:FindFirstChild("Client")
	local ClientModule = ClientFolder and ClientFolder:FindFirstChildWhichIsA("ModuleScript")
	local ActivationEvent = Tool:FindFirstChild("Activation")
	
	if ClientModule and ActivationEvent then
		Collections:AddTag(Tool, "Initialized")
		require(ClientModule):Init()
	end
end

local function Verify(Tool)
	if Tool:IsA("Tool") and not Collections:HasTag(Tool, "Initialized") then
		Collections:AddTag(Tool, "Initialized")
		task.spawn(LoadTool, Tool)
	end
end

-- Initialize all client tools in back
function InitializeClient()
	for _,Tool in pairs(Player.Backpack:GetChildren()) do
		Verify(Tool)
	end
end

function InitializeExtrapolation()
	ExtapolationModule:Init(Settings, Modules, Remotes, Player, ProjectileFolder)
end

-- Construct and release global table
local GlobalTable = {}
GlobalTable.Settings = Settings
GlobalTable.Modules = Modules
GlobalTable.Remotes = Remotes
GlobalTable.Buffers = Buffers
GlobalTable.ProjectileFolder = ProjectileFolder
GlobalTable.ServerTime = TimeValue
GlobalTable.ClientObjects = ClientObjects
GlobalTable.TrueMobile = not UserInputService.ModalEnabled and  UserInputService.TouchEnabled
GlobalTable.CanSBFly = true
GlobalTable.Local = Settings.LocalSettingsDefaults
GlobalTable.InitializeClient = InitializeClient
GlobalTable.LoadTool = LoadTool
GlobalTable.ToggleThemes = Aesthetics.ToggleThemes
GlobalTable.IconStateChanged = Instance.new("BindableEvent")
GlobalTable.SlaveTimeTable = {}
GlobalTable.ProjectileCounts = {
	Superballs = 0;
	Rockets = 0;
	Pellets = 0;
	Bombs = 0;
	Walls = 0;
	Paintballs = 0;
}

_G.BB = GlobalTable
print("Released global table")

local function CharacterAdded(character)
	if not character.Parent then
		character.AncestryChanged:Wait()
	end
	
	if character.Parent and Player.Character == character then
		character:WaitForChild("Humanoid")
		
		task.spawn(InitializeClient)
		SetCollisions(character)
	end
end

-- Begin initialization and event registering
local Character = Player.Character
if Character then
	task.spawn(CharacterAdded, Character)
end

task.spawn(InitializeExtrapolation)

Player.CharacterAdded:Connect(CharacterAdded)
Player.Backpack.ChildAdded:Connect(function(Tool)
	Verify(Tool)
end)

Aesthetics:RegisterClientEvents()
PSPV:InitClient()

local function ActivateTool(Position, TouchTap)
	local tool = Security:ApproveActivation(Player)
	if tool then
		if tool.Name == "Bomb" or tool.Name == "Sword" then
			tool.Activation:Fire()
		else
			local Hit, TargetPosition = Targeting:Get3DPosition(Position.X, Position.Y, TouchTap)
			tool.Activation:Fire(Hit, TargetPosition)
		end
	end
end

if UserInputService.TouchEnabled and Settings.Mobile.ShootMode == "InWorld" then
	UserInputService.TouchTapInWorld:Connect(function(Position, UITouch)
		if UITouch then return end
		ActivateTool(Position, true)
	end)
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed == false then
		if input.UserInputType == Enum.UserInputType.MouseButton1 
			or input.UserInputType == Enum.UserInputType.Gamepad1
			or (
				Settings.Mobile.ShootMode == "UserInput" 
				and input.UserInputType == Enum.UserInputType.Touch
				)
		then
			ActivateTool(input.Position, input.UserInputType == Enum.UserInputType.Touch)
		end
	end
end)

Collections:GetInstanceAddedSignal("BodyMoverServer"):Connect(function(p)
	if p:IsA("BodyVelocity") then
		p.MaxForce = Vector3.new()
	elseif p:IsA("BodyAngularVelocity") then
		p.MaxTorque = Vector3.new()
	else
		warn("Unrecognized BodyMoverServer object named", p.Name)
	end
end)

--[[
	Under _G.BB:
	- Settings: The default settings that were overriden by the requirer's changes
	- Modules: Directory of the modules used by the toolset
	- Remotes: Directory of the remotes used by the toolset
	- Buffers: Directory of the buffers used by the toolset
	- ProjectileFolder: Directory of the projectiles (would be physics folders from server's POV)
	- ServerTime: Value that holds the last tick() at .Heartbeat intervals. **Set by server, replicated to client
	- ClientObjects: Directory of the client modules (this script's parent)
	- TrueMobile: A bool of whether or not the player is truly on mobile
	- CanSbFly: A bool of whether or not the player has landed from their last superball jump
	- Local: Refers to the setting's local variables table
	- InitializeClient: Function that initializes all tools a client has
	- LoadModule: A function that loads the client modules of a specific weapon
	- ToggleThemes: A function that toggles the visibility of all themes in the game (no neon, no particles, no trails, etc)
	- IconStateChanged: A BindableEvent that fires when the player equips a tool, reloads, fires, or unequips a tool
	- SlaveTimeTable: Only relevant when Security.PSPV is true. Table created by client filled with other character CFrames and positions.
	- ProjectileCounts: Count of each projectile (increases as they're fired). Does not reset after death, only after rejoining
]]
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXAD03C283434A4AEF81C4C0C33C9596C7">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Targeting</string>
								<string name="ScriptGuid">{F8A129D5-F52A-424A-A9B0-89EBE69387D9}</string>
								<ProtectedString name="Source"><![CDATA[-- GloriedRage, Thegameboy and NexusAvenger
local Targeting = {}

local Collections = game:GetService("CollectionService")
local Filtered = {}

-- Assumes nothing like nested models in the hierarchy.
local function FindCharacterAncestor(part)
	local Model = part:FindFirstAncestorOfClass("Model")
	local Humanoid = Model and Model:FindFirstChildOfClass("Humanoid")
	return Model,Humanoid
end

local player = game:GetService("Players").LocalPlayer -- player would be nil for seemingly no reason..?

-- Custom raycasting function to prevent specific objects from messing up targeting
function Targeting:CastRay(StartPos, Direction, Length)
	local _set = _G.BB.Settings
	local Settings = _set.Targeting
	
	local ref =  _G.BB.Modules.Callbacks.Targeting
	local Callback = ref and require(ref)
	
	local raycastParams = RaycastParams.new()
	raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
	raycastParams.FilterDescendantsInstances = Filtered
	raycastParams.IgnoreWater = true
	
	local RaycastResults = workspace:Raycast(StartPos,Direction * Length, raycastParams) 
		or {Position = StartPos + (Direction* Length)}
	
	local Hit = RaycastResults and RaycastResults.Instance
	local EndPos = RaycastResults and RaycastResults.Position
	
	if Hit then		
		local CallbackResult = Callback(Hit)
		
		if CallbackResult == false then
			
			-- Cast another ray
			table.insert(Filtered,Hit)
			return self:CastRay(EndPos, Direction, Length - ((StartPos - EndPos).magnitude))
		end
	end
	
	-- Return the hit and target position
	Filtered = {}
	
	--print("Hit:", Hit, "Position:", EndPos)
	return Hit,EndPos
end

-- Acquires world position of the mouse
function Targeting:Get3DPosition(X, Y, TouchTap)
	local Camera = workspace.CurrentCamera
	local MouseRay = Camera[(TouchTap and "Viewport" or "Screen") .. "PointToRay"](Camera, X, Y)
	local EndPos = MouseRay.Origin + MouseRay.Direction
	table.insert(Filtered, player.Character)
	local Direction = (EndPos - Camera.CFrame.Position).Unit
	return self:CastRay(Camera.CFrame.Position, Direction, 9950)
end

return Targeting]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXC997C0BE460D47F9AC7250E634905610">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Extrapolation</string>
								<string name="ScriptGuid">{2103C0ED-180B-4927-B817-EDE5F5772901}</string>
								<ProtectedString name="Source"><![CDATA[-- Created by Tyzone, modified by GloriedRage

local Extrapolation = {}
local Physics = game:GetService("PhysicsService")
local Debris = game:GetService("Debris")
local TweenService = game:GetService("TweenService")

local TickTimeStamps = { 
	0.4, 
	0.76, 
	1.084, 
	1.3756, 
	1.63804, 
	1.874236, 
	2.0868124, 
	2.27813116,
	2.450318044,
	2.6052862396, 
	2.74475761564, 
	2.870281854076, 
	2.9832536686684, 
	3.0849283018016 -- Looks like a wedge of cheese tbh
}

local InvalidClasses = {
	"Folder",
	"Model"
}

local LastUpdate = -10
local UpdateInterval = 1/6 -- in seconds

local LastRender = -10
local RenderInterval = 1/60 -- in seconds


local function validateTime(Now, Then, Interval, Update)
	local OutsideInterval = Now - Then > Interval
	if OutsideInterval then 
		if Update then
			LastUpdate = Now
		else
			LastRender = Now
		end
	end
	return OutsideInterval
end

local function getProjectileData(Projectile)
	local projectileType = Projectile.ProjectileType.Value
	local ID_array = {Projectile.ProjectileType.Value, Projectile.Count.Value}

	if not _G.BB.Settings.Extrapolation.Updates[projectileType] then
		return
	end

	if projectileType == "Superball" or projectileType == "Slingshot" or projectileType == "PaintballGun" then

		-- Send ID array, CFrame, and Velocity
		local PositionMag = (Projectile.CFrame.Position-Projectile.LastSentPosition.Value).Magnitude
		local VelocityMag = (Projectile.Velocity-Projectile.LastSentVelocity.Value).Magnitude
		
		if PositionMag > 1 or VelocityMag > 1 then

			Projectile.LastSentPosition.Value = Projectile.Position
			Projectile.LastSentVelocity.Value = Projectile.Velocity
			Projectile.LastSentTime.Value = time()

			return {ID_array, Projectile.Position, Projectile.Velocity, Projectile.LastSentTime.Value}
		end

	elseif projectileType == "Rocket" then

		local OriginPosition = Projectile.Origin.Value.Position
		local CurrentPosition = Projectile.Position
		local LastSentPosition = Projectile.LastSentPosition.Value
		local Distance = (CurrentPosition - OriginPosition).Magnitude
		local VelocityMag = (Projectile.Velocity-Projectile.LastSentVelocity.Value).Magnitude

		if (CurrentPosition - LastSentPosition).Magnitude > 1 or VelocityMag > 1 then

			Projectile.LastSentPosition.Value = CurrentPosition
			
			local array = {ID_array, Distance}
			
			-- only send if necessary
			--if _G.BB.Settings.Rocket.Speed ~= _G.BB.Settings.Rocket.InitialSpeed then
			--	table.insert(array, Projectile.Velocity)
			--end
			
			--if _G.BB.Settings.Extrapolation.PingCompensation.Rocket then
				
			--	-- physics replicator determines data based on position
			--	-- in sent array
			--	if #array == 2 then
			--		table.insert(array, Vector3.new(0,0,0))
			--	end
				
			--	table.insert(array, _G.BB.ServerTime.Value)
			--end

			return array
		end

	elseif projectileType == "Bomb" then
				
		local Now = tick()
		local TickDifference = Now - Projectile.LocalOriginTime.Value
		local PositionMag = (Projectile.CFrame.Position - Projectile.LastSentPosition.Value).Magnitude
		local VelocityMag = (Projectile.Velocity - Projectile.LastSentVelocity.Value).Magnitude

		if PositionMag > 1 or VelocityMag > .5 or TickDifference > .1 then
			
			Projectile.LastSentPosition.Value = Projectile.Position
			Projectile.LastSentVelocity.Value = Projectile.Velocity
			
			return {ID_array, Projectile.Position, Projectile.Velocity, TickDifference}
		end
	end
end

function Extrapolation:SendUpdateData()
	local PhysicsPacket = {}
		
	for _, Projectile in pairs(self.ClientActiveFolder:GetChildren()) do
		if not table.find(InvalidClasses, Projectile.ClassName) then
			
			if Projectile and Projectile.Active.Value then
				
				local ProjectileDataArray = getProjectileData(Projectile)

				if ProjectileDataArray then
					table.insert(PhysicsPacket, ProjectileDataArray)
				end
			end
		end
	end

	if #PhysicsPacket > 0 then
		self.UpdateRemote:FireServer(PhysicsPacket)
	end
end

-- Uses data from an added folder that contains physics values to replicate a projectile
function Extrapolation:Begin(PhysicsFolder)
	
	if PhysicsFolder:IsA("Model") then
		local CandidatePF = PhysicsFolder:FindFirstChild("PhysicsFolder")
		if CandidatePF then
			PhysicsFolder = CandidatePF
		else
			return
		end
	elseif not PhysicsFolder:IsA("Folder") then
		return
	end

	if not PhysicsFolder:WaitForChild("creator", 1/30) then
		warn("No creator value!")
		return
	end

	if not PhysicsFolder:FindFirstChild("ProjectileType") then
		warn("No projectile type!")
		return
	end

	local extrapProjectile
	local creator = PhysicsFolder.creator.Value
	
	local tickRender = nil
	
	if PhysicsFolder.ProjectileType.Value == "Superball" then

		-- Make new superball
		extrapProjectile = self.MakeSuperball(creator, "Superballs", nil, PhysicsFolder.RandomColor.Value)

		-- Update position upon value changed
		local latestPos = PhysicsFolder.LatestPosition
		latestPos.Changed:Connect(function()
			extrapProjectile.Position = latestPos.Value
		end)

		-- Update velocity upon value changed
		local latestVel = PhysicsFolder.LatestVelocity
		latestVel.Changed:Connect(function()
			extrapProjectile.Velocity = latestVel.Value
		end)
		
		-- Remove projectile upon inactivity
		local function checkActive()
			if PhysicsFolder.Active.Value == false then
				Debris:AddItem(extrapProjectile, 1)
			end
		end

		PhysicsFolder.Active.Changed:Connect(checkActive)

		-- Fire the superball!
		extrapProjectile.Position = latestPos.Value
		extrapProjectile.Velocity = latestVel.Value
		extrapProjectile.Parent = self.ExtrapolatedFolder

		extrapProjectile.Boing:Play()
		
		checkActive()

	elseif PhysicsFolder.ProjectileType.Value == "Slingshot" then
		extrapProjectile = self.MakePellet(creator, "Pellets")

		-- Update position upon value changed
		local latestPos = PhysicsFolder.LatestPosition
		latestPos.Changed:Connect(function()
			extrapProjectile.Position = latestPos.Value
		end)

		-- Update velocity upon value changed
		local latestVel = PhysicsFolder.LatestVelocity
		latestVel.Changed:Connect(function()
			extrapProjectile.Velocity = latestVel.Value
		end)
		
		-- Remove projectile upon inactivity
		local function checkActive()
			if PhysicsFolder.Active.Value == false then
				Debris:AddItem(extrapProjectile, 1)
			end
		end
		
		PhysicsFolder.Active.Changed:Connect(checkActive)
		
		-- Fire the pellet!
		extrapProjectile.Position = latestPos.Value
		extrapProjectile.Velocity = latestVel.Value
		extrapProjectile.Parent = self.ExtrapolatedFolder

		local Sound = extrapProjectile.SlingshotSounds:FindFirstChild(_G.BB.Local.SlingshotSound)
		if Sound then
			Sound.Parent = extrapProjectile
			Sound:Play()
		end
		
		checkActive()

	elseif PhysicsFolder.ProjectileType.Value == "PaintballGun" then
		extrapProjectile = self.MakePaintball(creator, "Paintballs", nil, PhysicsFolder.RandomColor.Value)
		
		-- Update position upon value changed
		local latestPos = PhysicsFolder.LatestPosition
		latestPos.Changed:Connect(function()
			extrapProjectile.Position = latestPos.Value
		end)

		-- Update velocity upon value changed
		local latestVel = PhysicsFolder.LatestVelocity
		latestVel.Changed:Connect(function()
			extrapProjectile.Velocity = latestVel.Value
		end)
		
		-- Explode paintball upon inactivity
		local function checkActive()
			if PhysicsFolder.Active.Value == false then
				self.Aesthetics:ExplodePaintball(extrapProjectile)
			end
		end
		
		PhysicsFolder.Active.Changed:Connect(checkActive)
		
		-- Fire the paintball!
		extrapProjectile.Position = latestPos.Value
		extrapProjectile.Velocity = latestVel.Value
		extrapProjectile.Parent = self.ExtrapolatedFolder

		checkActive()

	elseif PhysicsFolder.ProjectileType.Value == "Rocket" then
		
		extrapProjectile = self.MakeRocket(creator, nil, PhysicsFolder)
		
		local function determineOffset()
			local ClientTime = _G.BB.ServerTime.Value
			local ServerTime = PhysicsFolder.ServerTime.Value
			local SenderTime = PhysicsFolder.ClientTime.Value
			local TotalDelay = (ServerTime - SenderTime) + (ServerTime - ClientTime)
			local offset = TotalDelay * _G.BB.Settings.Rocket.Speed
			return offset
		end
		
		local origin = PhysicsFolder.Origin.Value
		local pingCompensation = _G.BB.Settings.Extrapolation.PingCompensation.Rocket and determineOffset()
		
		
		local progress = pingCompensation and (origin.lookVector * pingCompensation) or origin.lookVector
		local newCF = origin + progress

		extrapProjectile.CFrame = newCF

		local InitialVelocity = origin.lookVector * _G.BB.Settings.Rocket.InitialSpeed
		local Velocity = origin.lookVector * _G.BB.Settings.Rocket.Speed
		
		extrapProjectile.Velocity = InitialVelocity
		extrapProjectile.RocketVelocity.Velocity = InitialVelocity
		extrapProjectile.RocketVelocity.MaxForce = Vector3.new(1e9, 1e9, 1e9)
		
		local tweenInfo = TweenInfo.new(_G.BB.Settings.Rocket.RampUpDuration, Enum.EasingStyle.Linear)
		local tween = TweenService:Create(extrapProjectile.RocketVelocity, tweenInfo, {Velocity = Velocity})
		
		tween:Play()
		
		
		if _G.BB.Settings.RocketRiding and PhysicsFolder and not self.Kill:CanDamage(creator, self.Player.Character.Humanoid) then
			-- Can Collide true
			extrapProjectile.CanCollide = true

			Physics:SetPartCollisionGroup(extrapProjectile, "RideableRockets")

			-- Make dense
			local densityMultiplier = 140
			local OriginalProperties = PhysicalProperties.new(extrapProjectile.Material)
			extrapProjectile.CustomPhysicalProperties = PhysicalProperties.new(
				OriginalProperties.Density * densityMultiplier, OriginalProperties.Friction, OriginalProperties.Elasticity
			) -- SUPER dense so that you can actually ride the rocket

			--Adapt bodymovers to the new density
			extrapProjectile.Floater.Force *= densityMultiplier
			extrapProjectile.RocketVelocity.MaxForce *= densityMultiplier

			-- Make rigid
			local Part = Instance.new("Part")
			Part.Size = Vector3.new(.05,.05,.05)
			Part.Anchored = true
			Part.CanCollide = false
			Part.Position = PhysicsFolder.Origin.Value.Position - PhysicsFolder.Origin.Value.lookVector * 1000
			Part.CFrame = CFrame.new(Part.Position,Part.Position + extrapProjectile.CFrame.LookVector)
			Part.Parent = workspace

			local Attachment1 = Instance.new("Attachment")
			Attachment1.Name = "Goal"
			Attachment1.Parent = Part
			Attachment1.Axis = Vector3.new(0, 0, 1)

			local Attachment0 = Instance.new("Attachment")
			Attachment0.Name = "Rocket"
			Attachment0.Parent = extrapProjectile 
			Attachment0.Axis = Vector3.new(0, 0, 1)

			local Constraint = Instance.new("AlignOrientation")
			Constraint.RigidityEnabled = true
			Constraint.Attachment1 = Attachment1
			Constraint.Attachment0 = Attachment0
			Constraint.Parent = Part

			local Constraint = Instance.new("PrismaticConstraint")
			Constraint.Attachment1 = Attachment1
			Constraint.Attachment0 = Attachment0
			Constraint.Parent = Part

			Debris:AddItem(Part,10)
		end
		
		-- Update distance upon value changed
		-- Compensate for ping if settings dictate so
		local latestDistance = PhysicsFolder.LatestDistance
		latestDistance.Changed:Connect(function()
			local distance = latestDistance.Value

			if _G.BB.Settings.Extrapolation.PingCompensation.Rocket then
				distance += pingCompensation
			end

			local progress = origin.lookVector * distance
			local newCF = origin + progress

			extrapProjectile.CFrame = newCF
		end)
	
		-- Update velocity upon value changed
		--local latestVel = PhysicsFolder.LatestVelocity
		--latestVel.Changed:Connect(function()
		--	extrapProjectile.Velocity = latestVel.Value
		--end)
		
		-- Explode rocket upon inactivity
		local function checkActive()
			if PhysicsFolder.Active.Value == false then
				self.Explosion:ExtrapolateExplosion(extrapProjectile, PhysicsFolder)
			end
		end

		PhysicsFolder.Active.Changed:Connect(checkActive)
		
		extrapProjectile.Parent = self.ExtrapolatedFolder
		extrapProjectile.Swoosh:Play()
		
		checkActive()

	elseif PhysicsFolder.ProjectileType.Value == "Bomb" then
		
		extrapProjectile = self.MakeBomb(creator)
		
		local exploded = false

		-- Update position upon value changed
		local latestPos = PhysicsFolder.LatestPosition
		latestPos.Changed:Connect(function()
			extrapProjectile.Position = latestPos.Value
		end)
		
		-- Update velocity upon value changed
		local latestVel = PhysicsFolder.LatestVelocity
		latestVel.Changed:Connect(function()
			extrapProjectile.Velocity = latestVel.Value
		end)

		-- Explode bomb upon inactivity
		local function checkActive()
			if PhysicsFolder.Active.Value == false then
				exploded = true
				extrapProjectile.Position = latestPos.Value
				extrapProjectile.Velocity = latestVel.Value

				self.Explosion:ExtrapolateExplosion(extrapProjectile, PhysicsFolder)
			end
		end
		
		extrapProjectile.Position = latestPos.Value
		extrapProjectile.Velocity = latestVel.Value
		extrapProjectile.Parent = self.ExtrapolatedFolder

		--Play the first tick
		extrapProjectile.Tick:Stop()
		if not _G.BB.TrueMobile then
			extrapProjectile.Tick.TimePosition = 0.12
		end
		extrapProjectile.Tick:Play()
		
		-- Update last tick time value
		local latestTime = PhysicsFolder.LatestTime
		--local _tick = 1
		
		local function updateTick(dt)
			if exploded then
				if tickRender then
					tickRender:Disconnect()
				end
				return
			end
			
			-- Update last tick time value
			local receivedTime = PhysicsFolder.LatestTime.Value
			local lastTime = extrapProjectile.LastReceivedTime.Value
			if lastTime < receivedTime then
				extrapProjectile.LastReceivedTime.Value = receivedTime
			else
				extrapProjectile.LastReceivedTime.Value = lastTime + dt -- Default render speed
			end
			local updatedTime = extrapProjectile.LastReceivedTime.Value

			-- Update tick time
			local iTick = -1
			for i=1,14 do
				if lastTime<TickTimeStamps[i] and updatedTime>=TickTimeStamps[i] then
					iTick = i
					break
				elseif updatedTime<TickTimeStamps[i] then
					break
				end
			end

			-- Play tick sound and update color
			if iTick ~= -1 then
				extrapProjectile.Tick:Stop()

				if not _G.BB.TrueMobile then
					extrapProjectile.Tick.TimePosition = 0.12
				end

				extrapProjectile.Tick:Play()

				local Val = iTick%2

				if Val == 1 then
					extrapProjectile.Color = extrapProjectile.TickColor.Value
				else
					extrapProjectile.Color = extrapProjectile.BaseColor.Value
				end

				if iTick == 14 then
					extrapProjectile.Anchored = true
				end
			end
		end
		
		--latestTime.Changed:Connect(function(new)
		--	updateTick(new - extrapProjectile.LastReceivedTime.Value)
		--end)

		tickRender = game:GetService("RunService").RenderStepped:Connect(function(dt)
			updateTick(dt)
		end)
		
		PhysicsFolder.Active.Changed:Connect(checkActive)

		checkActive()
		
	elseif PhysicsFolder.ProjectileType.Value == "Wall" then
		
		-- Toggle trowel outlines
		local CF = PhysicsFolder.PlaceCFrame.Value
		local CT = PhysicsFolder.RandomColor.Value
		local wall = PhysicsFolder.Wall.Value
		
		for _,Brick in pairs(wall:GetChildren()) do
			
			local SB = Brick:FindFirstChildWhichIsA("SelectionBox")
			
			if SB then
				SB.Visible = _G.BB.Local.TrowelOutlines
			end
			
			self.Aesthetics:ApplyWallColors(Brick,CT)
		end
	end

	if not extrapProjectile then 
		--warn("Added physics folder has improper projectile type")
		return 
	end

	PhysicsFolder.AncestryChanged:Connect(function(_, newParent)
		if newParent == nil then
			Debris:AddItem(extrapProjectile, 0)
			if tickRender then
				tickRender:Disconnect()
			end
		end
	end)

	extrapProjectile.Parent = self.ExtrapolatedFolder
end


function Extrapolation:Init(Settings, Modules, Remotes, Player, ProjectileFolder)
	
	local objects = Player.PlayerScripts.ToolObjects
	
	self.Player = Player
	
	self.Aesthetics = require(Modules:WaitForChild("Aesthetics"))
	self.Explosion = require(Modules:WaitForChild("Explosion"))
	self.Kill = require(Modules:WaitForChild("Kill"))
	
	self.UpdateRemote = Remotes:WaitForChild("UpdatePhysics")

	self.MakeSuperball = require(objects:WaitForChild("MakeSuperball"))
	self.MakeRocket = require(objects:WaitForChild("MakeRocket"))
	self.MakeBomb = require(objects:WaitForChild("MakeBomb"))
	self.MakePellet = require(objects:WaitForChild("MakePellet"))
	self.MakePaintball = require(objects:WaitForChild("MakePaintball"))
	

	-- Folder that contains each player's various physics folders and projectiles
	self.ActiveFolder = ProjectileFolder:WaitForChild("Active")

	-- Folder that contains extrapolated projectiles (only visible to client)
	self.ExtrapolatedFolder = ProjectileFolder:WaitForChild("Extrapolated")

	-- Folder that contains client's active physics folders and projectiles
	self.ClientActiveFolder = self.ActiveFolder:WaitForChild(Player.Name)

	local function EvaluateFolder(Folder)
		-- Do not extrapolate own projectiles
		if not Folder:IsA("Folder") or Folder.Name == Player.Name then 
			return 
		end

		for _,Folder2 in pairs(Folder:GetChildren()) do
			self:Begin(Folder2)
		end

		Folder.ChildAdded:Connect(function(Folder3)
			self:Begin(Folder3)
		end)
	end	

	for _,Folder in pairs(self.ActiveFolder:GetChildren()) do
		EvaluateFolder(Folder)
	end

	self.ActiveFolder.ChildAdded:connect(EvaluateFolder)

	game:GetService("RunService").RenderStepped:connect(function(ElaspedTime)
		--Displace all extrapolated projectiles
		local Start = tick()

		if validateTime(Start, LastUpdate, UpdateInterval, true) then
			self:SendUpdateData()
		end
	end)
end

return Extrapolation]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXF782D056462D4FCA84CE3253B9F962C3">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">SuperballCollisions</string>
								<string name="ScriptGuid">{BE256938-CF2B-4C88-A122-C14A84DF7E31}</string>
								<ProtectedString name="Source"><![CDATA[-- Thegamboy
-- Handles superball collisions with local character
-- Used to regulate flying via colliding with superball (sb fly)

local CollectionService = game:GetService("CollectionService")
local Players = game:GetService("Players")

local Player = Players.LocalPlayer

local REGION_CORNER = Vector3.new(10, 10, 10)

return function(Humanoid)
	local char = Humanoid.Parent
	
	Humanoid.StateChanged:Connect(function(state)
		if state == Enum.HumanoidStateType.Landed then
			local headPos = char.Head.Position

			local superballs = workspace:FindPartsInRegion3WithWhiteList(
				Region3.new(headPos - REGION_CORNER, headPos + REGION_CORNER),
				CollectionService:GetTagged("Superball"),
				math.huge
			)

			local hitSuperball = false
			for _, superball in next, superballs do
				if not superball:FindFirstChild("creator") then continue end
				if superball.creator.Value ~= Player then continue end
				hitSuperball = true
			end

			if hitSuperball then
				return
			end

			if _G.BB then
				_G.BB.CanSBFly = true
			end
		end
	end)
end
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX3C0310EE0BE14D9EBEB40F2F2BB15659">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MakePellet</string>
							<string name="ScriptGuid">{43D6729D-4AAC-4851-BAD6-8FA4B8133E11}</string>
							<ProtectedString name="Source"><![CDATA[
local Collections = game:GetService("CollectionService")
local Physics = game:GetService("PhysicsService")
local Aesthetics = require(_G.BB.Modules:WaitForChild("Aesthetics"))

return function (Creator, CollisionGroup, count)
	
	local Folder, Theme = Aesthetics:GetThemeObject(Creator, "Slingshot")
	local Part = Folder:FindFirstChildWhichIsA("Part"):Clone()
	
	Part.Name = Creator.Name.."'s pellet"
	Part.CastShadow = true
	Part.Massless = false
	Part.Anchored = false
	Part.CanCollide = true
	Part.Size = Vector3.new(1, 1, 1)
	Part.Shape = Enum.PartType.Ball
	Part.BottomSurface = Enum.SurfaceType.Smooth
	Part.TopSurface = Enum.SurfaceType.Smooth
	Part.Color = Theme == "Team Color" and Creator.TeamColor.Color or Part.Color
	
	Aesthetics:HandleProjectileVisuals(Creator, Part)

	Collections:AddTag(Part,"Pellet")
	Collections:AddTag(Part,"Projectile")
	
	_G.BB.ClientObjects.Sounds.SlingshotSounds:Clone().Parent = Part

	local lastUpdateVel = Instance.new("Vector3Value")
	lastUpdateVel.Name = "LastSentVelocity"
	lastUpdateVel.Parent = Part

	local lastUpdateCFrame = Instance.new("Vector3Value")
	lastUpdateCFrame.Name = "LastSentPosition"
	lastUpdateCFrame.Parent = Part

	local lastSentTime = Instance.new("NumberValue")
	lastSentTime.Name = "LastSentTime"
	lastSentTime.Parent = Part

	local Damage = Instance.new("NumberValue")
	Damage.Name = "Damage"
	Damage.Value = _G.BB.Settings.Slingshot.Damage
	Damage.Parent = Part

	local Type = Instance.new("StringValue")
	Type.Name = "ProjectileType"
	Type.Value = "Slingshot"
	Type.Parent = Part

	local c = Instance.new("ObjectValue")
	c.Name = "creator"
	c.Value = Creator
	c.Parent = Part

	local active = Instance.new("BoolValue")
	active.Name = "Active"
	active.Value = true
	active.Parent = Part
	
	local Ready = Instance.new("BoolValue")
	Ready.Name = "Ready"
	Ready.Value = false
	Ready.Parent = Part
	
	if count then
		local countVal = Instance.new("NumberValue")
		countVal.Name = "Count"
		countVal.Value = count
		countVal.Parent = Part
	end
	
	if CollisionGroup then
		Physics:SetPartCollisionGroup(Part,CollisionGroup)
	end

	return Part
end
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX34421373B22C44ED86AC46DAE7A2A6C4">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MakePaintball</string>
							<string name="ScriptGuid">{30852B9F-BB64-45B2-8AE3-2979AAEF6A1A}</string>
							<ProtectedString name="Source"><![CDATA[
local Collections = game:GetService("CollectionService")
local Physics = game:GetService("PhysicsService")
local Aesthetics = require(_G.BB.Modules:WaitForChild("Aesthetics"))

return function(Creator, CollisionGroup, count, color)
	
	local Folder, Theme = Aesthetics:GetThemeObject(Creator, "PaintballGun")
	local Part = Folder:FindFirstChildWhichIsA("BasePart"):Clone()
	
	Physics:SetPartCollisionGroup(Part, "Paintballs")
	
	Part.Name = Creator.Name.."s Paintball"
	Part.CastShadow = true
	Part.Massless = false
	Part.Anchored = false
	Part.CanCollide = true
	Part.Size = _G.BB.Settings.PaintballGun.Size
	Part.BottomSurface = Enum.SurfaceType.Smooth
	Part.TopSurface = Enum.SurfaceType.Smooth
	
	if _G.BB.Settings.PaintballGun.Density ~= nil then 
		Part.CustomPhysicalProperties = PhysicalProperties.new(_G.BB.Settings.PaintballGun.Density, 0.3, 0.5)
	end
	
	if Part.ClassName == "Part" then -- rather than WedgePart or others
		Part.Shape = _G.BB.Settings.PaintballGun.Shape
	end
	
	if color then
		Part.Color = color
	else
		if _G.BB.Settings.Themes.RandomPaintballColors and Theme == "Normal" then
			Part.Color = Aesthetics:RandomColor()
		elseif Theme == "Team Color" then
			Part.Color = Creator.TeamColor.Color
		end
	end
	
	local Attachment0 = Instance.new("Attachment")
	Attachment0.Parent = Part
	
	local Force = Instance.new("VectorForce")
	Force.Force = _G.BB.Settings.PaintballGun.VectorForce
	Force.RelativeTo = Enum.ActuatorRelativeTo.World
	Force.Attachment0 = Attachment0
	Force.Parent = Part

	Collections:AddTag(Part, "Paintball")
	Collections:AddTag(Part, "Projectile")
	
	Aesthetics:HandleProjectileVisuals(Creator, Part)

	-- In order to remove the PhysicsFolder buffer, had to make the projectile
	-- the location of data storage.

	local lastUpdateVel = Instance.new("Vector3Value")
	lastUpdateVel.Name = "LastSentVelocity"
	lastUpdateVel.Parent = Part

	local lastUpdateCFrame = Instance.new("Vector3Value")
	lastUpdateCFrame.Name = "LastSentPosition"
	lastUpdateCFrame.Parent = Part

	local lastSentTime = Instance.new("NumberValue")
	lastSentTime.Name = "LastSentTime"
	lastSentTime.Parent = Part

	local Damage = Instance.new("NumberValue")
	Damage.Name = "Damage"
	Damage.Value = _G.BB.Settings.PaintballGun.Damage
	Damage.Parent = Part

	local Type = Instance.new("StringValue")
	Type.Name = "ProjectileType"
	Type.Value = "PaintballGun"
	Type.Parent = Part

	local c = Instance.new("ObjectValue")
	c.Name = "creator"
	c.Value = Creator
	c.Parent = Part

	local active = Instance.new("BoolValue")
	active.Name = "Active"
	active.Value = true
	active.Parent = Part
	
	local Ready = Instance.new("BoolValue")
	Ready.Name = "Ready"
	Ready.Value = false
	Ready.Parent = Part

	if count then
		local countVal = Instance.new("NumberValue")
		countVal.Name = "Count"
		countVal.Value = count
		countVal.Parent = Part
	end

	return Part
end

]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX70BFAA2A9C94404E810080571AA15C7F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">HandleCrosshair</string>
							<string name="ScriptGuid">{ED9136D0-C15B-4076-9082-EC242E24ECB3}</string>
							<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")
local Settings = _G.BB.Settings
local Player = Players.LocalPlayer
local Bindable = _G.BB.IconStateChanged
--[[
	Bindable params (fires with):
	1st param: "NoTools" = no tools equipped, 
			   "Equipped" = tool equipped, 
			   "Reloaded" = tool reloaded
	2nd: lastTime: the time() at which tool was last fired
	3rd: the reload time of the tool
	
	Notice how there is no firing when a tool is unequipped.
	This is because all cases are covered when any other tool
	is equipped or when a player unequips and no longer has a tool.
]]
local Mouse = Player:GetMouse()

return function(Tool)
	local Equipped = true
	local lastTime = 0
	
	local RELOAD_TIME = Settings[Tool.Name].ReloadTime
		
	local function ToggleCrosshair()
		if Equipped and Settings.NativeCrosshair then
			local NewIcon = (Tool.Enabled and "Regular" or "Reload") .. "Icon"
			Mouse.Icon = Settings.Targeting[NewIcon]
		end
	end
	
	local function isDead()
		local Character = Player.Character
		if (Character.Humanoid.Health<=0) or not Tool.Parent then
			Bindable:Fire("NoTools", lastTime, RELOAD_TIME)

			if Settings.NativeCrosshair then
				Mouse.Icon = Settings.Targeting.DefaultIcon
			end
			return true
		end;
		return false
	end
	
	Tool.Equipped:Connect(function()
		if not isDead() then
			Equipped = true
			Bindable:Fire("Equipped", lastTime, RELOAD_TIME)
			ToggleCrosshair()
		end
	end)
	
	Tool:GetPropertyChangedSignal("Enabled"):Connect(function()
		--local Character = Player.Character
		if not isDead() then
			local String = Tool.Enabled and "Reloaded" or "Fired"
			if String == "Fired" then
				lastTime = time()
			end
			Bindable:Fire("Reloaded", lastTime, RELOAD_TIME)

			ToggleCrosshair()
		end
	end)
	
	Tool.Unequipped:Connect(function()
		if not isDead() then
			Equipped = false
			if Settings.NativeCrosshair then
				Mouse.Icon = Settings.Targeting.DefaultIcon
			end
			task.wait()
			if (Player.Character ~= nil) 
				and (Player.Character:FindFirstChildWhichIsA("Tool")) then
				Bindable:Fire("NoTools", lastTime, RELOAD_TIME)
			end
		end
	end)
	
	Tool.AncestryChanged:Connect(function()
		local Character = Player.Character
		if (Character == nil) or (Character.Parent == nil)
			or (not (
				(Tool.Parent == Character) or 
					((Tool.Parent ~= nil) and (Tool.Parent:IsA("Backpack"))
					)
				)
			) then
			
			Equipped = false
			Bindable:Fire("NoTools", lastTime, RELOAD_TIME)

			if Settings.NativeCrosshair then
				Mouse.Icon = Settings.Targeting.DefaultIcon
			end
		end
	end)
end

]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXC348C97C8F684ADCAD79FE6A821FFD74">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MakeBomb</string>
							<string name="ScriptGuid">{DE13D41B-8ECD-4FC2-A7D2-D1CD3CA13473}</string>
							<ProtectedString name="Source"><![CDATA[local Collections = game:GetService("CollectionService")
local Aesthetics = require(_G.BB.Modules:WaitForChild("Aesthetics"))

-- Create the Rocket
return function(Creator, count)
	local Folder, Theme = Aesthetics:GetThemeObject(Creator, "Bomb")
	
	local Part = Folder:FindFirstChild("Base"):Clone()
	Collections:AddTag(Part,"Bomb")
	Part.Size = Vector3.new(2, 2, 2)
	Part.Shape = Enum.PartType.Ball
	Part.CastShadow = true
	Part.BottomSurface = Enum.SurfaceType.Smooth
	Part.TopSurface = Enum.SurfaceType.Smooth
	Part.Material = Enum.Material.Plastic
	Part.Massless = false
	Part.Anchored = false
	Part.CanCollide = true
	Part.CustomPhysicalProperties = _G.BB.Settings.Bomb.PhysicsProperties
	
	_G.BB.ClientObjects.Sounds.BombSounds.Boom:Clone().Parent = Part
	_G.BB.ClientObjects.Sounds.BombSounds.Tick:Clone().Parent = Part
	
	local Tick = Instance.new("Color3Value")
	Tick.Name = "TickColor"
	Tick.Value = Theme == "Team Color" and Creator.TeamColor.Color or Folder:FindFirstChild("TickColor").Value
	Tick.Parent = Part
	
	local Base = Instance.new("Color3Value")
	Base.Name = "BaseColor"
	Base.Value = Part.Color
	Base.Parent = Part
	
	local ld = Instance.new("Vector3Value")
	ld.Name = "LastSentPosition"
	ld.Parent = Part
	
	local rp = Instance.new("Vector3Value")
	rp.Name = "LatestPosition"
	rp.Parent = Part

	local lastUpdateVel = Instance.new("Vector3Value")
	lastUpdateVel.Name = "LastSentVelocity"
	lastUpdateVel.Parent = Part

	local realOT = Instance.new("NumberValue")
	realOT.Name = "LocalOriginTime"
	realOT.Value = tick()
	realOT.Parent = Part
	
	local lrt = Instance.new("NumberValue")
	lrt.Name = "LastReceivedTime"
	lrt.Value = 0
	lrt.Parent = Part
	
	local ActiveTag = Instance.new("BoolValue")
	ActiveTag.Name = "Active"
	ActiveTag.Value = true
	ActiveTag.Parent = Part
	
	local c = Instance.new("ObjectValue")
	c.Name = "creator"
	c.Value = Creator
	c.Parent = Part

	local AssignedTouch = Instance.new("BoolValue")
	AssignedTouch.Name = "BlownUpClient"
	AssignedTouch.Value = false
	AssignedTouch.Parent = Part
	
	local Type = Instance.new("StringValue")
	Type.Name = "ProjectileType"
	Type.Value = "Bomb"
	Type.Parent = Part
	
	local Ready = Instance.new("BoolValue")
	Ready.Name = "Ready"
	Ready.Value = false
	Ready.Parent = Part
	
	if count then
		local countVal = Instance.new("NumberValue")
		countVal.Name = "Count"
		countVal.Value = count
		countVal.Parent = Part
	end
	
	Part.Color = Tick.Value
	
	Part.Name = Creator.Name.."'s Bomb"
	return Part
end
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX5ACAD62B45AF4C798A962C28C35EAC2C">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">isInsideSomething</string>
							<string name="ScriptGuid">{CC784206-8070-463D-9232-3ED55555A14E}</string>
							<ProtectedString name="Source"><![CDATA[-- Thegameboy
-- Used in all projectile client scripts
-- Designed to stop shooting through bricks

local CORNER_MULTIPLIERS = {
	Vector3.new(-1, -1, 1),
	Vector3.new(1, -1, 1),
	Vector3.new(-1, -1, -1),
	Vector3.new(1, -1, -1),

	Vector3.new(-1, 1, 1),
	Vector3.new(1, 1, 1),
	Vector3.new(-1, 1, -1),
	Vector3.new(1, 1, -1),
}

local function getPoints(instance)
	local points = {}
	local CF = instance.CFrame
	local size = instance.Size

	for _, corner in next, CORNER_MULTIPLIERS do
		local point = CF:PointToWorldSpace(corner * (size / 2))
		table.insert(points, point)
	end

	return points
end

local function getFaces(instance)
	local faces = {}
	local CF = instance.CFrame
	local size = instance.Size

	for _, dir in next, Enum.NormalId:GetEnumItems() do
		local v = Vector3.fromNormalId(dir)
		local point = CF:PointToWorldSpace(v * (size / 2))
		table.insert(faces, {point = point, normal = CF:VectorToWorldSpace(v)})
	end

	return faces
end

function isAbove(point, planePoint, normal)
	local relative = point - planePoint
	return relative:Dot(normal) > 0 -- if point is above plane
end

local chars = {}
do
	local function onPlayerAdded(player)
		local function onCharacterAdded(char)
			table.insert(chars, char)
		end
		local function onCharacterRemoving(char)
			local index = table.find(chars, char)
			if index then
				table.remove(chars, index)
			end
		end

		local con1 = player.CharacterAdded:Connect(onCharacterAdded)
		local con2 = player.CharacterRemoving:Connect(onCharacterRemoving)
		if player.Character then
			onCharacterAdded(player.Character)
		end

		local con3
		con3 = player.AncestryChanged:Connect(function()
			con1:Disconnect()
			con2:Disconnect()
			con3:Disconnect()

			if player.Character then
				onCharacterRemoving(player.Character)
			end
		end)
	end

	game:GetService("Players").PlayerAdded:Connect(onPlayerAdded)
	for _, player in pairs(game:GetService("Players"):GetPlayers()) do
		onPlayerAdded(player)
	end
end

local SIZE = Vector3.new(0.1, 0.1, 0.1)
return function(instance, completelyInside)

	local ignore = {instance, unpack(chars)}
	local pos = instance.Position
	local parts = workspace:FindPartsInRegion3WithIgnoreList(Region3.new(pos - SIZE, pos + SIZE), ignore, 1)
	local points = getPoints(instance)

	if completelyInside then
		for _, part in next, parts do
			for _, face in next, getFaces(part) do
				for _, point in next, points do
					if isAbove(point, face.point, face.normal) then
						return false
					end
				end
			end
		end
		
		return #parts > 0
	end
	
	for _, part in next, parts do
		for _, face in next, getFaces(part) do
			for _, point in next, points do
				if not isAbove(point, face.point, face.normal) then
					return true
				end
			end
		end
	end
	
	return false
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX4F208E7F5B044B25B891AB5186540569">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Delete</string>
							<string name="ScriptGuid">{CDECAA09-3088-4CE1-B586-F479277E92E4}</string>
							<ProtectedString name="Source"><![CDATA[return function (Projectile, DelayTime)
	local DeleteRemote = _G.BB.Remotes:WaitForChild("Delete")

	if not Projectile.Parent then
		--warn("Projectile already deleted:", Projectile)
		return
	end
	
	local ID_array = {Projectile.ProjectileType.Value, Projectile.Count.Value}
	
	local function delete()
		if Projectile.Parent ~= nil and Projectile.Active.Value then
			--print("Sending deletion info for",Projectile,PhysicsFolder.ProjectileType.Value)
			if Projectile:FindFirstChild("Active") then
				Projectile.Active.Value = false
			end
			DeleteRemote:FireServer(ID_array)
			game:GetService("Debris"):AddItem(Projectile, 0)
		end
	end
	
	if DelayTime > 0 then
		task.delay(DelayTime, delete)
	else
		delete()
	end
end

]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX1557FB0028D84E159A04A8087EC220DF">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">Workspace</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBXF4DA3643FD444A8E9A71E0145B5B8A0F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">Projectiles</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX7E61B141F25E4FECB9DC978BE4AF9A99">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Active</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBX5653FA35AA58422DA0639127C462E5CC">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Buffers</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBX26457A8CC7BC44C78C16833F750E5F19">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Extrapolated</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX910D351A6A7F4E8883D15D12DE8B3137">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">StarterPlayer</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX1B0A58EA12F64CCF931BAB370B7AAC75">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">Buffers</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ObjectValue" referent="RBX94593E3C3F2847FFACDC50B8DD696D75">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Wall</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<Ref name="Value">null</Ref>
						</Properties>
					</Item>
				</Item>
				<Item class="BoolValue" referent="RBXCBF726CBACA540F9BD9BEDED3FFB87CE">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">CanDamage</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Value">true</bool>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX2657D88541A745A0B80B2B9ADE04091C">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">StarterGui</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="LocalScript" referent="RBXD1D58AE475284EB3B6B2AAD4C92E4104">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Checker</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{A21EDB47-AE6A-48E3-9D3B-3F181F3EC4C4}</string>
						<ProtectedString name="Source"><![CDATA[local Player = game.Players.LocalPlayer
local playerScripts = Player.PlayerScripts

local SPS = game:GetService("StarterPlayer") .StarterPlayerScripts
if not playerScripts:FindFirstChild("ToolObjects") then
	--warn("Player spawned without brick battle toolset core objects.")
	SPS:FindFirstChild("ToolObjects"):Clone().Parent = playerScripts
end
--if not Player:FindFirstChild("Buffers") then
--	StarterPlayer:WaitForChild("Buffers"):Clone().Parent = Player
--end
task.wait(1)
script:Destroy()]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="RBXE5511C323C034045A0783EE4D4167BC7">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">DefaultSettings</string>
				<string name="ScriptGuid">{56E11A94-57BD-4367-85C0-310E086B0D90}</string>
				<ProtectedString name="Source"><![CDATA[local function getCallback(Callback)
	return script:WaitForChild("Callbacks"):WaitForChild(Callback)
end
local Settings = {
	
	-- GENERAL WEAPON SETTINGS --
	BombJump = true,
	SuperballJump = true,
	SuperballFly = true,
	SlingClimb = false,
	RocketRiding = true,
	
	RocketsExplodeSBs = false,
	MaxSafeWait = 0.25,
	
	-- DAMAGE SETTINGS -- 
	WeaponsDamageAfterDeath = true, -- You will never be able to shoot after you die.
	InstantDamage = true, -- Does not pair well with security deactivations
	TeamKill = false, -- Whether teammates can kill eachother
	AllowHumanoidChanges = true, -- Prevents admin abuse and exploiting
	TagLifetime = 1,
	
	
	-- TEAM SETTINGS --
	AutoTeamColors = true, -- Color projectiles and explosions to team colors
	ThemeOverrides = true, -- themes will override team colors if above is true
	IgnoreCertainTeams = false,
	TeamsFiltered = {"Gladiators"}, -- "neutral" teams
	TeamsFilterType = false,
	SpectatorTeamActive = false,   -- Spectators can't take or deal dmg.
	SpectatorTeamName = "Spectators", -- The name of the spectator team
	
	
	-- THEME SETTINGS --
	Themes = {
		ThemePacks = {};
		RandomSuperballColors = true; -- This overrides the Superball Colors setting below.	
		RandomPaintballColors = true;
		RandomWallColors = true;
		TrailsOmitted = {"Normal"}; -- Add theme names for them to not have trails
		DefaultTheme = "Normal"; -- The default theme that all normal users have.
		TrailFilterType = true;
		WeaponsFiltered = {"Superball","PaintballGun","Sword"};
		UseRobloxExplosions = false;
	},
	
	
	-- DOOMSPIRE SETTINGS --
	Doomspire = {
		SlingFly = true;
		RocketCollisions = true;
		BombSpawnToCam = false;
	},
	
	
	-- EXPLOSION SETTINGS --
	Explosions = {
		DestroyParts = false;
		DestroyTrowelWallsOverride = false; --If true, overrides Explosions.DestroyParts
		FlingParts = true;
		FlingBombs = true;
		FlingEnemies = true; -- will fling others' dead body parts
		FlingYou = true; -- Will fling your body parts!
		ForceFactorOnSelf = 1; --How much stronger ExplosionForces are on yourself
		LimbRemoval = true;
		ProtectTeammateWalls = false; -- won't be able to blow ur teammates walls
		ExclusionTag = "BB_NonExplodable"; -- collection service
		DebrisTime = 0; -- must be >0 for parts to be added to debris collection
	},
	
	
	-- RICOCHET SETTINGS --
	Ricochet = {
		HalfDamageDelay = 0, -- min is one frame
		ResetStateDelay = 1/30
	},
	
	
	-- TARGETING SETTINGS --
	Targeting = { -- whitelist has priority over blacklist
		RegularIcon = "rbxassetid://507449825";
		ReloadIcon = "rbxassetid://507449806";
		DefaultIcon = "";
	},
	
	
	-- MOBILE SETTINGS --
	Mobile = {
		DoubleJumpToSwordLunge = true;
		ShootMode = "InWorld"; 
		--[[ 
		Can be "InWorld" or "UserInput", case-sensitive
			
			What's the difference?
			
			- UserInput triggers weapons at any tap other than the jump button and 
			some GUI buttons.It has no input delay.
			
			- InWorld does not trigger weapons at taps on GUIs or the joystick, but it is
			slightly delayed.
		]]
	},
	
	
	-- EXTRAPOLATION SETTINGS --
	Extrapolation = {
		Updates = { -- send regular updates about the object's position and velocity
			Slingshot = false;
			PaintballGun = false;
			Superball = true;
			Rocket = false;
			Bomb = true;
		},
		PingCompensation = {
			Rocket = false;
		}
	},
	
	
	-- SPECIFIC WEAPON SETTINGS -- 
	Bomb = {
		Damage = 101;
		ReloadTime = 5;
		BombJumpReloadTime = 0;
		MaxBombJumpPower = 200; -- in studs
		BombJumpPosWindow = .25; -- click then jump timing, must be positive
		BombJumpNegWindow = -.1; -- jump then click window, must be negative
		--TODO switch these two
		--VariableBombJumpPower = true; --Bomb jump height depends on your timing.
		BombJumpPowerFormula = "Linear";
		WalkingBombJump = false; -- if you can bomb jump as you walk
		PhysicsProperties = PhysicalProperties.new(
			0.7, -- Density
			0.3, -- Friction
			0.6, -- Elasticity
			1,   -- Friction weight
			1.1  -- Elasticity weight
		);
		MaxMassToDestroy = 150;
		ExplosionForce = 1000000;
		SelfDamage = false;
		TeleportOnExplode = false; -- Gameboy...
		Radius = 12;
		TouchExplode = false;
		TouchExplodeSelf = false; 
		DespawnTime = 5; -- despawns after x seconds
	},
	Rocket = {
		Damage = 101;
		ReloadTime = 7;
		SpawnDistance = 6; -- increase to 6+ to shoot through walls
		InitialSpeed = 60;
		Speed = 60;
		RampUpDuration = 1;
		SelfDamage = false;
		--FlyThroughList = {
		--	"rocket",
		--	"handle",
		--	"effect",
		--	"water",
		--	"lava",
		--	"invisitouch",
		--	"explosion",
		--	"killbrick"
		--};
		ExplosionForce = 500000;
		MaxMassToDestroy = 75;
		Radius = 4;
		ShootInsideBricks = true;
		DespawnTime = 10; -- despawns after x seconds
	},
	Slingshot = {
		Damage = 16;
		ReloadTime = 0.2;
		SpawnDistance = 3; -- increase to 4+ to shoot  through walls --Default 3
		Speed = 85;
		SelfDamage = false; -- (not recommended) if SelfKill == false will not deal self dmg
		Automatic = true;
		SlingFlyCooldown = 0;
		RicochetDamage = true;
		ShootInsideBricks = true;
		DespawnTime = 7; -- despawns after x seconds
	},
	Superball = {
		Damage = 55;
		ReloadTime = 2;
		SpawnDistance = 4; -- increase to 5+ shoot through walls
		Speed = 200;
		SelfDamage = false; -- (not recommended) if SelfKill == false will not deal self dmg
		RicochetDamage = true;
		ShootInsideBricks = true;	
		DespawnTime = 10; -- despawns after x seconds
	},
	Sword = {
		LungeDamage = 30;
		SlashDamage = 10;
		IdleDamage = 5;
		ReloadTime = 0.01;
		DoubleClickTime = 0.2; -- lunge window
		FloatAmount = 5000;
		JumpHeight = 13;
		LungeDelayTime = 0;
		LungeExtensionTime = .95;
	},
	Trowel = {
		ReloadTime = 4;
		BrickSize = Vector3.new(4, 1.2, 2.02);
		ServerBuildSpeed = 0.045;
		ClientBuildSpeed = 0.04;
		BricksPerColumn = 4;
		BricksPerRow = 3;
		Lifetime = 24.54;
		Outlines = false--true; -- the local setting will be overriden by this
	},
	PaintballGun = {
		Damage = 20;
		ReloadTime = .5;
		SpawnDistance = 3; -- increase to 5+ shoot through walls
		Speed = 200;
		SelfDamage = false; -- (not recommended) if SelfKill == false will not deal self dmg
		VectorForce = Vector3.new(0, 60, 0);
		Shape = "Ball",
		Size = Vector3.new(1, 1, 1),
		Density = 0.7,
		DespawnTime = 10; -- despawns after x seconds
		MultiplierPartNames = {
			Head = true,
			Torso = true,
			UpperTorso = true,
			LowerTorso = true,
			HumanoidRootPart = true
		};
		ShootInsideBricks = true;
		ColorResetTime = 25; -- set to 0 for no color resetting
	},
	
	
	-- CHOOSE WEAPONS --
	WeaponsFiltered = {},
	WeaponsFilterType = false,
	CustomWeaponsDirectory = nil, -- can be game.ServerStorage.Weapons, for example
	
	
	-- SECURIY SETTINGS --
	Security = {
		-- Numbers are thresholds that, if surpassed, will deactivate projectile 
		--(cause no dmg and stop replication)
		Master = true, -- If set to false, will have no security logs or repercussions
		Webhook = nil, -- Change to a string of your Discord webhook URL to notify if someone was marked as exploiting
		Initial = { -- Spawn positions and velocities
			Deactivate = true; -- No possible damage and stop replication
			Warn = true; -- Warn in output
			Superball2D = 10; -- (SpawnPosition - Head.Position).Magnitude | X and Z axes
			Superball3D = 50; -- (SpawnPosition - Head.Position).Magnitude
			Rocket2D = 10; -- (SpawnPosition - Handle.Position).Magnitude | X and Z axes
			Rocket3D = 50; -- (SpawnPosition - Handle.Position).Magnitude 
			PaintballGun2D = 10;
			PaintballGun3D = 50;
			Bomb3D = 10;	
		},
		Update = { -- Physics updates sent from each client on regular intervals
			Deactivate = true; -- No possible damage and stop replication
			Warn = true; 
			Rocket = 75; -- NewDistanceFromOrigin-OldDistanceFromOrigin
			Bomb = 100; -- (UpdatePosition - CurrentPosition).Magnitude
			BombVelocity = 500; -- (UpdateVelocity - CurrentVelocity).Magnitude
			BombTime = .5; -- NewTime-OldTime+ DT
		},
		Hit = { -- Either when projectile explodes or hits humanoid (depending on type)
			Deactivate = true; -- No possible damage and stop replication
			Warn = true;
			RocketExplode = 75; -- ExplosionDistanceFromOrigin-OldDistanceFromOrigin
			BombExplode = 30; -- (ExplosionPos - PriorPosition).Magnitude
			BombTime = 2.8;
			SuperballHit = 100; -- (HitCharPart.Position-Superball.Position).Magnitude
			RadiusMultiplier = 5; -- (ExplosionPos-HitPos).Magnitude > RadiusMultiplier*Radius
			MaxSwordKillDistance = 12;

		},
		VerifyParabola = true;
		Fallout = {
			Slingshot = 0.2;
			Superball= 0.25;
			PaintballGun = 0.1;
		},
		PSPV = true; -- Hitbox verification
		FuturePositionApproval = true;
		Ricochet = true; -- secure ricochet damage
		AllowedTime = .2;
		AcceptableDistance = .5;
		ReloadTimeMultiplier = .7 --[[
			ServerReloadCheck = Tool.ReloadTime * ReloadTimeMultiplier
			if TimeSinceLastFire>=ServerReloadCheck then
		]]
	},
	
	
	-- LOCAL MISC SETTINGS --
	LocalSettingsDefaults = { -- mostly aesthetic
		NewIcons = false;
		MobileJump = true;
		SlingshotSound = "Modern";
		RocketExplosion = "Classic";
		BombExplosion = "Modern";
		Hit = "Minecraft"; -- None for no sound
		BlockedHit = "Tyzone";
		KillHit = "Robot"; -- NOT ACTIVE AT THE MOMENT
		Themes = true;
		ThemesHighGraphics = true;
		VisualHitIndicators = true;
	},
	
	
	-- DEVELOPER SETTINGS -- 
	NativeCrosshair = true,
	
	
	-- Callbacks must simply point to a module that returns a function
	Callbacks = {
		PaintballColor = getCallback("PaintballColor"),
		RocketExplode = getCallback("RocketExplode"),
		Targeting = getCallback("Targeting"),
		BreakJoints = getCallback("BreakJoints"),
		ExplodeMaster = getCallback("ExplosionMaster")
	}
}
return Settings

]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX1C716814E6EB4332854350257E2827CC">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ModifiableSettingsArrays</string>
					<string name="ScriptGuid">{22181126-5080-441A-A8A4-3556B7C80BEE}</string>
					<ProtectedString name="Source"><![CDATA[return { -- If you do not know what this does, ask GFink
	TeamsFiltered = "string",
	WeaponsFiltered = "string",
	Themes = {ThemePacks = "Instance", WeaponsFiltered = "string"}
}]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBX392260EBCECE44219AEA6627FC6C30C3">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">Callbacks</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXE189300E59D043C6AAD1D63B07024573">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">RocketExplode</string>
						<string name="ScriptGuid">{EE3F9B12-3FB3-4E7E-B547-BB20F4BC44A2}</string>
						<ProtectedString name="Source"><![CDATA[--!strict
return function(Hit: BasePart): boolean
	if game:GetService("CollectionService"):HasTag(Hit, "Projectile") then
		return false
		--return string.find(Hit.Name, "Pellet") ~= nil
	else
		local CharacterModel = Hit:FindFirstAncestorOfClass("Model")
		if CharacterModel and CharacterModel:FindFirstChildOfClass("Humanoid") then
			return Hit.Parent == CharacterModel
		else
			return Hit.CanCollide
		end
	end
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX00EFD207BF4C415283DDE8B31B9B41EC">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Targeting</string>
						<string name="ScriptGuid">{3C829586-1A2E-494E-9138-238645C99930}</string>
						<ProtectedString name="Source"><![CDATA[return function(Hit)
	return Hit.Parent:FindFirstChildWhichIsA("Humanoid") 
		or (
			not Hit.Parent:IsA("Accoutrement") 
			and Hit.CanCollide
			and (Hit.Transparency <= 0.9)
			and not game:GetService("CollectionService"):HasTag(Hit, "Projectile")
		)
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX033B843C12E7474DB8031776F026116E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ExplosionMaster</string>
						<string name="ScriptGuid">{C9489B76-8E2D-4E18-BF75-CDCBF999174F}</string>
						<ProtectedString name="Source"><![CDATA[local MaxFlingMass = 500 -- wil not attempt to fling larger parts

return function(HitPart, Creator)
	return HitPart.Mass < MaxFlingMass
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF680611CEC5042E68DDED31C5B3F7578">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PaintballColor</string>
						<string name="ScriptGuid">{0FF410C3-3228-423F-AF15-EDFEF2ECBEBC}</string>
						<ProtectedString name="Source"><![CDATA[return function(HitPart, Creator)
	return HitPart:GetMass() < 240 and not HitPart:IsDescendantOf(Creator.Character) -- and not HitPart.Anchored
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX637D59FD24AF49BCBE27D64D17DFB444">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">BreakJoints</string>
						<string name="ScriptGuid">{36D816A1-CDA5-40F0-9248-EEA0AABDA89E}</string>
						<ProtectedString name="Source"><![CDATA[return function(HitPart, Creator)
	return true
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Model" referent="RBX58B213F91DAF4FDCB09A48BA6FF2D1B6">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<token name="LevelOfDetail">0</token>
				<CoordinateFrame name="ModelMeshCFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
				<Vector3 name="ModelMeshSize">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="ModelStreamingMode">0</token>
				<string name="Name">SecurityDummy</string>
				<bool name="NeedsPivotMigration">false</bool>
				<Ref name="PrimaryPart">RBX1D7E0161FD7F442988723BFC843D7E54</Ref>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<OptionalCoordinateFrame name="WorldPivotData"></OptionalCoordinateFrame>
			</Properties>
			<Item class="Part" referent="RBX1D7E0161FD7F442988723BFC843D7E54">
				<Properties>
					<bool name="Anchored">true</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">4</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-273.131836</X>
						<Y>-24.3704491</Y>
						<Z>72.2736588</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">false</bool>
					<bool name="CanQuery">true</bool>
					<bool name="CanTouch">true</bool>
					<bool name="CastShadow">true</bool>
					<string name="CollisionGroup">Default</string>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4294901760</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">7</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="MaterialVariantSerialized"></string>
					<string name="Name">Head</string>
					<CoordinateFrame name="PivotOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">1</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>2</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
				<Item class="BodyAngularVelocity" referent="RBX7671D43B1E1A4101BFDECC049C7624F6">
					<Properties>
						<Vector3 name="AngularVelocity">
							<X>0</X>
							<Y>2</Y>
							<Z>0</Z>
						</Vector3>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Vector3 name="MaxTorque">
							<X>4000</X>
							<Y>4000</Y>
							<Z>4000</Z>
						</Vector3>
						<string name="Name">BodyAngularVelocity</string>
						<float name="P">1250</float>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBX1DB0FA23B48D472D82474DA705A09B1B">
				<Properties>
					<bool name="Anchored">true</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">4</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-273.131836</X>
						<Y>-25.8704643</Y>
						<Z>72.2736588</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">false</bool>
					<bool name="CanQuery">true</bool>
					<bool name="CanTouch">true</bool>
					<bool name="CastShadow">true</bool>
					<string name="CollisionGroup">Default</string>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4294901760</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">0</float>
					<float name="LeftParamB">0</float>
					<token name="LeftSurface">2</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="MaterialVariantSerialized"></string>
					<string name="Name">Torso</string>
					<CoordinateFrame name="PivotOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<float name="Reflectance">0</float>
					<float name="RightParamA">0</float>
					<float name="RightParamB">0</float>
					<token name="RightSurface">2</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">3</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">1</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>2</X>
						<Y>2</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="Part" referent="RBXD5E086729832407A928702F9DD915A56">
				<Properties>
					<bool name="Anchored">true</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">4</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-274.631836</X>
						<Y>-25.8704643</Y>
						<Z>72.2736588</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">false</bool>
					<bool name="CanQuery">true</bool>
					<bool name="CanTouch">true</bool>
					<bool name="CastShadow">true</bool>
					<string name="CollisionGroup">Default</string>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4294901760</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="MaterialVariantSerialized"></string>
					<string name="Name">Left Arm</string>
					<CoordinateFrame name="PivotOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">3</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">1</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1</X>
						<Y>2</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="Part" referent="RBX6963F62DE13A4EF280CA97711B0A8CE9">
				<Properties>
					<bool name="Anchored">true</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">4</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-271.631836</X>
						<Y>-25.8704643</Y>
						<Z>72.2736588</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">false</bool>
					<bool name="CanQuery">true</bool>
					<bool name="CanTouch">true</bool>
					<bool name="CastShadow">true</bool>
					<string name="CollisionGroup">Default</string>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4294901760</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="MaterialVariantSerialized"></string>
					<string name="Name">Right Arm</string>
					<CoordinateFrame name="PivotOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">3</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">1</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1</X>
						<Y>2</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="Part" referent="RBX098909B3476E4A699D19838267E503FC">
				<Properties>
					<bool name="Anchored">true</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-273.631836</X>
						<Y>-27.8704643</Y>
						<Z>72.2736588</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">false</bool>
					<bool name="CanQuery">true</bool>
					<bool name="CanTouch">true</bool>
					<bool name="CastShadow">true</bool>
					<string name="CollisionGroup">Default</string>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4294901760</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="MaterialVariantSerialized"></string>
					<string name="Name">Left Leg</string>
					<CoordinateFrame name="PivotOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">3</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">1</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1</X>
						<Y>2</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="Part" referent="RBXF3F532B7A4E64DFAA5E5EEB588E3EF34">
				<Properties>
					<bool name="Anchored">true</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-272.631836</X>
						<Y>-27.8704643</Y>
						<Z>72.2736588</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">false</bool>
					<bool name="CanQuery">true</bool>
					<bool name="CanTouch">true</bool>
					<bool name="CastShadow">true</bool>
					<string name="CollisionGroup">Default</string>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4294901760</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="MaterialVariantSerialized"></string>
					<string name="Name">Right Leg</string>
					<CoordinateFrame name="PivotOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">3</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">1</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1</X>
						<Y>2</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="Part" referent="RBX51A605DB77794E52991C58E848EC9AD6">
				<Properties>
					<bool name="Anchored">true</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">4</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-273.131836</X>
						<Y>-25.8704643</Y>
						<Z>72.2736588</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">false</bool>
					<bool name="CanQuery">true</bool>
					<bool name="CanTouch">true</bool>
					<bool name="CastShadow">true</bool>
					<string name="CollisionGroup">Default</string>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4294901760</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">0</float>
					<float name="LeftParamB">0</float>
					<token name="LeftSurface">2</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="MaterialVariantSerialized"></string>
					<string name="Name">HumanoidRootPart</string>
					<CoordinateFrame name="PivotOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<float name="Reflectance">0</float>
					<float name="RightParamA">0</float>
					<float name="RightParamB">0</float>
					<token name="RightSurface">2</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">3</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">1</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>2</X>
						<Y>2</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="RBX75B99463AC08451B8B30A64822EF564E">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">CustomPhysicsReplicator</string>
				<string name="ScriptGuid">{A2D4B8CF-685C-46E1-9A08-D15540986B44}</string>
				<ProtectedString name="Source"><![CDATA[local CustomPhysicsReplicator = {}

function CustomPhysicsReplicator:Init(Remotes, Modules)
	
	local Settings = _G.BB.Settings
	local UpdateSet = Settings.Security.Update
	
	local Security = require(_G.BB.Modules.Security)

	local UpdateRemote = Remotes:WaitForChild("UpdatePhysics")
	local Delete = Remotes:WaitForChild("Delete")

	UpdateRemote.OnServerEvent:Connect(function(RemoteSender, PlayerProjectilePhysicsData)
		for _,InfoArray in pairs(PlayerProjectilePhysicsData) do
			--[[
				InfoArray = {
					PhysicsFolder,
					Projectile CFrame, (or distance)
					Projectile Velocity,
					Projectile Time
				}
			]]
			
			local ID_array = InfoArray[1]
			local PhysicsFolder = Security:GetPhysicsFolder(ID_array, RemoteSender, true)

			if not PhysicsFolder then
				return
			end
			
			local ProjectileType = PhysicsFolder.ProjectileType.Value
		
			local LastUpdateTick = PhysicsFolder.LastUpdateTick.Value
			
			local Now = tick()
			local DeltaTime = LastUpdateTick and Now - LastUpdateTick or 0
			PhysicsFolder.LastUpdateTick.Value = Now
			
			if not Security:ApproveUpdate(PhysicsFolder, InfoArray, UpdateSet, DeltaTime) then
				return
			end
			
			if ProjectileType == "Rocket" then
				
				--local clientTime = InfoArray[4]
				--local serverTime = _G.BB.ServerTime.Value

				--if _G.BB.Settings.Extrapolation.PingCompensation.Rocket and clientTime then
				--	PhysicsFolder.ServerTime.Value = serverTime
				--	PhysicsFolder.ClientTime.Value = clientTime
				--end

				PhysicsFolder.LatestDistance.Value = InfoArray[2]

				-- No reason to replicate if no change.
				--if _G.BB.Settings.Rocket.Speed ~= _G.BB.Settings.Rocket.InitialSpeed then
				--	LatestVelocity.Value = NewVelocity
				--end
				
			else
				PhysicsFolder.LatestPosition.Value = InfoArray[2]
				PhysicsFolder.LatestVelocity.Value = InfoArray[3]
				PhysicsFolder.LatestTime.Value = InfoArray[4]
			end
			
		end
	end)
	
	Delete.OnServerEvent:Connect(function(RemoteSender, array)
		local PhysicsFolder = _G.BB.ProjectileFolder.Active[RemoteSender.Name]:FindFirstChild(array[1]..array[2])
		if not PhysicsFolder or not PhysicsFolder.Parent then
			--warn("No physics folder sent from "..RemoteSender.Name.."!", array)
			return
		end
		
		if RemoteSender == PhysicsFolder.creator.Value then
			task.wait(.1)
			--print("making inactive", PhysicsFolder)
			PhysicsFolder.Active.Value = false
		end		
	end)
end

return CustomPhysicsReplicator]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXA4CAA21A3F424E24AD62B699B20FD2B1">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">LoadPlayerModules</string>
				<string name="ScriptGuid">{B0731093-51D2-4CB7-879B-B92DEAB17FD6}</string>
				<ProtectedString name="Source"><![CDATA[local PlayersService = game:GetService("Players")

local function ApplyFunctionToAll(Function)
	for _,Player in pairs(PlayersService:GetPlayers()) do
		coroutine.wrap(Function)(Player)
		-- If the function has a yield, we don't want every player to have to wait in line for their function call. coroutine.wrap fixes this.
	end
end

return function(PlayerAddedFunction, PlayerRemovingFunction, CharacterAddedFunction)
	-- PlayerAddedFunction = function that we want to run on all joining or existing players
	-- function(Player)
	-- PlayerRemovingFunction = function that want to run on all leaving players
	-- function(Player)
	-- CharacterAddedFunction = function we want to run on all spawning or existing characters
	-- function(Player, Character)

	local AddConnection, RemoveConnection, CharacterConnections
	-- We also want to return 3 things (even though they will likely never need to be used)
	-- 1. RBXScriptConnection
	-- For the PlayerAdded event
	-- 2. RBXScriptConnection
	-- For the PlayerRemoving event/game::BindToClose function
	-- 3. Table of RBXScriptConnections
	-- For each player's CharacterAdded event
			--[[
			{
				[game.Players.GFink] = game.Players.GFink.CharacterAdded:Connect(etc)
				[game.Players.tyzone] = game.Players.tyzone.CharacterAdded:Connect(etc)
			}
			]]

	if PlayerAddedFunction then
		AddConnection = PlayersService.PlayerAdded:Connect(PlayerAddedFunction) -- Joining players
		ApplyFunctionToAll(PlayerAddedFunction) -- Existing players
	end

	if PlayerRemovingFunction then
		local Left = {}
		-- The "Left" table represents the table of Player instances who have already left.
		-- This is to make sure that only a single instance of the PlayerRemovingFunction is run, rather than being run by both the PlayerRemoving event and the game::BindToClose function
		local function RunCheck(Player)
			--[[
				We check if this player's PlayerRemovingFunction has already been run by either PlayerRemoving or ApplyFunctionToAll.
				Again, this prevents the PlayerRemovingFunction from being run twice when the last player leaves, or if the server crashes.
				Note that before making this checker function, I never actually ran into this issue while testing using data stores
				(can't test with basic print statements because the output cannot be read while the game is being closed). It's just here 
				to make absolute sure the issue never pops up, and it would also annoy me if it wasn't here. ]]
			if not Left[Player] then -- We use the player's instance rather than their UserId so rejoining doesn't break things
				Left[Player] = true
				PlayerRemovingFunction(Player)
			end
		end
		RemoveConnection = PlayersService.PlayerRemoving:Connect(RunCheck)
		if game:GetService("RunService"):IsServer() then -- If you're requiring the module from the ID, this will never be false.
			-- The module could technically have been required by the client if the module itself was reparented somehow(?)
			-- Hopefully Roblox adds this functionality somehow. See the forum post I made about NOT being able to do this: https://devforum.roblox.com/t/note-to-myself/835748
			game:BindToClose(
				function()
					if RemoveConnection.Connected == true then 
						-- Can't "UnbindFromClose", so this is the next-best thing
						-- Why would anyone disconnect that connection on the server anyway? 
						-- Again, it would just annoy me if this wasn't here.
						ApplyFunctionToAll(RunCheck)
					end
				end
			)
		end
	end

	if CharacterAddedFunction then 
		--[[ 
			Optional third argument per a friend's request. Personally I don't have a use for it because I'm either yielding for 
			information gathered from within the PlayerAddedFunction, or I'm using the CharacterAppearanceLoaded listener instead. ]]
		CharacterConnections = {}
		local function DefaultPlayerAdded(Player)
			CharacterConnections[Player] = Player.CharacterAdded:Connect(
				function(Character)
					CharacterAddedFunction(Player, Character)
				end
			)
			-- Don't have to worry about disconnecting prior connections that may exist at this Player index from prior joins to the same server, because
			-- 1. Previous player instances are completely separate instances from new player instances, even if it's the same user, so it would not occupy the same index anyway.
			-- Using something like Player.UserId or Player.Name would be a different story.
			-- 2. Connections to players who have left are automatically disconnected anyway since the player instance gets destroyed automatically when the user leaves.
			-- RBXScriptConnections are disconnected when the instance it's listening on is destroyed
			local ExistingCharacter = Player.Character
			if ExistingCharacter then -- Only run the CharacterAddedFunction on the existing character IF that character exists
				CharacterAddedFunction(Player, ExistingCharacter)
			end
		end
		PlayersService.PlayerAdded:Connect(DefaultPlayerAdded)
		ApplyFunctionToAll(DefaultPlayerAdded)
	end
	return AddConnection, RemoveConnection, CharacterConnections
	-- If you decide to disconnect all CharacterConnections, this still leaves the door open for players who haven't joined yet to have active CharacterAdded connections.
	-- To solve this, consider a bool value "ListenForCharacterAdded" you make false when you intend to disconnect all CharacterAdded functions. Using this module, you would write your code like this:
	--[[
		local CharacterConnections
		
		function OnCharacterAdded(Player, Character)
			if ListenForCharacterAdded == false then
				return CharacterConnections[Player]:Disconnect()
				-- Ends the OnCharacterAdded function right here while also disconnecting the CharacterAdded connection from running it in the future
			end
			-- Here would be all your code that usually runs when a character is added
		end
		
		_, _, CharacterConnections = require(ThisModule)(
			nil, -- PlayerAddedFunction
			nil, -- PlayerRemovingFunction
			OnCharacterAdded
		)
	]]
	-- Again I'm not really sure what the use of this would be, but it's there nonetheless.
end]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX1C452121ED90451DA1B896C4AF0EB8D7">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">DistributeObjects</string>
				<string name="ScriptGuid">{76889935-FBB6-4723-9016-F965E9EC519C}</string>
				<ProtectedString name="Source"><![CDATA[local LoadContents = require(script.LoadContents)

return function(ContainingDirectory)
	for _,ServiceFolder in pairs(ContainingDirectory:GetChildren()) do
		local Success, RespectiveService = pcall(game.GetService, game, ServiceFolder.Name)
		LoadContents(Success and RespectiveService, ServiceFolder)
	end
end]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX1E25DBE2FD984EB6AE6AE0E0318C0F03">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">LoadContents</string>
					<string name="ScriptGuid">{68E90AEB-E2CB-47A2-9C04-0B2EA1301C7E}</string>
					<ProtectedString name="Source"><![CDATA[local function LoadContents(Service,Folder)
	if Service and typeof(Service)=="Instance" then
		for _,Item in pairs(Folder:GetChildren()) do
			Item.Parent = Service
		end
	else
--		local SPService=game:GetService("StarterPlayer"):FindFirstChildWhichIsA(Folder.Name)
--		if SPService then
--			-- This conditional is to prevent infinite recursion
--			return LoadContents(SPService,Folder)
--		end 
		local SubService = game:FindFirstChildWhichIsA(Folder.Name, true)
		if SubService then
			return LoadContents(SubService, Folder)
		end
	end
end

return LoadContents]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
	</Item>
	<SharedStrings>
		<SharedString md5="yuZpQdnvvUBOTYh1jqZ2cA=="></SharedString>
	</SharedStrings>
</roblox>